<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8" /><title>Object Event Modeling and Simulation</title><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="OEMS_files/ebook.css" rel="stylesheet" type="text/css" /><link href="OEMS_files/icons" type="inode/directory" /><meta content="Object Event Modeling and Simulation (OEM&amp;S) represents a general Discrete Event Simulation approach based on object-oriented modeling and event scheduling." name="description" /><style>/*<![CDATA[*/
div.role-book-title-div {
  text-align: center;
}
h1.role-book-title {
  margin: 4em 0;
  padding-bottom: 0;
  border-bottom-style: none;
}
span.button {
  outline: 1px solid;
  background: aliceblue;
}
}/*]]>*/</style></head><body><section class="role-book" id="OEMS"><div class="role-book-title-div"><h1 class="role-book-title">Object Event Modeling and Simulation</h1><div class="role-content" id="OEMS-content-1"><div id="OEMS-content-1__subtitle">For Information Systems Engineering and for<br />
  Discrete Event Simulation Engineering </div><div id="OEMS-content-1__authors">Gerd Wagner <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a></div><p>Copyright ©
  2023-24 Gerd Wagner</p><p><b>Draft version</b>, published
  2024-07-21.</p><figure><img alt="business-process-gearwheels" height="500" src="OEMS_files/Tree-broken-by-lightning.png" width="650" /></figure><section><h2>Abstract</h2><p>This book explains how
  to make models for <em>Information Systems</em> engineering and for
  <em>Discrete Event Simulation</em> engineering using the <em>Unified
  Modeling Language (UML)</em> and the <em>Discrete Event Process Modeling
  Notation (DPMN)</em> and following the paradigm of <em>Object Event Modeling
  and Simulation (OEM&amp;S)</em>, which combines the Software Engineering
  paradigm of <em>Object-Oriented Modeling</em> with the Discrete Event
  Simulation paradigm of <em>Event-Based Simulation</em> (also called<em>
  Event Scheduling</em>).</p><p>The modeling concepts of OEM&amp;S, in
  particular the concepts of <em>objects</em>, <em>events</em> and
  <em>activities</em>, are ontologically grounded on corresponding categories
  of the <em>Unified Foundational Ontology (UFO)</em>.</p></section></div></div><div class="role-frontmatter" id="frontmatter"><section class="role-toc" id="toc"><h1 class="role-toc-title">Table of Contents</h1><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-lof"><a class="role-lof-ref" href="#lof">List of Figures</a></li><li class="role-booklist-entry booklist-entry-for-lot"><a class="role-lot-ref" href="#lot">List of Tables</a></li><li class="role-booklist-entry booklist-entry-for-part"><a class="role-part-ref" href="#OEM-Intro"><span class="role-label"><span class="role-number">I</span>. </span>Object Event Modeling</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#Introduction"><span class="role-label"><span class="role-number">1</span>. </span>Introduction</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#UFO"><span class="role-label"><span class="role-number">1.1</span>. </span>Ontological Foundations of OEM</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#IS-model-to-DES-model"><span class="role-label"><span class="role-number">1.2</span>. </span> Turning an IS Model into a DES Model</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#UML-SysML"><span class="role-label"><span class="role-number">1.3</span>. </span>Modeling Events in UML and SysML</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#RelatedWork"><span class="role-label"><span class="role-number">1.4</span>. </span>Related Work</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#chConceptualModels"><span class="role-label"><span class="role-number">2</span>. </span>Making Conceptual Domain Models</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secCIM"><span class="role-label"><span class="role-number">2.1</span>. </span>Making Conceptual Information Models</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ObjectTypes_CIM"><span class="role-label"><span class="role-number">2.1.1</span>. </span>Modeling Object Types</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#EventTypes_CIM"><span class="role-label"><span class="role-number">2.1.2</span>. </span>Modeling Event Types</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ActivityTypes_CIM"><span class="role-label"><span class="role-number">2.1.3</span>. </span>Modeling Activity Types</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secCIM-ParticipationAssociations"><span class="role-label"><span class="role-number">2.1.4</span>. </span>Modeling Participation Associations</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secCPM"><span class="role-label"><span class="role-number">2.2</span>. </span>Making Conceptual Process Models</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#CPM-EventRuleTable"><span class="role-label"><span class="role-number">2.2.1</span>. </span>Modeling Causal Regularities with Event Rule Tables</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#CPM-OEG"><span class="role-label"><span class="role-number">2.2.2</span>. </span>Modeling Causal Regularities with Object Event Graphs</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#CPM-AN"><span class="role-label"><span class="role-number">2.2.3</span>. </span>Modeling Causal Regularities with Activity Networks</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#DesigModels-IS"><span class="role-label"><span class="role-number">3</span>. </span>Making Design Models for Information Systems</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secIDM-IS"><span class="role-label"><span class="role-number">3.1</span>. </span>Information Design for IS Engineering</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secPDM-IS"><span class="role-label"><span class="role-number">3.2</span>. </span>Process Design for IS Engineering</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secPDM-IS-FlexibleBPs"><span class="role-label"><span class="role-number">3.2.1</span>. </span>Design of Flexible Business Processes</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secPDM-IS-WorkflowBPs"><span class="role-label"><span class="role-number">3.2.2</span>. </span>Design of Workflow Processes</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#secIDM-FormalSemantics"><span class="role-label"><span class="role-number">4</span>. </span>Formal Semantics of OEM</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#OE-Logic"><span class="role-label"><span class="role-number">4.1</span>. </span>Object Event Logic</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#OE-Class-Models"><span class="role-label"><span class="role-number">4.1.1</span>. </span>Object Event Class Models</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#Interpretations"><span class="role-label"><span class="role-number">4.1.2</span>. </span>Interpretations</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secIDM-Constraints"><span class="role-label"><span class="role-number">4.1.3</span>. </span>Integrity Constraints</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#OE-Tables"><span class="role-label"><span class="role-number">4.1.4</span>. </span>An Interpretation in the Form of Tables</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#DesigModels-DES"><span class="role-label"><span class="role-number">5</span>. </span>Making Design Models for Discrete Event Simulations</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secIDM-DES"><span class="role-label"><span class="role-number">5.1</span>. </span>Making Information Design Models for DES Engineering</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secPDM-DES"><span class="role-label"><span class="role-number">5.2</span>. </span>Making Process Design Models for DES Engineering</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-part"><a class="role-part-ref" href="#ES-Part-Intro"><span class="role-label"><span class="role-number">II</span>. </span>Event-Based Simulation</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#ES-without-Objects"><span class="role-label"><span class="role-number">6</span>. </span>Event-Based Simulation without Objects</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#subsec_The-ES-Formalism"><span class="role-label"><span class="role-number">6.1</span>. </span>The ES Formalism</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#subsec_EGs"><span class="role-label"><span class="role-number">6.2</span>. </span>Event Graphs</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#ES-with-Objects"><span class="role-label"><span class="role-number">7</span>. </span>Event-Based Simulation with Objects</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#subsec_The-OES-Formalism"><span class="role-label"><span class="role-number">7.1</span>. </span>The OES Formalism</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#subsec_OEGs"><span class="role-label"><span class="role-number">7.2</span>. </span>Object Event Graphs</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#SimpleActivities-Intro"><span class="role-label"><span class="role-number">8</span>. </span>Simple Activities</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secCM"><span class="role-label"><span class="role-number">8.1</span>. </span>Conceptual Modeling of Simple Activities</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secDesM"><span class="role-label"><span class="role-number">8.2</span>. </span>Design Modeling of Simple Activities</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#ResourceConstrainedActivities-Intro"><span class="role-label"><span class="role-number">9</span>. </span>Resource-Constrained Activities</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secCM-2"><span class="role-label"><span class="role-number">9.1</span>. </span>Conceptual Modeling of Resource-Constrained Activities</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secDesM-2"><span class="role-label"><span class="role-number">9.2</span>. </span>Resource-Constrained Activities in Simulation Design Models</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secAllocateReleasePattern"><span class="role-label"><span class="role-number">9.3</span>. </span>Introducing Resource-Dependent Activity Scheduling Arrows</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secOrganizationModeling"><span class="role-label"><span class="role-number">9.4</span>. </span>Organization Modeling Concepts</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#ResourceModeling-Intro"><span class="role-label"><span class="role-number">9.5</span>. </span>Resource Modeling</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ResMod-Constraints"><span class="role-label"><span class="role-number">9.5.1</span>. </span>Resource Cardinality Constraints and Multitasking
    Constraints</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ResMod-OrganizationalPositions"><span class="role-label"><span class="role-number">9.5.2</span>. </span>Organizational Positions and Resource Pools</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ResMod-Alternative-resources"><span class="role-label"><span class="role-number">9.5.3</span>. </span>Alternate Resource Pools</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ResMod-Task-priorities"><span class="role-label"><span class="role-number">9.5.4</span>. </span>Task Priorities</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ResMod-Activity-Preemption"><span class="role-label"><span class="role-number">9.5.5</span>. </span>Activity Preemption</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ResMod-Resource-Outages"><span class="role-label"><span class="role-number">9.5.6</span>. </span>Resource Outages</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#secPN-CM"><span class="role-label"><span class="role-number">10</span>. </span>Conceptual Modeling of Processing Networks</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#secPN-DM"><span class="role-label"><span class="role-number">11</span>. </span>Processing Network Design Models</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-part"><a class="role-part-ref" href="#AgentBasedDES-Intro"><span class="role-label"><span class="role-number">III</span>. </span>Agent-Based Modeling and Simulation</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#BasicAgents"><span class="role-label"><span class="role-number">12</span>. </span>Basic Agents with Perfect Information</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Perception-Action"><span class="role-label"><span class="role-number">12.1</span>. </span>Perception and Action</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Communication"><span class="role-label"><span class="role-number">12.2</span>. </span>Communication</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#InterleavedAgentSimulation"><span class="role-label"><span class="role-number">12.3</span>. </span>Interleaved Agent Simulation</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#BasicAgentsWithImperfectInformation-Intro"><span class="role-label"><span class="role-number">13</span>. </span>Basic Agents with Imperfect Information</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#Contracts-Intro"><span class="role-label"><span class="role-number">14</span>. </span>Contracts</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#CognitiveAgents-Intro"><span class="role-label"><span class="role-number">15</span>. </span>Cognitive Agents</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Bibliography">Bibliography</a></li><li class="role-booklist-entry booklist-entry-for-index"><a class="role-index-ref" href="#_index">Index</a></li></ul></section><section class="role-lof" id="lof"><h1 class="role-lof-title">List of Figures</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-figure-ref" href="#secIDM-IS__figLibraryIDM"><span class="role-label"><span class="role-number">3-1</span>. </span>An <abbr title="Object Event">OE</abbr> class diagram providing an information design
  for the Public Library IS.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPDM-IS-FlexibleBPs__lof__2"><span class="role-label"><span class="role-number">3-2</span>. </span>A business process design model describing a
  flexible business process type.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPDM-IS-WorkflowBPs__figBookPurchasePDM"><span class="role-label"><span class="role-number">3-3</span>. </span>A business process design model describing a
  workflow process type.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secIDM-FormalSemantics__figOEMLmetaclasses"><span class="role-label"><span class="role-number">4-1</span>. </span>The abstract
  syntax of the OE Modeling Language based on KerML
  meta-classes.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsec_OEGs__lof__5"><span class="role-label"><span class="role-number">7-1</span>. </span>A basic DPMN Process Diagram showing an
  <abbr title="Object Event Graph">OEG</abbr>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsec_OEGs__lof__6"><span class="role-label"><span class="role-number">7-2</span>. </span>A basic <abbr title="Object Event">OE</abbr>
  class model defining an object type and three event
  types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM__figWorkstationCIM"><span class="role-label"><span class="role-number">8-1</span>. </span>Introducing an
  activity type in a conceptual information model of a single workstation
  system.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM__figWorkstationCPM"><span class="role-label"><span class="role-number">8-2</span>. </span>Introducing an activity type in a conceptual
  process model of a single workstation system.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label"><span class="role-number">8-3</span>. </span>Going from
  basic OEM to <abbr title="Object Event">OE</abbr> class models by
  introducing activity types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label"><span class="role-number">8-4</span>. </span>Going from basic DPMN to DPMN-A process models by
  introducing Activity rectangles.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM__figWS3PDM2"><span class="role-label"><span class="role-number">8-5</span>. </span>Allocating the workstation as a resource of
  Processing activities</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResourceConstrainedActivities-Intro__figActRes"><span class="role-label"><span class="role-number">9-1</span>. </span>Typically, the performer of an activity is a
  resource object.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResourceConstrainedActivities-Intro__figIndividualsAndTypes"><span class="role-label"><span class="role-number">9-2</span>. </span>Activity
  types may have special properties representing resource
  roles.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label"><span class="role-number">9-3</span>. </span>A conceptual information model of the activity
  type &quot;examinations&quot; with resource roles.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label"><span class="role-number">9-4</span>. </span>A conceptual
  process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label"><span class="role-number">9-5</span>. </span>A conceptual information
  model with doctors and patients as people.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label"><span class="role-number">9-6</span>. </span>Adding the
  activity type &quot;walks to room&quot; to the conceptual information
  model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM2"><span class="role-label"><span class="role-number">9-7</span>. </span>A
  conceptual process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">9-6</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM3"><span class="role-label"><span class="role-number">9-8</span>. </span>An improved process model based on the
  information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">9-6</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label"><span class="role-number">9-9</span>. </span>Displaying the process owner and activity
  performers in a conceptual process model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figExclusiveResByType"><span class="role-label"><span class="role-number">9-10</span>. </span>Adding parallel participation
  multiplicities for rooms participating both in walks and examinations at the
  same time.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label"><span class="role-number">9-11</span>. </span>An
  information model for the simplified design with the resource counters
  nmrOfRooms and nmrOfDoctors.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1PDM1"><span class="role-label"><span class="role-number">9-12</span>. </span>A process design model
  based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">9-11</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label"><span class="role-number">9-13</span>. </span>An <abbr title="Object Event">OE</abbr> class model with resource object
  types for modeling resource roles and pools.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1PDM2"><span class="role-label"><span class="role-number">9-14</span>. </span>A process design model based on the
  information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__lof__26"><span class="role-label"><span class="role-number">9-15</span>. </span>Any resource type
  <i>R</i> extends the pre-defined object type
  <code>Resource</code></a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM3"><span class="role-label"><span class="role-number">9-16</span>. </span>A simplified version of the model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a> </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figWS3IDM3"><span class="role-label"><span class="role-number">9-17</span>. </span>An OE Class Diagram modeling a
  single workstation system with resource-constrained processing activities
  </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label"><span class="role-number">9-18</span>. </span>An
  information design model for decoupling the allocation of rooms and
  doctors.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep2PDM1"><span class="role-label"><span class="role-number">9-19</span>. </span>A process design model based on the
  information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label">Figure <span class="role-number">9-18</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label"><span class="role-number">9-20</span>. </span>Representing the process owner as a Pool and
  activity performers as Lanes in a process design
  model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label"><span class="role-number">9-21</span>. </span>A conceptual modeling
  pattern for a sequence of resource-constrained
  activities</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label"><span class="role-number">9-22</span>. </span>Using <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr> arrows in a
  conceptual process model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label"><span class="role-number">9-23</span>. </span>Displaying the implicit
  allocate-release steps.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figWS3IDM3"><span class="role-label"><span class="role-number">9-24</span>. </span>Modeling WorkStation as a resource
  type</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figWS3PDM3"><span class="role-label"><span class="role-number">9-25</span>. </span>A simplified version of the workstation process
  model using an <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr>
  arrow.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2IdmRewrite"><span class="role-label"><span class="role-number">9-26</span>. </span>A simplified version of the medical
  department information model with Doctor and Room as resource
  types</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2PdmRewrite"><span class="role-label"><span class="role-number">9-27</span>. </span>A simplified version of the medical
  department process model using <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr>
  arrows.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResMod-Constraints__figExamDoc"><span class="role-label"><span class="role-number">9-28</span>. </span>Doctors
  perform examinations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResMod-Constraints__figExamDocRoom"><span class="role-label"><span class="role-number">9-29</span>. </span>An examination requires
  two resources: a room and a doctor.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResMod-Constraints__figExam"><span class="role-label"><span class="role-number">9-30</span>. </span>The class
  <i>Examination</i> implementing the corresponding activity
  type.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResMod-Constraints__figLoadWheelLoaders"><span class="role-label"><span class="role-number">9-31</span>. </span>The loading of a truck requires at
  least one, and can be handled by at most two, wheel
  loaders.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResMod-Constraints__figLoadTruck"><span class="role-label"><span class="role-number">9-32</span>. </span>The class LoadTruck
  implementing the corresponding activity type.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResMod-Constraints__figExamRoom"><span class="role-label"><span class="role-number">9-33</span>. </span>An
  examination room may be used by up to 3 examinations at the same
  time.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ResMod-Constraints__figTeaching"><span class="role-label"><span class="role-number">9-34</span>. </span>The
  teaching of a course is performed by teachers.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-CM__figPredefinedTypes4PN_CM"><span class="role-label"><span class="role-number">10-1</span>. </span>A conceptual OEM class model
  defining built-in types for conceptual PN modeling</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-CM__figDmvCPM"><span class="role-label"><span class="role-number">10-2</span>. </span>A PN model using the new DPMN
  modeling elements of PN Node rectangles, Processing Flow arrows and
  Object-Event Flow arrows</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-CM__figDMVCPM2"><span class="role-label"><span class="role-number">10-3</span>. </span>A DPMN-PN
  process diagram with an Event Scheduling arrow </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figPredefinedTypes4PN"><span class="role-label"><span class="role-number">11-1</span>. </span>An OEM
  class design model defining built-in types for making PN design models</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figWS3PDM-PN"><span class="role-label"><span class="role-number">11-2</span>. </span>A PN
  model of a workstation system using PN Node rectangles and PN Flow arrows</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figWS4PDM-PN"><span class="role-label"><span class="role-number">11-3</span>. </span>A PN model of a
  workstation system where parts may have to be reworked </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figDmvPDM"><span class="role-label"><span class="role-number">11-4</span>. </span>A PN model using the new DPMN modeling
  elements of PN Node rectangles and PN Flow arrows</a></li></ul></section><section class="role-lot" id="lot"><h1 class="role-lot-title">List of Tables</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-table-ref" href="#subsec_The-ES-Formalism__tblEventRulesArrDep"><span class="role-label"><span class="role-number">6-1</span>. </span>Expressing event routines as pure functions that compute state
      changes and follow-up events.</a></li></ul></section></div><section class="role-part" id="OEM-Intro"><h1 class="role-part-title"><span class="role-label">Part <span class="role-number">I</span>. </span>Object Event Modeling</h1><section class="role-chapter" id="Introduction"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction</h1><p>The world consists of objects and events. “Smiles, walks, dances,
  weddings, explosions, hiccups, hand-waves, arrivals and departures, births
  and deaths, thunder and lightning: the variety of the world seems to lie not
  only in the assortment of its ordinary citizens—animals and physical
  objects, and perhaps minds, sets, abstract particulars—but also in the sort
  of things that happen to or are performed by them” (Casati and Varzi
  2015).</p><p>While research in <em>Business Process Modeling</em> has
  focused on events and processes, neglecting objects, research in
  <em>Conceptual Modeling</em> for <em>Information Systems</em> engineering
  has focused on objects, neglecting events. <em>Object Event Modeling
  (OEM)</em> reconciles both perspectives, giving equal weight to objects and
  events as two kinds of entities.</p><p><abbr title="Object Event Modeling">OEM</abbr> is a new paradigm for modeling
  <em>discrete dynamical systems</em>, including organizations and their
  process-supportive information systems. <abbr title="Object Event Modeling">OEM</abbr> combines information modeling with
  discrete process modeling.</p><p>An <em>Object Event (OE) model</em> is a
  triple ⟨<i>OT, ET, R</i>⟩, consisting of </p><ol>
      <li>a set of <em>object types</em> <i>OT</i>,</li>

      <li>a set of <em>event types</em> <i>ET</i>, and</li>

      <li>a set of <em>event rules</em> <i>R</i>, which capture <em>causal
      regularities</em>.</li>
    </ol><p>Both object types and event types are defined with attributes,
  operations and constraints, like classes in UML class models. Attributes are
  defined with a name and a <em>range</em> (also called <em>codomain</em>),
  which is either a datatype or another entity type. Special attributes, also
  called <em>reference attributes</em>, represent associations, hence their
  range is an entity type.</p><p>While object types and event types can be
  defined in an information model, e.g., visually as a <em>UML Class
  Diagram</em> or textually in the form of class definitions, event rules can
  be defined visually in a discrete process model diagram, such as an
  <em>Object Event Graph</em> or an <em>Activity Network</em>, or textually in
  the form of rule statements. Thus, an <abbr title="Object Event">OE</abbr>
  model is provided by a combination of an information model with a discrete
  process model.</p>The formal semantics of an <abbr title="Object Event">OE</abbr> model ⟨<i>OT, ET, R</i>⟩ is defined in (<a href="#Bibliography__Wag2017">Wagner 2017</a>) in the form of an <i lang="en-US">Abstract State Machine</i>, which is an expressive kind of
  state transition system, whose state structure is defined by the object and
  event types of <i>OT</i> and <i>ET</i>, and whose transition functions are
  provided by the event rules of <i>R</i>. Since an <abbr title="Object Event">OE</abbr> model is executable, it is a special type of
  a <em>Discrete Event Simulation (DES)</em> model.<p>In <abbr title="Object Event Modeling">OEM</abbr>, an information model defines the
  types of objects, events and activities of a problem domain, with their
  attributes, associations, operations and constraints, typically in the form
  of an <em><abbr title="Object Event">OE</abbr> Class Model</em>, which is a
  UML Class Model with the class categories «object type», «event type» and
  «activity type». In <abbr title="Object Event Modeling">OEM</abbr>, an
  activity is a special kind of non-instantaneous event that is composed of an
  instantaneous activity start event followed by an instantaneous activity end
  event.</p><p><abbr title="Object Event Modeling">OEM</abbr> has originally
  been developed as an approach for DES modeling (<a href="#Bibliography__Wag2018">Wagner 2018</a>), and only later, in
  (<a href="#Bibliography__Wag2022">Wagner 2022</a>), for
  <em>Information System (IS)</em> modeling. Essentially, the same types of
  entities, and their associations, as well as the same types of processes,
  have to be modeled both for making a DES model of, and for making a
  <em>process-supportive</em> IS model for, an organization.</p><p>Since DES
  engineering projects and IS engineering projects have different goals, they
  need different (but nevertheless overlapping) models. However, one important
  case is the simulation of an IS in the broader sense, including the
  interactions between the IS and its users, which can also be viewed as the
  simulation of an organization as a <em>discrete dynamical system</em>
  including the organization's IS as a subsystem. In this case, the DES model
  is an extension of the IS model and the steps needed for turning an IS model
  into a DES model are sketched in <a class="role-section1-ref" href="#IS-model-to-DES-model"><span class="role-label">Section <span class="role-number">1.2</span></span></a></p><section class="role-section1" id="UFO"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.1</span>. </span>Ontological Foundations of OEM</h2><p><abbr title="Object Event Modeling">OEM</abbr>’s concepts of
  <em>objects</em> (and <em>object types</em>) as well as <em>events</em> (and
  <em>event types</em>), and the concept of <em>participation
  associations</em> between object types and event types, are ontologically
  grounded on the <em>Unified Foundational Ontology (UFO)</em>, specifically
  on its ontology of endurants/objects (UFO-A) and its ontology of
  perdurants/events (UFO-B) (Guizzardi et al 2022). However, there are several
  open issues concerning the <abbr title="Object Event Modeling">OEM</abbr>
  concepts of (discrete and continuous) processes, activities, causal
  regularities and dynamical systems.</p><p><em>OntoUML</em> is a conceptual
  modeling language based on UML Class Diagrams and UFO. <abbr title="Object Event Modeling">OEM</abbr> has been developed independently
  of, and prior to, the extended version of OntoUML that covers event modeling
  (Almeida, Falbo and Guizzardi. 2019). There are the following
  mismatches:</p><ol lang="en-US">
      <li>In OEM, creation and termination of objects have not (yet) been
      considered and a commitment to a “historical semantics” not only for
      event types, but also for object types, has been avoided. For practical
      modeling purposes it is preferable not to impose a “historical
      semantics” on all object types, which would require to keep terminated
      objects in the universe of discourse (and in the extension of
      corresponding database tables), but only impose such a semantics on
      event types requiring to keep historical events in the universe of
      discourse (and corresponding event records in the underlying
      database).</li>

      <li>While OntoUML only considers history multiplicities at the event
      type association ends of participation associations, OEM allows both for
      snapshot multiplicities and for history multiplicities (see <a class="role-section2-ref" href="#secCIM-ParticipationAssociations"><span class="role-label">Section <span class="role-number">2.1.4</span></span></a>).</li>
    </ol><section lang="en-US"><h3>Processes</h3><p>UFO-B does not (yet) cover
  the ontological foundations of processes as a particular category of
  perdurants. Only recently, Guarino and Guizzardi (<a href="#Bibliography__GuaGui2024">2024</a>) have been proposing a
  new ontological theory of processes essentially stating that </p><ol>
      <li>For allowing the same process to be ongoing (while “accumulating
      events”) and later completed, processes should be considered as
      “variable embodiments” in the sense of (Fine 2022).</li>

      <li>The completion of a process creates a corresponding
      (process-as-)event with the same start and end time.</li>

      <li>There are a number of conceptual distinctions among basic process
      kinds: (1) structurally <i>homogeneous</i> processes, (2)
      <i>intentional</i> processes, and (3) <i>telic</i> processes. E.g.,
      business processes are complex telic processes.</li>
    </ol><p>However, Guarino and Guizzardi do not consider the distinction
  between <em>discrete</em> processes and <i>continuous</i> processes (such as
  the rotation of the earth around the sun). Unlike the former, the latter are
  not “accumulating events”.</p></section><section lang="en-US"><h3>Activities</h3><p>Activities are special processes: they
  may be both ongoing and completed. While completed activities may be loosely
  identified with the corresponding (activity-as-)event, this does not apply
  to ongoing activities.</p><p>In (Fine 2022), activities are defined as
  “processes whose manifestations are sequences of intentional acts of the
  same kind, and are described by verbal expressions such as walking, running,
  eating apples, etc.” However, this concept of activities as
  quasi-homogeneous processes deviates from the ordinary language use of the
  term, e.g., in the area of Business Process Management, where any subprocess
  performed by the same actor(s) can be considered to be an activity.
  </p></section><section lang="en-US"><h3>Causal Regularities</h3><p>In UFO-B,
  causation has only be considered at the level of individuals (in the form of
  events causing other events), but not as a pattern, or <i>causal
  regularity</i>, at the level of types.</p><p>In OEM, <i>event rules</i>
  express causal regularities where events of a certain type cause state
  changes of affected objects and follow-up events.</p></section><section lang="en-US"><h3>Dynamical Systems</h3><p>The concept of dynamical systems
  is widely used in mathematics and the natural sciences, but also in certain
  social sciences such as economics. In some works, the term “discrete
  dynamical system” is mistakenly defined as a dynamical system for which time
  is discrete. </p><p>The general concept rather refers to the nature of the
  state changes of a system. If a system has only continuous state changes, it
  is a continuous dynamical system, while if it has only discrete state
  changes, it is a discrete dynamical system.</p><p>UFO does not (yet) have a
  theory of dynamical systems.</p></section></section><section class="role-section1" id="IS-model-to-DES-model"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.2</span>. </span> Turning an IS Model into a DES Model</h2><p>The steps needed for turning an IS model into a DES model can be
  sketched as follows:</p><ol>
      <li>For each activity type <em>A</em>, (a) for each attribute
      <em>Attr</em> of <em>A, </em>add a function <em>getAttr</em> that
      returns a random value for <em>Attr</em>; (b) add an <em>activity
      duration</em> function, which either returns a constant value
      representing the average duration of activities of this type or a value
      sampled from a probability distribution modeling the random variation of
      the duration of activities of this type. In a simulation run, when an
      activity is started, the simulator computes (a) a random value for each
      attribute <em>Attr</em> by invoking <em>getAttr</em>, (b) its duration
      by invoking the activity duration function.</li>

      <li>Add a <em>recurrence</em> function to each start event type. This
      function may either return a constant value representing the average
      time in-between two consecutive start events of this type or a value
      sampled from a probability distribution modeling the random variation of
      this time. In a simulation run, the simulator computes the first and all
      successive occurrence times of start events of this type by invoking
      this function.</li>

      <li>For each <em>organizational position</em>, add a human <em>resource
      pool</em> consisting of a realistic number of resource objects
      representing staff required for performing activities.</li>

      <li>For each <em>passive resource</em> object type, add a <em>resource
      pool</em> consisting of a realistic number of corresponding resource
      objects.</li>
    </ol></section><section class="role-section1" id="UML-SysML"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.3</span>. </span>Modeling Events in UML and SysML</h2><p>The UML standardization effort has been concerned with
  <em>Object-Oriented (OO)</em> modeling, but it has missed the modeling of
  events and the opportunity of modeling behavior/processes based on a general
  concept of events and their state changes. Instead, UML contributors have
  been obsessed with the computational concept of <em>state machines</em>
  requiring to name all relevant states of an object, which is an approach
  that does not scale.</p><p>It is rather strange that even in the new <em><a href="https://modeling-languages.com/Users/gwagner/Downloads/ptc-23-06-01.pdf">Kernel
  Modeling Language</a></em>, the behavior/process modeling concepts of
  <em>Behaviors</em> and <em>Interactions</em> are defined without even
  mentioning the term “event”.</p><p>Olivé and Raventós (2006) presume that in
  UML, events have not been considered as first-class citizens (as instances
  of event classes), but rather in the limited form of operation invocations,
  due to the desire to separate “structural modeling” from “behavioral
  modeling”.</p><p>The UML-based <em>System Modeling Language (SysML)</em>
  allows modeling “blocks” (representing system components), which can be
  connected via “ports” for allowing data flows and signal flows between
  “blocks”. This approach is good for modeling digital systems, where the
  &quot;ports&quot; of a &quot;block&quot; represent the pins of an electronics component, but it
  is not suitable for modeling other types of discrete dynamical systems such
  as discrete manufacturing systems or supply chain systems.</p><p>UML/SysML
  limit the concept of events to specific uses in State Machine Diagrams and
  Activity Diagrams (“Call Event”,”Change Event”,”Signal Event”,”Time Event”).
  Unlike OEM, UML/SysML do not support a general concept of events, which
  would include UI events and business events.</p></section><section class="role-section1" id="RelatedWork"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.4</span>. </span>Related Work</h2><p>Unlike in the field of DES, in the field of IS engineering the idea
  of modeling events as entities in information models and combining this with
  modeling objects is not new. Already Peter Chen (1976), in his seminal paper
  proposing <em>Entity-Relationship (E-R)</em> modeling, suggested that both
  objects and events should be modelled as entities: “A specific person,
  company, or event is an example of an entity”. Motivated by the importance
  of events such as sales, purchases, or cash receipts, in accounting,
  McCarthy (1979) has proposed to model these events, along with objects, as
  entities in E-R models  However, neither Chen nor McCarthy considered the
  fundamental semantic differences between these two kinds of entities and
  treated them in the same way.</p><p>Independently of each other, Allen and
  March (2003) as well as Olivé and Raventós (2006) have proposed modeling
  events as entities in information models taking into consideration how they
  affect the state of objects.</p><p>Allen and March (2003) propose to include
  the events responsible for object state changes as entities in an E-R model
  arguing that this approach is preferable to temporal database approaches
  whenever temporality is needed. March and Allen (2009), by stating that “an
  information system must be conceptualized as an event-processing mechanism
  and an event as the cause of the transition from an initial state to a
  subsequent state via the application of its rules”, already have been aware
  of the concept of <em>event rules</em> as transition functions, which is the
  basis of the semantics of DPMN process models (<a href="https://www.informs-sim.org/wsc17papers/includes/files/056.pdf" rel="noopener" target="_blank">Wagner 2017</a>).</p><p>Olivé and Raventós
  (2006) propose modelling events as entities and event types as classes with
  a special <em>effect()</em> operation in UML class models. Their
  <em>effect()</em> operation essentially corresponds to the OEM concept of
  <em>event rule</em>s, or the event handlers <em>onEvent()</em> and
  <em>onActivityEnd()</em> in OEMjs. Olivé and Raventós integrate information
  and behavior/process modeling in their extended form of UML class diagrams.
  However, it seems preferable to separate behavior/process modeling from
  information modeling. While the latter is in charge of defining the types of
  objects, events and activities (including their attributes, associations,
  operations and constraints), the former is in charge of defining event
  rules, which define the effects of events and the admissible sequences of
  events.</p><p>Neither Allen and March nor Olivé and Raventós have made a
  distinction between instantaneous events and activities.</p></section></section><section class="role-chapter" id="chConceptualModels"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">2</span>. </span>Making Conceptual Domain Models</h1><p>A <dfn>conceptual domain model</dfn> describes a problem domain (or
  real-world system under investigation) by describing its relevant types of
  <em>objects</em> and <em>events</em> in an information model (typically in
  the form of a class diagram), and by describing its <em>causal
  regularities</em>, or its dynamics, in a process model in the form of
  <em>event rules</em>, e.g., expressed in an <em>Object Event Graph</em>,
  helping to understand what's going on in the system.</p><section class="role-section1" id="secCIM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Making Conceptual Information Models</h2><p>A <dfn>conceptual information model</dfn> describes the subject
  matter vocabulary used, e.g., in the system narrative, in a semi-formal way.
  Such a vocabulary essentially consists of names for</p><ul>
      <li><strong>types</strong>, corresponding to <em>classes</em> in OO
      modeling, or <em>unary predicates</em> in formal logic,</li>

      <li><strong>attributes</strong>, corresponding to <em>binary
      predicates</em> in formal logic,</li>

      <li><strong>associations</strong>, corresponding to <em>n-ary
      predicates</em> (with <em>n</em> &gt; 1) in formal logic.</li>
    </ul><p>The main categories of types are <em>object types</em> and
  <em>event types</em>. A simple form of conceptual information model is
  obtained by providing a list of each of them, while a more elaborated model,
  e.g., in the form of a UML class diagram, also defines attributes and
  associations, including those that describe the <em>participation</em> of
  objects (of certain types) in events (of certain types).</p><section class="role-section2" id="ObjectTypes_CIM"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.1.1</span>. </span>Modeling Object Types</h3><p>Object types are modeled in <abbr title="Object Event">OE</abbr>
  class diagrams in the form of class rectangles categorized with the
  (&quot;stereotype&quot;) keyword «object type». </p>As an illustrating example,
  consider a public library, which lends book copies to its users. For this
  organization, the most important object types are <i>Book</i>,
  <i>BookCopy</i>, <i>Person</i>, and <i>LibraryUser</i>, as described by the
  following class diagram:<figure><img src="OEMS_files/PublicLibrary-Obj_CIM.svg" width="300" /></figure><p>This model includes two <em>associations</em> and
  one <em>specialization</em>:</p><ol>
      <li>The functional (<i>many-to-one</i>) association between <i>book
      copy</i> and <i>book</i> associating exactly one book with any book
      copy, and, inversely, zero to many book copies with any book.</li>

      <li>The non-functional (<i>many-to-many</i>) association between
      <i>book</i> and <i>person</i> associating zero to many people as authors
      with a book, and, inversely, zero to many books with any person as one
      of their authors.</li>

      <li>The specialization from <i>library user</i> to <i>person</i> stating
      that any library user is also a person and, hence, has the attributes
      id, name, birth date and biography.</li>
    </ol><p> </p></section><section class="role-section2" id="EventTypes_CIM"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.1.2</span>. </span>Modeling Event Types</h3><p>For simplicity, we often say &quot;event&quot; instead of &quot;instantaneous
  event&quot;. We trust the reader's ability to disambiguate the intended meaning
  of &quot;event&quot;: either denoting the general category of events or the specific
  category of instantaneous events. </p><p>All event types have the implicit
  attributes <em><em>startTime</em>, occurrenceTime</em>, and
  <em>duration</em>, such that </p><p style="padding-left:2em"><em>duration</em> = <em>occurrenceTime</em> −
  <em>startTime</em>.</p><p>For instantaneous events, such as user arrivals
  and departures, only their occurrence time is meaningful (their start time
  is the same as their occurrence time and their duration is zero).</p><p>It
  is important to understand that <em><strong>objects participate in
  events</strong></em> – this is a principle of foundational ontologies such
  as <a href="https://philpapers.org/rec/PORUUF" rel="noopener" target="_blank">UFO</a>. It implies that there are corresponding
  <em>participation associations</em> between an event type and its
  participating object types.</p><p>Event types are modeled in <em><abbr title="Object Event">OE</abbr></em> class diagrams in the form of class
  rectangles categorized with the (&quot;stereotype&quot;) keyword «event type», as
  shown in the following example model:</p><figure id="EventTypes_CIM__figCIM-OEG"><img src="OEMS_files/PublicLibrary-ObjEvt_CIM.svg" width="450" /></figure><p>This
  model includes the four event types <i>arrival</i>, <i>departure</i>,
  <i>book borrowing</i> and <i>book return</i>. While arrival and departure
  events have a library user as their only participating object, <i>book
  borrowing</i> and <i>book return</i> events have both a library user and one
  or more book copies as participants. The participation associations
  expressing these participations are shown with a blue line in the diagram
  above. </p><p>The multiplicity expression ∗ at the <i>arrival</i> and
  <i>departure</i> association ends states that a library user participates in
  zero or many arrival and departure events over time. </p><p>Notice that
  <i>book borrowing</i> and <i>book return</i> events represent corresponding
  <strong>activity end events</strong> since borrowing and returning books
  are, in fact, activities that take some time and, therefore, consist of an
  activity start event followed by an activity end event. Whenever we are not
  interested in considering their start event and their duration, we can
  reduce activities to their (instantaneous) end events, as in the model
  above.</p><p>While we model (types of) <strong>business events</strong> in
  business process (simulation) models, we may also want to model more
  low-level types of events in other kinds of models, such as messaging
  events, user interface events or software application system
  events.</p></section><section class="role-section2" id="ActivityTypes_CIM"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.1.3</span>. </span>Modeling Activity Types</h3><p>It is important to distinguish between <em>ongoing</em> and
  <em>completed</em> activities. Only a completed activity corresponds to an
  event, since events need to have occurred (they need a value for their
  <em>occurrence time</em> attribute), so they are always in the past. As
  explained in (<a href="#Bibliography__GuaGui2024">Guarino and
  Guizzardi 2024</a>), an ongoing activity is an ongoing
  process.</p><p>Activity types have the implicit attributes
  <em><em>startTime</em>, occurrenceTime</em>, and <em>duration</em>, where
  <em>duration</em> = <em>occurrenceTime</em> − <em>startTime</em>. Activities
  occur when they end/complete. </p><p>Activity types are modeled in <abbr title="Object Event">OE</abbr> class diagrams in the form of class
  rectangles categorized with the (&quot;stereotype&quot;) keyword «activity type», as
  shown in the following example model:</p><figure><img id="ActivityTypes_CIM__figCIM-ObjEvtAct" src="OEMS_files/PublicLibrary-ObjEvtAct_CIM.svg" width="450" /></figure><p>This
  model includes the two activity types <i>book lending</i> and <i>book take
  back</i>, both of which have a library user and one or more book copies as
  their participating objects.</p></section><section class="role-section2" id="secCIM-ParticipationAssociations"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.1.4</span>. </span>Modeling Participation Associations</h3><p>When we model event and activity types along with object types in
  <abbr title="Object Event">OE</abbr> class models, we also have to model the
  special associations between them expressing the participation of objects in
  events and activities, like library users participating in <i>arrival</i>
  and <i>departure</i> events, or book copies participating in <i>book
  lending</i> and <i>book take back</i> activities, as shown with blue lines
  in the following diagram:</p><figure id="secCIM-ParticipationAssociations__figCIM-ObjEvtAct"><img src="OEMS_files/PublicLibrary-ObjEvtAct_CIM.svg" width="450" /></figure><p>This
  model includes six participation associations:</p><ol>
      <li>Exactly one library user participates in any <i>arrival</i> or
      <i>departure</i> event, as indicated by the multiplicity '1' shown at
      the <i>library user</i> association end.</li>

      <li>Exactly one library user participates in any <i>book lending</i> or
      <i>book take back</i> activity, as indicated by the multiplicity
      '1'.</li>

      <li>One or more book copies participate in any <i>book lending</i> or
      <i>book take back</i> activity, as indicated by the multiplicity
      '1..*'.</li>
    </ol><p>While the above three statements express the <em><b>participant
  multiplicities</b></em> shown at the association ends of the respective
  participant object types, there are also <em><b>participation
  multiplicities</b></em> shown at the association ends of the respective
  event/activity types. They can be stated as follows:</p><ol>
      <li>A library user participates in zero or more <i>arrival</i> and
      <i>departure</i> events over time, as indicated by the multiplicity
      '*'.</li>

      <li>A library user participates in zero or more <i>book lending</i> and
      <i>book take back</i> activities over time, as indicated by the
      multiplicity '*'.</li>

      <li>A book copy participates in zero or more <i>book lending</i> and
      <i>book take back</i> activities over time, as indicated by the
      multiplicity '*'.</li>
    </ol><p>Notice that we have used the phrase &quot;over time&quot; in these
  participation multiplicity statements. It refers to the history populations
  of the event/activity classes involved.</p><p>Tauzovich (1991) has proposed
  a distinction between snapshot and history cardinality constraints in his
  <em>Temporal Entity-Relationship</em> modeling approach. We adopt this
  distinction for <abbr title="Object Event">OE</abbr> class models, where we
  allow for a <strong>snapshot multiplicity expression</strong> in the form of
  “S:<em>m</em>“, where <em>m</em> is a normal multiplicity expression (such
  as * or 0..1), in addition to the history multiplicity expression at the
  event/activity class side (or association end) of a participation
  association. For avoiding the cluttering of <abbr title="Object Event">OE</abbr> class diagrams, we assume that, by default,
  at the event/activity class side of a participation association, the
  snapshot multiplicity is <i>zero-or-one</i> (0..1). By convention, we only
  display an explicit snapshot multiplicity expression in an <abbr title="Object Event">OE</abbr> class diagram if it is different from the
  default (0..1).</p><p>However, in addition to these <em><b>history
  participation multiplicities</b></em> stating in how many events/activities
  an object may participate <em>over time</em>, we also need to be able to
  express <b><em>snapshot participation multiplicities</em></b> stating in how
  many events/activities an object may participate <em>at a time</em>. We can
  do this by adding a second multiplicity expression to the association end at
  the event/activity type side prefixed with &quot;S:&quot;, as in the following
  diagram:</p><figure><img src="OEMS_files/ParticipationMultiplicity.svg" width="450" /></figure><p>The snapshot participation multiplicity 'S:0..1'
  in this example can be verbalized as follows: a library user participates in
  at most one <i>book lending</i> activity at a time. Since this multiplicity
  is the most frequent type of snapshot participation multiplicity, it is
  assumed as the default (and not shown) in <abbr title="Object Event">OE</abbr> class models. Consequently, in the model
  above, since no snapshot participation multiplicities are shown, all of them
  have by default the multiplicity 0..1, as verbalized by the following
  statements: </p><ol>
      <li>A library user participates in at most one <i>arrival</i> or
      <i>departure</i> event at a time.</li>

      <li>A library user participates in at most one <i>book lending</i> or
      <i>book take back</i> activity at a time.</li>

      <li>A book copy participates in at most one <i>book lending</i> or
      <i>book take back</i> activity at a time.</li>
    </ol></section></section><section class="role-section1" id="secCPM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.2</span>. </span>Making Conceptual Process Models</h2><p>A <dfn>conceptual process model</dfn> should describe the relevant
  <em>causal regularities</em> of the problem domain in the form of <em>event
  rules</em>, providing one event rule for each type of event described in the
  conceptual information model. A conceptual <em>event rule</em> for an event
  type describes the <em>state changes</em> and <em>follow-up events</em>
  caused by events of that type. This includes describing in which temporal
  sequences events may occur, based on conditional and parallel
  branching.</p><p>A conceptual process model can be expressed textually in
  the form of a list or a table of <em>event rule statements</em> or visually
  in the form of an <em>Object Event Graph</em> or an Activity Network, which
  are two forms of <em>DPMN Process Diagram</em>s.</p><section class="role-section2" id="CPM-EventRuleTable"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.2.1</span>. </span>Modeling Causal Regularities with Event Rule Tables</h3><p>Causal regularities can be described with the help of <em>event
  rules</em>, which express, for an event type <i>E</i>, the state changes and
  follow-up events caused by events of that type.</p><p>After identifying the
  relevant types of events of a problem domain, e.g., with the help of an
  <abbr title="Object Event">OE</abbr> class model, we can list the event
  rules for these event types in the form of a table like the
  following:</p><table border="1">
      <thead>
        <tr>
          <th>ON</th>

          <th>STATE CHANGES</th>

          <th>FOLLOW-UP EVENTS</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><i>arrival</i></td>

          <td>record that user has entered the library</td>

          <td><p><i>book lending</i> if user wants to borrow
          books</p><p><i>book take back</i> if user wants to return
          books</p></td>
        </tr>

        <tr>
          <td><i>book lending</i></td>

          <td>set <i>status</i> to LENDED for all lended book copies</td>

          <td><i>departure</i></td>
        </tr>

        <tr>
          <td><i>book take back</i></td>

          <td>set <i>status</i> to AVAILABLE for all returned book copies</td>

          <td><i>departure</i></td>
        </tr>

        <tr>
          <td><i>departure</i></td>

          <td>record that user has departed the library</td>

          <td></td>
        </tr>
      </tbody>
    </table><p>Notice that, for simplicity, we do not consider the case where
  a library user, after arriving at the library, departs some time later
  without returning or borrowing books (e.g., because she couldn't find any
  interesting book). </p><p>A follow-up event does often not happen
  immediately after the causing event, but only later after some kind of
  delay. For instance, after arriving at the library, a user may not
  immediately go to the service desk and return her due book copies, but
  rather first browse the newly arrived books shelf.</p></section><section class="role-section2" id="CPM-OEG"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.2.2</span>. </span>Modeling Causal Regularities with Object Event Graphs</h3><p><strong>Object Event Graphs (OEGs)</strong> extend the Event Graph
  diagram language of (Schruben 1983) by adding object rectangles containing
  declarations of typed object variables and state change statements, as well
  as gateway diamonds for expressing conditional and parallel
  branching.</p><p>The following OEG is based on the object and event type
  definitions of the <abbr title="Object Event">OE</abbr> class diagram shown
  in <a href="#EventTypes_CIM__figCIM-OEG"></a>.</p><figure><img src="OEMS_files/PublicLibrary_CPM.svg" width="450" /></figure><p>Notice that the
  short arrows leading from event circles to gateway diamonds, such as the
  arrow from the <i>arrival</i> event circle to the inclusive gateway diamond
  (representing an inclusive-disjunctive split), or from gateway diamonds to
  event circles, such as the arrow from the inclusive gateway diamond
  (representing an inclusive-disjunctive merge) to the <i>departure</i> event
  circle, have a different meaning than the long arrows coming in to, and
  going out from, event circles. The short arrows are just an auxiliary
  notation for connecting event circles and gateway diamonds, while the long
  arrows represent causation, which implies temporal precedence: </p><ol>
      <li>Each <i>book lending</i> event, and each <i>book take back</i>
      event, must be preceded by a corresponding <i>arrival</i> event.</li>

      <li>Each <i>departure</i> event must be preceded by a corresponding
      <i>book lending</i> or <i>book take back</i> event.</li>
    </ol></section><section class="role-section2" id="CPM-AN"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.2.3</span>. </span>Modeling Causal Regularities with Activity Networks</h3><p><strong>Object Event Graphs (OEGs)</strong> extend the Event Graph
  diagram language by adding object rectangles containing declarations of
  typed object variables and state change statements, as well as gateway
  diamonds for expressing conditional and parallel branching.</p><p>The
  following OEG is based on the object, event and activity type definitions of
  the <abbr title="Object Event">OE</abbr> class diagram shown in <a href="#ActivityTypes_CIM__figCIM-ObjEvtAct"></a>.</p><figure><img src="OEMS_files/PublicLibrary_CPM2.svg" width="500" /></figure><p>This model
  includes the two activity types <i>book lending</i> and <i>book take
  back</i>, both of which have a library user and one or more book copies as
  their participating objects.</p><p>Again, the long arrows represent
  causation, which implies temporal precedence:</p><ol>
      <li>Each <i>book lending</i> activity, and each <i>book take back</i>
      activity, must be preceded by a corresponding <i>arrival</i> event.</li>

      <li>Each <i>departure</i> event must be preceded by a corresponding
      <i>book lending</i> or <i>book take back</i> activity.</li>
    </ol><p>Compare this to the &quot;sequence flow&quot; arrows in BPMN process models
  that are typically intended to represent <strong><em>workflow
  sequencing</em></strong>, which means that follow-up tasks are added to the
  task lists of the human performers in charge who decide when to
  start/perform the follow-up tasks. Our example of a public library business
  process is not a workflow process, since the start of follow-up activities
  is not controlled by their performers.</p></section></section></section><section class="role-chapter" id="DesigModels-IS"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">3</span>. </span>Making Design Models for Information Systems</h1><p>A <dfn>design model</dfn> defines a computational design (for an IS
  or for a simulation) based on a conceptual model. While a conceptual domain
  model is <em>descriptive</em>, describing the domain's structure (its
  entities and relationships) and dynamics, a design model is
  <em>prescriptive</em>, defining design artifacts.</p><p>Unlike a conceptual
  model, a design model is tailored towards the purpose of an IS, or a
  simulation, engineering project. Although the design model is independent of
  a specific technology platform, it is typically based on <em>object-oriented
  (OO) modeling</em> (e.g., with UML Class Diagrams). It can be implemented in
  different ways with any specific technology choice, typically using an OO
  programming approach.</p><p>An <dfn>information design model</dfn> is
  derived from a conceptual information model by <em>choosing the
  design-relevant types</em> of objects and events and enrich them with design
  details, while dropping other object types and event types not deemed
  relevant for the simulation design. Adding design details includes
  specifying <em>property ranges</em> as well as adding multiplicity and other
  types of <em>constraints</em>.</p><p>In á <dfn>process design model</dfn>,
  we refine a conceptual process model. We can do this by identifying those
  types of events that account for the causation of relevant state changes and
  follow-up events by triggering a causal regularity. Any event type modeled
  in the information model could potentially trigger a causal
  regularity.</p><p>For designing an information system (IS), it is essential
  to identify the types of business objects, business events and business
  activities that have to be represented and supported by the IS. This choice
  can be made on the basis of the conceptual domain model and the IS
  requirements provided by the project clients. In the case of our example
  problem, the public library, these types are:</p><ol>
      <li>the business object types <i>Book</i>, <i>BookCopy</i>,
      <i>LibraryUser</i> and <i>Person</i>;</li>

      <li>the business event types <i>Arrival</i> and <i>Departure</i>;</li>

      <li>the business activity types <i>BookLending</i> and
      <i>BookTakeBack</i>.</li>
    </ol><p>Notice that in the design model, as is common in <abbr title="Object-Oriented">OO</abbr> modeling, we use camel case notation for
  all type names.</p><p>The two event types <i>Arrival</i> and
  <i>Departure</i> would only be included in the design model, if it is
  required to record the arrival and departure times of library users, e.g.,
  for getting statistics about the times they spend in the library. This can
  be achieved by having library users present their membership card to card
  readers at the entrance and exit. Each card reading would create a
  corresponding event record in the database of the library IS.</p><section class="role-section1" id="secIDM-IS"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">3.1</span>. </span>Information Design for IS Engineering</h2><p>An <dfn>information design model</dfn> is derived from a conceptual
  information model by <em>choosing the design-relevant types</em> of objects
  and events and enrich them with design details, while dropping other object
  types and event types not deemed relevant for the simulation design. Adding
  design details includes specifying <em>attribute ranges</em> as well as
  adding multiplicity and other types of <em>constraints</em>.</p><p>As
  opposed to the underlying conceptual information model shown in <a class="role-section2-ref" href="#ActivityTypes_CIM"><span class="role-label">Section <span class="role-number">2.1.3</span></span></a>, the following information design
  model provides attribute ranges, standard identifiers, mandatory value and
  key constraint declarations (by default, in UML, attributes are mandatory
  and single-valued).</p><figure id="secIDM-IS__figLibraryIDM"><figcaption><span class="role-label">Figure <span class="role-number">3-1</span>. </span>An <abbr title="Object Event">OE</abbr> class diagram providing an information design
  for the Public Library IS.</figcaption><img src="OEMS_files/PublicLibrary_IDM_IS.svg" width="500" /></figure><p>Notice
  also the notation &quot;/date&quot; in the attribute compartments of the activity
  classes <i>BookLending</i> and <i>BookTakeBack</i>, where the slash prefix
  indicates that the attribute <i>date</i> is a derived attribute (its value
  can be automatically computed from the implicit <i>occurrenceTime</i>
  attribute).</p><p>The class model expressed above with the visual modeling
  language of <abbr title="Object Event">OE</abbr> class diagrams can also be
  expressed textually, following the syntax of <a href="https://www.omg.org/spec/KerML">KerML</a>, in the following
  way:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">objectType <b>Person</b> {
  attribute id : Integer {id};
  attribute name : String;
  attribute birthDate : Date;
  attribute biography : String[0..1];
}
objectType <b>LibraryUser</b> specializes Person {
  attribute userId : Integer {key};
  attribute address : String;
}
eventType <b>Arrival</b> {
  attribute libraryUser : LibraryUser;
}
eventType <b>Departure</b> {
  attribute libraryUser : LibraryUser;
}
objectType <b>Book</b> {
  attribute isbn : String {id};
  attribute title : String;
  attribute year : Integer;
  attribute authors : Person[0..*];
}
enum <b>BookCopyStatusEL</b> {
  AVAILABLE;
  LENDED;
}
objectType <b>BookCopy</b> {
  attribute id : Integer {id};
  attribute isbn : String;
  attribute status : BookCopyStatusEL;
}
activityType <b>BookLending</b> {
  attribute id : Integer {id};
  attribute date : Date;
  attribute libraryUser : LibraryUser;
  attribute bookCopies : BookCopy[1..*];
}
activityType <b>BookTakeBack</b> {
  attribute id : Integer {id};
  attribute date : Date;
  attribute libraryUser : LibraryUser;
  attribute bookCopies : BookCopy[1..*];
}</pre></td></tr></tbody></table></section><section class="role-section1" id="secPDM-IS"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">3.2</span>. </span>Process Design for IS Engineering</h2><p>In a <dfn>process design model</dfn> for a process-supportive IS,
  we refine a conceptual process model by adding all details needed for
  obtaining a computationally complete definition of the business processes to
  be supported. While the arrows in conceptual process models represent the
  causation of follow-up events/activities, the arrows in process design
  models represent <em>workflow sequencing</em>. </p><p>An important question
  in process design is whether the process consist of activities that have to
  be performed in a certain order, like a <em>workflow process</em>, or that
  may be performed in any order, like a <em>flexible business process</em>. In
  the former case, the workflow sequencing of activities has to be defined in
  a suitable process model, while in the latter case, workflow sequencing is
  not possible and it is sufficient to define the state changes that come with
  the performance of activities, either in a process model without arrows or
  in an extended version of the underlying <abbr title="Object Event">OE</abbr> class model.</p><section class="role-section2" id="secPDM-IS-FlexibleBPs"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">3.2.1</span>. </span>Design of Flexible Business Processes</h3><p>In our example of a public library process shown in the following
  conceptual process model diagram, there are only two types of activities,
  <i>book lending</i> and <i>book take back</i>, which may be performed in any
  order, so we deal with a flexible business process.</p><figure><img src="OEMS_files/PublicLibrary_CPM2.svg" width="500" /></figure><p>Notice that
  the sequencing from <i>arrival</i> events to <i>book lending</i> and <i>book
  take back</i> activities in this conceptual process model expresses
  causation and the implied temporal precedence, but does not mean that there
  is a corresponding workflow sequencing such that on arrival, a <i>book
  lending</i> or <i>book take back</i> activity can be added to the task list
  of the library clerk in charge. Rather, since the start times of any <i>book
  lending</i> and <i>book take back</i> activities are controlled by the
  library user going to the service desk, and not by the library clerk, there
  is no workflow sequencing and, consequently, we have to drop the work
  sequence flow arrows in the process design model, as shown in the following
  diagram:</p><figure id="secPDM-IS-FlexibleBPs__lof__2"><img src="OEMS_files/PublicLibrary_PDM2_IS.svg" width="600" /><figcaption><span class="role-label">Figure <span class="role-number">3-2</span>. </span>A business process design model describing a
  flexible business process type.</figcaption></figure><p>This process design
  model, using the names (of types, attributes and operations) defined in the
  information design model shown in <a class="role-section1-ref" href="#secIDM-IS"><span class="role-label">Section <span class="role-number">3.1</span></span></a>, defines in
  the attached object rectangles for all event circles and activity
  rectangles:</p><ol>
      <li>variable names and bindings of these variables to parameter values
      (e.g., by the equality u = a.user assigning the user object reference of
      the expression a.user to the variable u),</li>

      <li>state change statements that will be executed when a corresponding
      event occurs or when a corresponding activity completes.</li>
    </ol><p>These variable definitions and state change statements can also be
  expressed in <i>onEvent</i> and <i>onActivityEnd</i> operations in
  corresponding event and activity classes. In this way, they can be added to
  the <abbr title="Object Event">OE</abbr> class model from <a class="role-section1-ref" href="#secIDM-IS"><span class="role-label">Section <span class="role-number">3.1</span></span></a> by adding these operations to the classes
  concerned, resulting in the following model:</p><figure><img src="OEMS_files/PublicLibrary_IDM-IS-wEvtHandl.svg" width="500" /></figure></section><section class="role-section2" id="secPDM-IS-WorkflowBPs"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">3.2.2</span>. </span>Design of Workflow Processes</h3><p>In a workflow process, an activity to be performed by a specific
  organizational role is scheduled by adding a corresponding task to the task
  list of that role. This form of task scheduling provides the operational
  meaning of sequence flow arrows in business process design models</p><p>In a
  workflow process design model, activity rectangles represent either human
  activities or IS service operations. In the case of human activities, the
  process design model should specify the organizational role that is in
  charge of performing them, e.g., by annotating the activity rectangle with
  the name of the role. For instance, the model shown in <a class="role-figure-ref" href="#secPDM-IS-WorkflowBPs__figBookPurchasePDM"><span class="role-label">Figure <span class="role-number">3-3</span></span></a> specifies the role <i>LibraryClerk</i> as
  being in charge of performing <i>MakeRecommendation</i>
  activities.</p><figure id="secPDM-IS-WorkflowBPs__figBookPurchasePDM"><img src="OEMS_files/PublicLibrary-Purchase_PDM_IS.svg" width="600" /><figcaption><span class="role-label">Figure <span class="role-number">3-3</span>. </span>A business process design model describing a
  workflow process type.</figcaption></figure></section></section></section><section class="role-chapter" id="secIDM-FormalSemantics"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">4</span>. </span>Formal Semantics of OEM</h1><p>An <abbr title="Object Event">OE</abbr> class model is based on a
  set of underlying <em>data types</em> (such as Integer, String, etc.). Data
  types, object types, event types and associations are <em>classifiers</em>,
  which are <em>types</em>. Also, features, such as attributes, are types.
  <em>Specialization</em> is a relationship between types that is subject to
  certain constraints (such as the constraint that object types can only
  specialize other object types). The meta-classes <i>Type</i>,
  <i>Specialization</i>, <i>Classifier</i>, and <i>Feature</i>, shown in <a class="role-figure-ref" href="#secIDM-FormalSemantics__figOEMLmetaclasses"><span class="role-label">Figure <span class="role-number">4-1</span></span></a>, are defined in the <a href="https://www.omg.org/spec/KerML">Kernel Modeling Language</a> developed
  by the Object Management Group as the foundation of SysML v2 and a future
  version UML.</p><figure id="secIDM-FormalSemantics__figOEMLmetaclasses"><figcaption><span class="role-label">Figure <span class="role-number">4-1</span>. </span>The abstract
  syntax of the OE Modeling Language based on KerML
  meta-classes.</figcaption><div><img alt="???" src="OEMS_files/OEML-Metamodel.svg" width="650" /></div></figure><section class="role-section1" id="OE-Logic"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">4.1</span>. </span>Object Event Logic</h2><p>An <abbr title="Object Event">OE</abbr> class model, like the one
  presented in <a class="role-figure-ref" href="#secIDM-IS__figLibraryIDM"><span class="role-label">Figure <span class="role-number">3-1</span></span></a>,
  defines (1) a <strong><em>vocabulary</em></strong> consisting of the names
  of object types, event types, attributes and associations, and (2) a set of
  <strong><em>integrity constraints</em></strong>, which are logical
  statements that have to be satisfied by the (Tarski-model-theoretic)
  interpretations of the model's vocabulary.</p><p>The vocabulary of an <abbr title="Object Event">OE</abbr> class model corresponds to the vocabulary of
  a predicate logical language consisting of names of constants, functions and
  predicates. Object types and event types correspond to unary predicates,
  while attributes correspond to unary functions (or binary predicates), and
  associations correspond to n-ary predicates.</p><section class="role-section2" id="OE-Class-Models"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">4.1.1</span>. </span>Object Event Class Models</h3><p>A <em>multiplicity</em> is an expression <i>l</i>..<i>u</i>
  consisting of a lower bound <i>l</i> being a non-negative integer and an
  upper bound <i>u</i> being either a positive integer or the special symbol ∗
  standing for <em>unbounded</em> such that either <i>u</i> = ∗ or <i>l</i> ≤
  <i>u</i>. Whenever the lower bound <i>l</i> of a multiplicity is greater
  than 0, it defines a minimum cardinality constraint (&quot;there must be at least
  <i>l</i> values&quot;). Whenever the upper bound <i>u</i> of a multiplicity is
  not ∗ (unbounded), it defines a maximum cardinality constraint (&quot;there must
  be at most <i>u</i> values&quot;).</p><p>An <abbr title="Object Event">OE</abbr>
  class model (based on a finite set of data types DT) is a 10-tuple</p><p style="text-align: center">⟨ <i>OT</i>, <i>ET</i>, attr, rng, <i>OAss</i>,
  <i>PAss</i>, ends, mul, mul<sub>s</sub>, sup ⟩</p><p>specifying</p><ol>
      <li>a <em>vocabulary</em> ⟨ <i>OT</i>, <i>ET</i>, attr,<i> OAss</i>,
      <i>PAss</i> ⟩ consisting of finite sets of <em>object</em> and <em>event
      type</em> names <i>OT</i> and <i>ET</i>, a finite set of composite
      <em>attribute</em> names of the form <i>T</i>-<i>a</i> where <i>T</i> ∈
      <i>OT</i> ∪ <i>ET</i> and <i>a</i> ∈ attr(<i>T</i>), such that <i>T</i>
      is both the <em>domain</em> and the <em>namespace</em> of <i>a</i>, a
      finite set of <em>object type association</em> names <i>OAss</i>, and a
      finite set of <em>participation association</em> names <i>PAss</i>;</li>

      <li>a function <i>attr</i> for assigning a set of local attribute names
      to an object or event type;</li>

      <li>a function <i>rng</i> for assigning a <em>range</em> (or
      <em>co-domain</em>) to any attribute <i>T</i>-<i>a</i> with <i>T</i> ∈
      <i>OT</i> ∪ <i>ET</i> and <i>a</i> ∈ attr(<i>T</i>);</li>

      <li>a function <i>ends</i> for assigning a tuple of object types to each
      <em>object type association</em> from <i>OAss</i>, and an ordered pair
      of an object type and an event type to each <em>participation
      association</em> from <i>PAss</i>;</li>

      <li>a function <i>mul</i> for assigning <em>multiplicities</em> both to
      attributes and association ends (<i>mul</i> also expresses <em>history
      multiplicities</em> for event class association ends of participation
      associations);</li>

      <li>a function <i>mul<sub>s</sub></i> for assigning <em>snapshot
      multiplicities</em> to event class association ends of participation
      associations;</li>

      <li><p>a function <i>sup</i> for assigning <em>supertypes</em> to types
      such that</p><ol>
          <li>for all <i>O</i> ∈ <i>OT</i>, sup(<i>O</i>) ⊆ <i>OT</i>,</li>

          <li>for all <i>E</i> ∈ <i>ET</i>, sup(<i>E</i>) ⊆ <i>ET</i>,</li>

          <li><i>Event</i> ∈ sup*(<i>E</i>), where <i>Event</i> is the
          predefined top-level event type and <i>sup</i>* is the transitive
          closure of <i>sup</i>,</li>

          <li>for all <i>T</i> ∈ <i>OT</i> ∪ <i>ET</i> and <i>T'</i> ∈
          sup(<i>T</i>), attr(<i>T')</i> ⊆ attr(<i>T)</i>;</li>
        </ol></li>

      <li>for all event types <i>E</i> ∈ <i>ET</i>, the two implicit
      attributes <i>startTime</i> and <i>occTime</i> are inherited from the
      predefined event type <i>Event</i>.</li>
    </ol><p>If an <abbr title="Object Event">OE</abbr> class model has only
  binary object type associations, it can be reduced to an
  <em>association-free</em> model as a septuple</p><p style="text-align: center">⟨ OT, ET, attr, rng, mul, mul<sub>s</sub>, sup
  ⟩</p><p>by expressing/replacing all associations with the help of
  corresponding <em>reference attributes</em>, the ranges of which are not
  data types, but entity types.</p></section><section class="role-section2" id="Interpretations"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">4.1.2</span>. </span>Interpretations</h3><p>An <strong><em>interpretation</em></strong> of an association-free
  <abbr title="Object Event">OE</abbr> class model is a septuple</p><p style="text-align: center"><b>I</b> = ⟨ <i>T</i>, <i>c</i>, <i>Obj</i>,
  <i>Evt</i>, types, startT, occT, <b><i>I</i></b> ⟩</p><p>such that</p><ol>
      <li><i>T</i> is a linearly ordered set of time instants and <i>c</i> ∈
      <i>T</i> is the <em>current</em> time,</li>

      <li><i>Obj</i> is a finite set of (currently existing) objects, for
      which it is assumed that they have been existing in the past and will
      exist in the future (for simplicity, by assuming a constant universe of
      objects, neither object creation nor object destruction is
      considered),</li>

      <li><i>Evt</i> is a finite set of (past or current) events with
      occt(<i>e</i>) ≤ <i>c</i> for all <i>e</i> ∈ <i>Evt</i>,</li>

      <li><i>types</i> is a function that assigns one or more object types to
      each object from <i>Obj</i> and one or more event types to each event
      from <i>Evt</i> (<i>types</i> assigns an entity its direct types),</li>

      <li><i>startT</i> and <i>occT</i> are functions that assign a start time
      <i>t</i><sub>1</sub> and an occurrence time <i>t</i><sub>2</sub> to each
      event from <i>Evt</i> such that <i>t</i><sub>1</sub> ≤
      <i>t</i><sub>2</sub> ≤ <i>c</i>, and</li>

      <li><p><b><i>I</i></b> is an <strong><em>interpretation
      function</em></strong> for the vocabulary ⟨ OT, ET, attr ⟩ of the class
      model such that</p><ol>
          <li><b><i>I</i></b>(<i>O</i>) ⊆ <i>Obj</i> for all <i>O</i> ∈
          <i>OT</i><i>.</i></li>

          <li><b><i>I</i></b>(<i>E</i>) ⊆ <i>Evt</i> for all <i>E</i> ∈
          <i><i>ET</i></i> and <i><b><i>I</i></b>(<i>Event</i>) =
          <i>Evt</i>.</i></li>

          <li><p>An attribute <i><i>T</i>-<i>a</i></i> with multiplicity
          mul(<i><i>T</i>-<i>a</i></i>) = ⟨ <i>l</i>, <i>u</i> ⟩ is
          interpreted as a function from entities to value sets:
          <b><i>I</i></b>(<i>T</i>-<i>a</i>) : <b><i>I</i></b>(<i>T</i>) →
          2<sup><b><i>I</i></b>(<i>R</i>)</sup> for all attributes
          <i><i>T</i>-<i>a</i></i> with <i>T</i> ∈ <i>OT</i> ∪ <i>ET</i>,
          <i>a</i> ∈ attr(<i>T</i>) and <i>R</i> =
          rng(<i><i>T</i>-<i>a</i></i>), such that for any entity <i>e</i> ∈
          <i><b><i>I</i></b>(T</i>) and its attribute value set <i>val</i> =
          <b><i>I</i></b>(<i>T</i>-<i>a</i>)(<i>e</i>), </p><ol>
              <li>the cardinality of <i>val</i> is greater than <i>l</i> and
              smaller than <i>u</i>,</li>

              <li>if the attribute has a snapshot multiplicity
              mul<sub>s</sub>(<i><i>T</i>-<i>a</i></i>) = ⟨
              <i>l</i><sub>s</sub>, <i>u</i><sub>s</sub> ⟩, that is, if the
              attribute represents the event class association end of a
              participation association, then if <i>l</i><sub>s</sub>&gt; 0,
              the cardinality of the set of current events in the attribute's
              value set, <i>card</i> = #{ <i>evt</i> ∈ <i>val</i> |
              occt(<i>evt</i>) = <i>c</i>}, is greater than
              <i>l</i><sub>s</sub>, and if <i>u</i><sub>s</sub>≠ ∗, then
              <i>card</i> ≤ <i>u</i><sub>s</sub>,</li>

              <li>if <i>T</i> ∈ <i>ET</i>, <i>e</i>.<i>occTime</i> =
              occt(<i>e</i>) and <i>e</i>.<i>duration</i> =
              <i>e</i>.<i>occTime</i> - <i>e</i>.<i>startTime</i>.</li>
            </ol></li>

          <li>For any entity type <i>T</i> ∈ <i>OT</i> ∪ <i>ET</i> and any of
          its supertypes <i>T'</i> ∈ sup(<i>T</i>),
          <b><i>I</i></b>(<i><i>T</i>)</i> ⊆
          <b><i>I</i></b>(<i><i>T</i>').</i></li>
        </ol></li>
    </ol><p>Together with a variable value assignment α : <i>V</i> →
  <i>Obj</i> ∪ <i>Evt</i> for a finite set of entity variables <i>V</i>, an
  interpretation <b>I</b> allows to interpret expressions of the form
  <i>v</i>.<i>a</i> where <i>v</i> is an entity variable and <i>a</i> is a
  (local) attribute name:</p><p style="text-align: center"><b><i>I</i></b><sub>α</sub>(<i>v</i>.<i>a</i>) =
  <b><i>I</i></b>(<i>T</i>-<i>a</i>)(<i>e</i>) where <i>e</i> = α(<i>v</i>)
  and <i>T</i> ∈ types(<i>e</i>) with <i>a</i> ∈ attr(<i>T</i>)</p><p>Whenever
  the range of an attribute <i>T</i>-<i>a</i> is an entity type <i>T'</i>, we
  can interpret expressions of the form
  <i>v</i>.<i>a</i><sub>1</sub>.<i>a</i><sub>2</sub> where
  <i>a</i><sub>1</sub> ∈ attr(<i>T</i>) and <i>a</i><sub>2</sub> ∈
  attr(<i>T'</i>), which are called <em>path expressions</em>, by iterating
  the attribute function application. While it is obvious how this works for
  the case of single-valued attributes <i>a</i><sub>1</sub>, in the case of
  multi-valued attributes <i>a</i><sub>1</sub>, all resulting value sets are
  simply merged together. In this way, we can form path expressions of any
  length greater than zero.</p><h4>Satisfaction of Logical
  Formulas</h4><p>Finally, we can define how an interpretation
  <b>I</b><sub>α</sub>, together with a variable value assignment α for a set
  of data and entity variables, satisfies a logical formula <i>F</i> formed
  with atomic formulas that are connected with the help of the usual logical
  operators, which is symbolically expressed as <b>I</b><sub>α</sub> ⊨
  <i>F</i>. The base case of atomic formulas includes the following two
  forms:</p><ol>
      <li><p><em>Classification atoms</em> have the form <i>C</i>(<i>x</i>)
      where <i>C</i> is a classifier.</p><p><b>I</b><sub>α</sub> ⊨
      <i>C</i>(<i>x</i>) iff α(<i>x</i>) ∈ <b><i>I</i></b>(<i>C</i>).</p></li>

      <li><p><em>Comparison atoms</em> have the form <i>expr</i><sub>1</sub> o
      <i>expr</i><sub>2</sub> where each <i>expr</i><sub>k</sub> is either a
      data literal (from one of the underlying datatypes), a variable, or a
      path expression, and o is one of the usual comparison predicates (=, ≠,
      &lt;, ≤, &gt;, ≥).</p><p><b>I</b><sub>α</sub> ⊨ <i>expr</i><sub>1</sub>
      o <i>expr</i><sub>2</sub> iff ⟨
      <b><i>I</i></b><sub>α</sub>(<i>expr</i><sub>1</sub>),
      <b><i>I</i></b><sub>α</sub>(<i>expr</i><sub>2</sub>) ⟩ ∈
      <b><i>I</i></b>(o), where <b><i>I</i></b>(o) is the binary relation
      providing the interpretation of the comparison predicate.</p></li>
    </ol><p>Complex logical formulas formed with the logical operators ¬, ∧,
  ∨, →, ∀, ∃ are satisfied by an interpretation in the usual
  way.</p><h4>Entailment</h4><p>An <abbr title="Object Event">OE</abbr> class
  model <i>CM</i> entails a logical sentence if the sentence is satisfied by
  all interpretations of the class model:</p><p style="text-align: center"><i>CM</i> ⊨ <i>F</i> iff <b>I</b> ⊨ <i>F</i> for
  all interpretations <b>I</b> of <i>CM</i></p></section><section class="role-section2" id="secIDM-Constraints"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">4.1.3</span>. </span>Integrity Constraints</h3><figure class="right"><img src="OEMS_files/PublicLibrary-Person__IDM_IS.svg" width="150" /></figure><p>An <abbr title="Object Event">OE</abbr> class
  model, like the one presented in <a class="role-figure-ref" href="#secIDM-IS__figLibraryIDM"><span class="role-label">Figure <span class="role-number">3-1</span></span></a>, defines the following
  types of (integrity) constraints:</p><dl>
      <dt>Range Constraints</dt>

      <dd><p>require that an attribute must have a value from the value space
      of the type that has been defined as its range. For instance, a value of
      the attribute Person::birthDate must be a date. These (implicit)
      constraints are expressed in a class diagram by specifying a range for
      all attributes.</p></dd>

      <dt>Mandatory Value Constraints</dt>

      <dd><p>require that an attribute must have a value. These constraints
      are expressed in a class diagram with the help of an attribute
      multiplicity with a lower bound greater than 0. The multiplicity
      expression is enclosed in brackets and appended to the attribute name.
      For instance, in the class diagram to the right, an instance of
      <i>Person</i> must have a <i>name</i> and a <i>birthDate</i>, but need
      not have a <i>biography</i>. Notice that the default multiplicity of an
      attribute is [1], implying that it is mandatory and single-valued.
      </p></dd>

      <dt>Cardinality Constraints</dt>

      <dd><p>apply to multi-valued attributes, only, and require that the
      cardinality of a multi-valued attribute's value set is not less than a
      given minimum cardinality or not greater than a given maximum
      cardinality, as expressed by the attribute's multiplicity.</p></dd>
    </dl><p>In addition to these types of attribute constraints, an <abbr title="Object Event">OE</abbr> class model may specify two further, more
  general, types of constraints:</p><ol>
      <li>a set of <strong><em>classifier invariants</em></strong>
      <i>CInvar</i>, which are ordered pairs of a classifier <i>C</i> and a
      logical formula, or Boolean expression, <i>F</i>(<i>x</i>) with one free
      variable <i>x</i> stating that <i>F</i>(<i>i</i>) holds for all <i>i</i>
      from the extent of <i>C</i>;</li>

      <li>a set of <strong><em>global invariants</em></strong> <i>GInvar</i>,
      which are logical sentences, or Boolean expressions without free
      variables.</li>
    </ol><p>In a class diagram, classifier invariants are expressed within a
  constraint rectangle that is attached to a classifier with the help of a
  dashed line. Global invariants can be expressed within a constraint
  rectangle in a corner of the diagram.</p><p>Interpretations of an <abbr title="Object Event">OE</abbr> class model are required to satisfy all of
  its invariants:</p><ol>
      <li><b>I</b> ⊨ ∀<i>x</i>: <i>C</i>(<i>x</i>) → <i>F</i>(<i>x</i>) for
      all classifier invariants ⟨<i>C</i>, <i>F</i>(<i>x</i>)⟩ ∈
      <i>CInvar</i>.</li>

      <li><b>I</b> ⊨ <i>F</i> for all <i>F</i> ∈ <i>GInvar</i>.</li>
    </ol><p>There are several types of very common classifier invariants that
  can be expressed in a class diagram in the simplified way of an attribute
  annotation in curly braces appended to the attribute declaration:</p><dl>
      <dt>Uniqueness Constraints (also called 'Key Constraints')</dt>

      <dd><p>are expressed with the attribute annotation keyword &quot;key&quot; and
      require that the value of an attribute <i>a</i> is unique among all
      instances of its domain: F(<i>x</i>) ≡ ∀<i>y</i>: <i>C</i>(<i>y</i>) →
      <i>x</i>.<i>a ≠</i> <i>y</i>.<i>a</i>.</p></dd>

      <dt>Interval Constraints</dt>

      <dd><p>are expressed with the attribute annotation keywords &quot;min&quot; and
      &quot;max&quot; and require that the value of a numeric attribute <i>a</i> must be
      in a specific interval [min,max]: F(<i>x</i>) ≡ min ≤ <i>x</i>.<i>a</i>
      ∧ <i>x</i>.<i>a</i> ≤ max.</p></dd>

      <dt>Pattern Constraints</dt>

      <dd><p>are expressed with the attribute annotation keyword &quot;pattern&quot; and
      require that a string attribute's value must match a certain pattern
      defined by a regular expression.</p></dd>
    </dl><p>The attribute annotation keyword &quot;id&quot; implies that the attribute
  is unique and mandatory, and that its values <i>e</i>.<i>a</i> are used as
  standard identifiers for the entities <i>e</i>.</p><p>Examples of global
  invariants are the following:</p><ol>
      <li><p>Each <i>Departure</i> event must be preceded by a corresponding
      <i>Arrival</i> event: </p><p style="text-align: center">∀<i>x</i> [
      <i>Departure</i>(<i>x</i>) → ∃<i>y</i> [ <i>Arrival</i>(<i>y</i>) ∧
      <i>y.libraryUser = x.libraryUser</i> ∧ <i>y</i>.<i>occTime</i> &lt;
      <i>x</i>.<i>occTime</i> ∧ ¬∃<i>z</i> [ <i>Departure</i>(<i>z</i>) ∧
      <i>z.libraryUser = x.libraryUser</i> ∧ <i>y</i>.<i>occTime</i> &lt;
      <i>z</i>.<i>occTime</i> ∧ <i>z</i>.<i>occTime</i> &lt;
      <i>x</i>.<i>occTime</i> ]]]</p></li>

      <li>For each book copy involved in a <i>BookTakeBack</i> activity there
      must be a corresponding preceding <i>BookLending</i> activity involving
      that book copy.</li>
    </ol><p></p></section><section class="role-section2" id="OE-Tables"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">4.1.4</span>. </span>An Interpretation in the Form of Tables</h3><p>An interpretation of an <abbr title="Object Event">OE</abbr> class
  model can be expressed with a suitable set of object tables and event
  tables, which implicitly define (1) a (Herbrand) universe of discourse, (2)
  the types of individual entities, (3) the start time and an occurrence time
  of each event, (4) the interpretations of entity types and their
  attributes.</p><p>An example of an interpretation of (a slightly simplified
  version of) the model presented in <a class="role-figure-ref" href="#secIDM-IS__figLibraryIDM"><span class="role-label">Figure <span class="role-number">3-1</span></span></a> consists of the
  following tables:</p><div style="display:flex; flex-wrap:wrap; justify-content:space-between;"><table border="1">
      <thead>
        <tr>
          <th colspan="2">persons</th>
        </tr>

        <tr>
          <th>id</th>

          <th>name</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>1049</td>

          <td>Tom Banks</td>
        </tr>

        <tr>
          <td>1083</td>

          <td>Mary Swift</td>
        </tr>

        <tr>
          <td>1102</td>

          <td>Liza Miller</td>
        </tr>

        <tr>
          <td>1157</td>

          <td>Su Kang</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th colspan="2">library_users</th>
        </tr>

        <tr>
          <th>id</th>

          <th>address</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>1049</td>

          <td>738 Austin Blv, Manchaca, TX 78652</td>
        </tr>

        <tr>
          <td>1102</td>

          <td>29 Hank St, Austin, TX 73301</td>
        </tr>

        <tr>
          <td>1157</td>

          <td>114 Feritti Dr, Austin, TX 78734</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th colspan="2">books</th>
        </tr>

        <tr>
          <th>isbn</th>

          <th>title</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>006251587X</td>

          <td>Weaving the Web</td>
        </tr>

        <tr>
          <td>0465026567</td>

          <td>Gödel, Escher, Bach</td>
        </tr>

        <tr>
          <td>0465030793</td>

          <td>I Am A Strange Loop</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th colspan="3">book_copies</th>
        </tr>

        <tr>
          <th>id</th>

          <th>isbn</th>

          <th>status</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>2194</td>

          <td>006251587X</td>

          <td>LENDED</td>
        </tr>

        <tr>
          <td>2195</td>

          <td>006251587X</td>

          <td>AVAILABLE</td>
        </tr>

        <tr>
          <td>2196</td>

          <td>006251587X</td>

          <td>AVAILABLE</td>
        </tr>

        <tr>
          <td>1843</td>

          <td>0465026567</td>

          <td>AVAILABLE</td>
        </tr>

        <tr>
          <td>1844</td>

          <td>0465026567</td>

          <td>LENDED</td>
        </tr>

        <tr>
          <td>1172</td>

          <td>0465030793</td>

          <td>LENDED</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th colspan="2">arrivals</th>
        </tr>

        <tr>
          <th><i>occTime</i></th>

          <th>libraryUser</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>20240705T09:03</td>

          <td>1102</td>
        </tr>

        <tr>
          <td>20240705T10:42</td>

          <td>1157</td>
        </tr>

        <tr>
          <td>20240705T13:29</td>

          <td>1157</td>
        </tr>

        <tr>
          <td>20240706T09:01</td>

          <td>1049</td>
        </tr>

        <tr>
          <td>20240706T09:37</td>

          <td>1102</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th colspan="2">departures</th>
        </tr>

        <tr>
          <th><i>occTime</i></th>

          <th>libraryUser</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>20240705T11:17</td>

          <td>1157</td>
        </tr>

        <tr>
          <td>20240705T12:36</td>

          <td>1102</td>
        </tr>

        <tr>
          <td>20240705T15:55</td>

          <td>1157</td>
        </tr>

        <tr>
          <td>20240706T09:58</td>

          <td>1049</td>
        </tr>

        <tr>
          <td>20240706T10:41</td>

          <td>1102</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th colspan="4">book_lendings</th>
        </tr>

        <tr>
          <th><i>startTime</i></th>

          <th><i>occTime</i></th>

          <th>libraryUser</th>

          <th>bookCopies</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>20240705T09:14</td>

          <td>20240705T09:17</td>

          <td>1102</td>

          <td>2195</td>
        </tr>

        <tr>
          <td>20240705T13:46</td>

          <td>20240705T13:53</td>

          <td>1157</td>

          <td>1844, 2194</td>
        </tr>

        <tr>
          <td>20240706T09:08</td>

          <td>20240706T09:12</td>

          <td>1049</td>

          <td>1172</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th colspan="4">book_take_backs</th>
        </tr>

        <tr>
          <th><i>startTime</i></th>

          <th><i>occTime</i></th>

          <th>libraryUser</th>

          <th>bookCopies</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>20240706T09:42</td>

          <td>20240706T09:44</td>

          <td>1102</td>

          <td>2195, 1843</td>
        </tr>

        <tr>
          <td>20240706T09:33</td>

          <td>20240706T09:39</td>

          <td>1049</td>

          <td>2195</td>
        </tr>
      </tbody>
    </table></div><template><p>An interpretation <b>I</b> = ⟨ <i>T</i>,
  <i>c</i>, <i>Obj</i>, <i>Evt</i>, types, startT, occT, <b><i>I</i></b> ⟩ of
  a class model ⟨ OT, ET, attr, rng, mul, mul<sub>s</sub>, sup ⟩ can be
  defined in the form</p><p style="text-align: center"><b>I</b> = ⟨ <i>T</i>,
  <i>c</i>, <i>Obj</i>, <i>Evt</i>, <i>ObjTbls</i>, <i>EvtTbls</i>
  ⟩</p><p>where the interpretation function <b><i>I</i></b> is defined
  implicitly by the two sets <i>ObjTbls</i> = {<i>objects</i><sub>1</sub>,
  <i>objects</i><sub>2</sub>, …} and <i>EvtTbls</i> =
  {<i>events</i><sub>1</sub>, <i>events</i><sub>2</sub>, …} such that</p><ol>
      <li><p>each object type <i>O</i><sub>1</sub> ∈ <i>OT</i> is implicitly
      mapped to a corresponding object table <i>objects</i><sub>1</sub> ∈
      <i>ObjTbls</i> (via a name correspondence) with columns corresponding to
      the attributes of <i>O</i><sub>1</sub> by having the same names and
      satisfying their range constraints in the sense that for all rows
      <i>r</i> ∈ <i>objects</i><sub>1</sub> and all attributes <i>a</i> ∈
      attr(<i>O</i><sub>1</sub>), </p><ol type="a">
          <li>if the range of <i>a</i> is a data type <i>D</i> =
          rng(<i>a</i>), then <i>r</i>[<i>a</i>] ∈ Lit(<i>D</i>), where
          <i>r</i>[<i>a</i>] denotes the data literal contained in the
          <i>objects</i><sub>1</sub> table cell determined by row <i>r</i> and
          column <i>a</i>, and Lit(<i>D</i>) denotes the set of data literals
          associated with <i>D</i>;</li>

          <li>if the range of <i>a</i> is an entity type <i>T</i> =
          rng(<i>a</i>) with a corresponding entity table <i>tbl</i>, then the
          corresponding table column is a foreign key column, that is,
          <i>r</i>[<i>a</i>] ∈ <i>T</i>[<i>a</i>] where <i>T</i>[<i>a</i>]
          denotes</li>
        </ol></li>

      <li>for each event type <i>E</i><sub>1</sub> ∈ <i>ET</i>, there is a
      corresponding event table <b><i>I</i></b>(<i>E</i><sub>1</sub>) =
      <i>events</i><sub>1</sub> ∈ <i>EvtTbls</i> having the two special
      columns <i>startTime</i> and <i>occTime</i> with data literals
      corresponding to values from the temporal domain <i>T</i>, and all other
      columns corresponding to the attributes of <i>E</i><sub>1</sub> by the
      same names and by satisfying their range constraints as for object
      types;</li>

      <li><i>Obj</i> is a finite set of (currently existing) objects, for
      which it is assumed that they have been existing in the past and will
      exist in the future (for simplicity, by assuming a constant universe of
      objects, neither object creation nor object destruction is
      considered),</li>

      <li><i>Evt</i> is a finite set of (past or current) events with
      occt(<i>e</i>) ≤ <i>c</i> for all <i>e</i> ∈ <i>Evt</i>,</li>

      <li><i>types</i> is a function that assigns one or more object types to
      each object from <i>Obj</i> and one or more event types to each event
      from <i>Evt</i> (<i>types</i> assigns an entity its direct types),</li>

      <li><i>startT</i> and <i>occT</i> are functions that assign a start time
      <i>t</i><sub>1</sub> and an occurrence time <i>t</i><sub>2</sub> to each
      event from <i>Evt</i> such that <i>t</i><sub>1</sub> ≤
      <i>t</i><sub>2</sub> ≤ <i>c</i>, and</li>

      <li><p><b><i>I</i></b> is an <strong><em>interpretation
      function</em></strong> for the vocabulary ⟨ OT, ET, attr ⟩ of the class
      model such that</p><ol>
          <li><b><i>I</i></b>(<i>O</i>) ⊆ <i>Obj</i> for all <i>O</i> ∈
          <i>OT</i><i>.</i></li>

          <li><b><i>I</i></b>(<i>E</i>) ⊆ <i>Evt</i> for all <i>E</i> ∈
          <i><i>ET</i></i> and <i><b><i>I</i></b>(<i>Event</i>) =
          <i>Evt</i>.</i></li>

          <li><p>An attribute <i><i>T</i>-<i>a</i></i> with multiplicity
          mul(<i><i>T</i>-<i>a</i></i>) = ⟨ <i>l</i>, <i>u</i> ⟩ is
          interpreted as a function from entities to value sets:
          <b><i>I</i></b>(<i>T</i>-<i>a</i>) : <b><i>I</i></b>(<i>T</i>) →
          2<sup><b><i>I</i></b>(<i>R</i>)</sup> for all attributes
          <i><i>T</i>-<i>a</i></i> with <i>T</i> ∈ <i>OT</i> ∪ <i>ET</i>,
          <i>a</i> ∈ attr(<i>T</i>) and <i>R</i> =
          rng(<i><i>T</i>-<i>a</i></i>), such that for any entity <i>e</i> ∈
          <i><b><i>I</i></b>(T</i>) and its attribute value set <i>val</i> =
          <b><i>I</i></b>(<i>T</i>-<i>a</i>)(<i>e</i>), </p><ol>
              <li>the cardinality of <i>val</i> is greater than <i>l</i> and
              smaller than <i>u</i>,</li>

              <li>if the attribute has a snapshot multiplicity
              mul<sub>s</sub>(<i><i>T</i>-<i>a</i></i>) = ⟨
              <i>l</i><sub>s</sub>, <i>u</i><sub>s</sub> ⟩, that is, if the
              attribute represents the event class association end of a
              participation association, then if <i>l</i><sub>s</sub>&gt; 0,
              the cardinality of the set of current events in the attribute's
              value set, <i>card</i> = #{ <i>evt</i> ∈ <i>val</i> |
              occt(<i>evt</i>) = <i>c</i>}, is greater than
              <i>l</i><sub>s</sub>, and if <i>u</i><sub>s</sub>≠ ∗, then
              <i>card</i> ≤ <i>u</i><sub>s</sub>,</li>

              <li>if <i>T</i> ∈ <i>ET</i>, <i>e</i>.<i>occTime</i> =
              occt(<i>e</i>) and <i>e</i>.<i>duration</i> =
              <i>e</i>.<i>occTime</i> - <i>e</i>.<i>startTime</i>.</li>
            </ol></li>

          <li>For any entity type <i>T</i> ∈ <i>OT</i> ∪ <i>ET</i> and any of
          its supertypes <i>T'</i> ∈ sup(<i>T</i>),
          <b><i>I</i></b>(<i><i>T</i>)</i> ⊆
          <b><i>I</i></b>(<i><i>T</i>').</i></li>
        </ol></li>
    </ol></template><p>These tables implicitly define </p><ol>
      <li>a Herbrand universe consisting of the two sets <i>Obj</i> = {
      p(1049), p(1083), …, lu(1049), lu(1102), …, b(006251587X),
      b(0465026567), …, bc(2194), bc(2195), …} and <i>Evt</i> = {
      a(20240705T09:03,1102), a(20240705T10:42,1157), …,
      d(20240705T11:17,1157), …, bl(20240705T09:17, 1102, 2195), …,
      btb(20240706T09:44, 1102, {2195,1843}), …};</li>

      <li>the types of individual entities, e.g., types( lu(1049)) = {
      <i>LibraryUser</i>, <i>Person</i>);</li>

      <li>the start time and occurrence time of each event with the help of
      the corresponding event table columns;</li>

      <li>the interpretation of entity types: e.g., <b><i>I</i></b>(
      <i>LibraryUser</i>) = { lu(1049), lu(1102), lu(1157)};</li>

      <li>the interpretation of attributes: e.g., <b><i>I</i></b>(
      <i>Person</i>-<i>name</i>) = { 1049: 'Tom Banks', 1083: 'Mary Swift',
      1102: 'Liza Miller', 1157: 'Su Kang'}.</li>
    </ol><p></p></section></section></section><section class="role-chapter" id="DesigModels-DES"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">5</span>. </span>Making Design Models for Discrete Event Simulations</h1><p>A simulation <dfn>design model</dfn> defines a computational design
  for a simulation based on a conceptual model. Unlike the conceptual domain
  model, the design is tailored towards the purpose of the simulation project
  (e.g., for answering certain research questions in a social system analysis
  project or in a technical system engineering project, or for teaching
  certain facts about a system in an educational simulation project). Although
  the design model is independent of a specific technology platform, it is
  typically based on <abbr title="Object-Oriented">OO</abbr> modeling (e.g.,
  with UML diagrams). It can be implemented in different ways with any
  specific technology choice, typically using an <abbr title="Object-Oriented">OO</abbr> programming approach.</p><p>A simulation
  design model for simulating an organization may also be based on an IS
  design model for that organization. We can distinguish two different cases:
  </p><ol>
      <li>If the purpose is to compute certain statistics, then an
      <b>offline</b> simulation design model is made from the IS design model
      by dropping all elements that are not relevant for the purpose of the
      simulation to be built. For instance, if the purpose of our library
      simulation is to compute the organizational performance statistics of
      average and maximal length of the waiting line at the service desk, then
      we can abstract away from the object type <i>Person</i> and the
      attributes <i>Book</i>::<i>title</i>, <i>Book</i>::<i>year</i>, and
      <i>Book</i>::<i>authors</i> described in the domain model shown in <a class="role-section2-ref" href="#EventTypes_CIM"><span class="role-label">Section <span class="role-number">2.1.2</span></span></a>. We may even drop the object types
      <i>Book</i> and <i><i>BookCopy</i></i> altogether, if we just count the
      number of books lended and taken back in the simulation design
      model.<i><i> </i></i></li>

      <li>If the purpose is to support <em>operational decision making</em>,
      then a <strong>digital twin</strong> design model has to be made as an
      extension of the IS design model. For instance, if the purpose of our
      library simulation is to support making decisions like testing if a
      library clerk can take a one hour break without taking the risk of
      overlong waiting lines at the service desk, then a digital twin of the
      library, including all elements of the library IS model, has to be
      made.</li>
    </ol><section class="role-section1" id="secIDM-DES"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">5.1</span>. </span>Making Information Design Models for DES Engineering</h2><p>In addition to the general information modeling issues, there are
  also a few issues, which are specific for simulation modeling:</p><ol>
      <li>The information design model must designate attributes representing
      state variables that are subject to random variation, so they can be
      considered as <em>random variables</em> with an underlying probability
      distribution that is sampled by a corresponding method stereotyped «rv»
      for categorizing it as a <em>random variate</em> sampling method. The
      underlying probability distribution can be indicated in the model
      diagram by appending a symbolic expression, denoting a distribution
      (with parameter values), to the method definition clause. For instance,
      <em>U(1,6)</em> may denote the uniform distribution with lower bound 1
      and upper bound 6, while <em>Exp(1.5)</em> may denote the exponential
      distribution with event rate 1.5.</li>

      <li>The information design model must distinguish between
      <em>exogenous</em> and <em>caused</em> (or <em>endogenous</em>) event
      types. For any exogenous event type, the <em>recurrence</em> of events
      of that type must be specified, typically in the form of a random
      variable, but in some cases it may be a constant (like 'on each
      Monday'). The recurrence defines the elapsed time between two
      consecutive events of the given type (their inter-occurrence time). It
      can be specified within the event class concerned in the form of a
      special operation with the predefined name 'recurrence' and normally
      annotated with a probability distribution expression.</li>

      <li>The information design model must specify a <i>duration()</i>
      function for all activity classes. This function is invoked when a new
      activity is created during a simulation run for computing the value of
      its <i>duration</i> attribute. Normally, the <i>duration()</i> function
      represents a <em>random variable</em>, to be indicated by the stereotype
      «rv» and by appending a probability distribution annotation such as
      <em>Exp(1.5)</em>.</li>

      <li>If the simulation is to deal with <em>objects in space</em>, the
      design model must be based on a choice of <em>space model</em>:
      one-dimensional (1D) discrete space, two-dimensional (2D) discrete space
      (also called <em>grid space</em>), three-dimensional (3D) discrete
      space, and 1D/2D/3D continuous space. The chosen space model implies a
      corresponding form of spatial <em>positions</em> (or
      <em>locations</em>): a 1-, 2- or 3-tuple of integers or decimal
      numbers.</li>
    </ol><p>Following these rules, by extending the IS information design
  model (from <a class="role-section1-ref" href="#secIDM-IS"><span class="role-label">Section <span class="role-number">3.1</span></span></a>) we obtain the following
  model:</p><figure><img src="OEMS_files/PublicLibrary_IDM_DES.svg" width="500" /></figure></section><section class="role-section1" id="secPDM-DES"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">5.2</span>. </span>Making Process Design Models for DES Engineering</h2><p>In a <dfn>process simulation design model</dfn>, we refine a
  conceptual process model by adding all details needed for obtaining a
  computationally complete process simulation model that can be directly
  transformed into simulation code. </p><figure><img src="OEMS_files/PublicLibrary_PDM2_DES.svg" width="600" /></figure></section></section></section><section class="role-part" id="ES-Part-Intro"><h1 class="role-part-title"><span class="role-label">Part <span class="role-number">II</span>. </span>Event-Based Simulation</h1><p><em>Event-Based Simulation (ES)</em> is the most fundamental form
  of Discrete Event Simulation (<a>Pegden 2010</a>). The <abbr title="Event-Based Simulation">ES</abbr> paradigm has been pioneered by
  <em>SIMSCRIPT</em> (<a>Markowitz, Hausner &amp; Karr 1962</a>) and later
  formalized by <em>Event Graphs</em> (<a>Schruben 1983</a>).</p><p><abbr title="Event-Based Simulation">ES</abbr> uses <i>state variables</i> for
  modeling a system’s state and <i>event scheduling</i> with a <i>Future
  Events List</i> for modeling its dynamics. An implementation-agnostic
  definition of <abbr title="Event-Based Simulation">ES</abbr> is provided by
  Event Graphs, which define graphically how an event triggers</p><ol>
      <li>(possibly conditional) <strong>state changes</strong> (in the form
      of variable value assignments) and</li>

      <li>(possibly conditional) <strong>follow-up events</strong>.</li>
    </ol><p>According to Pegden (<a>2010</a>), in <abbr title="Event-Based Simulation">ES</abbr>, the system under investigation is
  viewed as a series of instantaneous events that change its state over time.
  The modeler “defines the events in the system and models the state changes
  that take place when those events occur”. More precisely, the modeler
  defines the <i>types</i> of events that cause <i>state changes</i> and/or
  <i>follow-up events</i>.</p><p>Pegden also explains that in <abbr title="Event-Based Simulation">ES</abbr>,</p><ol>
      <li>a simulation creates events that are supposed to occur in the future
      (called <i>future events</i>),</li>

      <li>future events are scheduled (using an <i>Event Scheduling</i>
      mechanism),</li>

      <li>time advances to the time of the next event (<i>next-event time
      progression</i>),</li>

      <li>the series of events corresponds to a sequence of state transitions
      of a <i>transition system</i> where the “transition logic” of each event
      type is specified in the form of a procedure definition (often called
      <i>event routine</i>).</li>
    </ol><p>Event routines can be expressed in a
  programming-language-independent way using pseudo code as in (<a>Pegden
  2010</a>), or in a (simulation) programming language. In an object-oriented
  programming approach, it is natural to define an event routine as a method
  of the class defining the event type.</p><p>Pegden does not make any attempt
  to clarify the philosophical nature of (types of) events and their
  “transition logic”. Philosophically, (1) all events have
  <i>participants</i>, which are the objects that participate in them; (2) the
  combination of an <em>event type</em> and its <i>event routine</i> results
  in an <strong>event rule</strong> of the form</p><blockquote><b>ON</b>
  <i>event</i> <b>PERFORM</b> <i>state changes</i> <b>SCHEDULE</b>
  <i>follow-up events</i></blockquote><p>representing a <strong>causal
  regularity</strong>.</p><p><em>Object Event Simulation (OES)</em> extends
  <abbr title="Event-Based Simulation">ES</abbr> by adding the modeling
  concepts of <em>objects</em>.</p><section class="role-chapter" id="ES-without-Objects"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">6</span>. </span>Event-Based Simulation without Objects</h1><p>When <em>Event-Based Simulation (ES)</em> was developed in the
  1960's, pioneered by <a>SIMSCRIPT</a>, the software engineering paradigm of
  <em>Object-Oriented (OO)</em> modeling and programming was not yet
  available. Therefore, the real-world objects of a system under investigation
  have not been modeled as objects, but rather the relevant characteristics of
  the (objects of) the system have been modeled in the form of <em>state
  variables</em>.</p><section class="role-section1" id="subsec_The-ES-Formalism"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">6.1</span>. </span>The ES Formalism</h2><p>We illustrate the formal semantics of ES with the help of an
  example. We model a system of one or more service desks, each of them having
  its own queue, as a discrete event system characterized by the following
  narrative:</p><ol>
      <li>Customers arrive at a service desk at random times.</li>

      <li>If there is no other customer in front of them, and the service desk
      is available, they are served immediately, otherwise they have to queue
      up in a waiting line.</li>

      <li>The duration of services varies, depending on the individual
      case.</li>

      <li>When a service is completed, the customer departs and the next
      customer is served, if there is still any customer in the queue.</li>
    </ol><p>The base concepts of ES are:</p><ol>
      <li><em>state variables</em> for describing the state of a system,</li>

      <li>event types,</li>

      <li>event expressions,</li>

      <li>event routines,</li>

      <li>future events lists (FEL).</li>
    </ol><p>A <b><i>state variable</i></b> is declared with a name and a
  <em>range</em>, which is a datatype defining its possible values.</p><p>An
  <b><i>event type</i></b> is defined in the form of a class: with a name, a
  set of property declarations and a set of method definitions, which together
  define the <i>signature</i> of the event type.</p><p>An <b><i>event
  expression</i></b> is a term E<i>(<u>x</u>)@t</i> where</p><ol>
      <li>E is an event type,</li>

      <li><i>t</i> is a parameter for the occurrence time of events,</li>

      <li><i><u>x</u></i> is a (possibly empty) list of event parameters
      <i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, …, <i>x<sub>n</sub></i>
      according to the signature of the event type E.</li>
    </ol><p>For instance, Arrival@<i>t</i> is an event expression for
  describing Arrival events where the signature of the event type Arrival is
  empty, so there are no event parameters, and the parameter <i>t</i> denotes
  the arrival time (more precisely, the occurrence time of the Arrival event).
  An individual event of type E is a <i>ground</i> event expression, <i>e</i>
  = E(<i><u>v</u></i>)@<i>i</i>, where the event parameter list
  <i><u>x</u></i> and the occurrence time parameter <i>t</i> have been
  instantiated with a corresponding value list <i><u>v</u></i> and a specific
  time instant <i>i</i>. For instance, Arrival@1 is a ground event expression
  representing an individual Arrival event.</p>An <b><i>event routine</i></b>
  is a procedure that essentially computes state changes and follow-up events,
  possibly based on conditions on the current state. In practice, state
  changes are often directly performed by immediately updating the state
  variables concerned, and follow-up events are immediately scheduled by
  adding them to the FEL. However, for defining the formal semantics of ES, we
  assume that an event routine is a pure function that computes state changes
  and follow-up events, but does not apply them, as in the rules described in
  <a class="role-table-ref" href="#subsec_The-ES-Formalism__tblEventRulesArrDep"><span class="role-label">Table <span class="role-number">6-1</span></span></a>.<table border="1" id="subsec_The-ES-Formalism__tblEventRulesArrDep" style="border-spacing:0px;width:100%;">
      <caption><span class="role-label">Table <span class="role-number">6-1</span>. </span>Expressing event routines as pure functions that compute state
      changes and follow-up events.</caption>

      <colgroup style="text-align:center;"></colgroup>

      <colgroup></colgroup>

      <colgroup></colgroup>

      <thead>
        <tr>
          <td style="vertical-align:top;"><p><b>Event rule name</b></p></td>

          <td style="text-align:center;"><p><b>ON (event
          expression)</b></p></td>

          <td style="text-align:center;"><p><b>DO (event routine)</b></p></td>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><p>r<i><sub>Arr</sub></i></p></td>

          <td><p>Arrival @ t</p></td>

          <td><p>E’ := { Arrival @ (t + recurrence()) }<br />Δ := { INCREMENT
          queueLength }<br />IF queueLength = 0<br />THEN E’ := E’ ⋃ {
          Departure @ (t + serviceDuration()) }<br />RETURN ⟨ Δ, <i>E'</i>
          ⟩</p></td>
        </tr>

        <tr>
          <td><p>r<i><sub>Dep</sub></i></p></td>

          <td><p>Departure @ t</p></td>

          <td><p>E’ := {}<br />Δ := { DECREMENT queueLength }<br />IF
          queueLength &gt; 1<br />THEN E’ := E’ ⋃ { Departure @ (t +
          serviceDuration()) }<br />RETURN ⟨ Δ, <i>E'</i> ⟩ </p></td>
        </tr>
      </tbody>
    </table><p>An <b><i>event rule</i></b> associates an event expression with
  an <i>event routine F</i>:</p><p class="indented"><b>ON</b>
  E<i>(<u>x</u>)@t</i> <b>DO</b> <i>F( t, <u>x</u>)</i>,</p><p>where the event
  expression E<i>(<u>x</u>)@t</i> specifies the type E of events that trigger
  the rule, and <i>F( t, <u>x</u>)</i> is a function call expression for
  computing a set of <i>state changes</i> and a set of <i>follow-up
  events</i>, based on the event parameter values <i><u>x</u></i>, the event's
  occurrence time <i>t</i> and the current system state, which is accessed in
  the event routine <i>F</i> for testing conditions expressed in terms of
  state variables.</p><p>A <b><i>Future Events List (FEL)</i></b> is a set of
  ground event expressions partially ordered by their occurrence times, which
  represent future time instants either from a discrete or a continuous model
  of time. The partial order implies the possibility of simultaneous events,
  as in the example { Departure@4, Arrival@4 }.</p><section><h5>ES
  Models</h5><p>An <em>ES<b><i> </i></b>model</em> is a triple ⟨ SV, ET, R ⟩
  where</p><ol>
      <li>SV is a set of state variable declarations defining the structure of
      possible system states,</li>

      <li>ET is a set of event type definitions,</li>

      <li>R is a set of event rules expressed in terms of SV and ET.</li>
    </ol><p>We show how to express the example model of a simple service desk
  system as an ES model. The set of state variables is a singleton:</p><p class="indented">SV = { queueLength: NonNegativeInteger}</p><p>There are two
  event types, both having an empty signature:</p><p class="indented">ET = {
  Arrival(), Departure()}</p><p>And there are two event rules:</p><p class="indented">R = { r<i><sub>Arr</sub></i>,
  r<i><sub>Dep</sub></i>}</p><p>which are defined as in Table 1
  above.</p><p>Such a model, together with an initial state (specifying
  initial values for state variables and initial events), defines an ES
  system, which is a transition system where</p><ol>
      <li>system states are defined by value assignments for the state
      variables,</li>

      <li>transitions are provided by event occurrences triggering event rules
      that change the simulation state through changing the system state (by
      changing the values of affected state variables) and the FEL (by adding
      follow-up events).</li>
    </ol><p>Whenever the transitions of an ES system involve computations
  based on random numbers (if the simulation model contains random variables),
  the transition system defined is non-deterministic.</p><p>For instance,
  assuming that the initial system state is <i>S</i><sub>0</sub> =
  {queueLength: 0}, and there is an initial event {Arrival@1}, then, as a
  consequence of applying r<i><sub>Arr</sub></i>, there is a system state
  change {queueLength := 1} and, assuming a random service time of 2 time
  units (as a sample from the underlying probability distribution function), a
  follow-up event Departure@3, which has to be scheduled along with the next
  Arrival event, say Arrival@3 (with a random inter-arrival time of 2),
  because Arrival is an exogenous event type (with a random recurrence).
  Consequently, the next system state is <i>S</i><sub>1</sub> = {queueLength:
  1}.</p><p>We need to distinguish between the <i>system state</i>, like
  <i>S</i><sub>0</sub> = {queueLength: 0}, which is the state of the simulated
  system, and the <i>simulation state</i>, which adds the FEL to the system
  state, like</p><p class="indented"><b><i>S</i></b><sub>0</sub> = ⟨
  {queueLength: 0}, {Arrival@1} ⟩</p><p class="indented"><b><i>S</i></b><sub>1</sub> = ⟨ {queueLength: 1},
  {Arrival@2, Departure@3} ⟩</p><p>Doing one more step, the next transition is
  given by the next event Arrival@2 again triggering r<i><sub>Arr</sub></i>,
  which leads to</p><p class="indented"><b><i>S</i></b><sub>2</sub> = ⟨
  {queueLength: 2}, {Departure@3, Arrival@4} ⟩</p><p>In this way, we get a
  succession of states <b><i>S</i></b><sub>0</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>1</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>2</sub> <span style="font-family:monospace;">→</span> … as a history of the transition
  system defined by the ES model.</p></section><section><h5>Event Rules as
  Functions</h5><p>An event rule <i>r</i> = <b>ON</b> E<i>(<u>x</u>)@t</i>
  <b>DO</b> <i>F( t, <u>x</u>)</i> can be considered as a 2-step function
  that, in the first step, maps an event <i>e</i> =
  E(<i><u>v</u></i>)@<i>i</i> to a parameter-free state change function
  <i>r<sub>e</sub></i> = <i>F( i, <u>v</u>)</i>, which maps a system state to
  a pair ⟨ Δ, <i>E'</i> ⟩ of system state changes Δ and follow-up events
  <i>E'</i>. When the parameters <i>t</i> and<i> <u>x</u></i> of <i>F( t,
  <u>x</u>)</i> are replaced by the values <i>i</i> and <i><u>v</u></i>
  provided by a ground event expression E(<i><u>v</u></i>)@<i>i</i>, we also
  simply write <i>F<sub>i,<u>v</u></sub></i> instead of <i>F( i, <u>v</u>)</i>
  for the resulting parameter-free state change function.</p><p>We say that an
  event rule <i>r</i> is <i>triggered</i> by an event <i>e</i> when the
  event’s type is the same as the rule’s triggering event type. When <i>r</i>
  is triggered by <i>e</i>, we can form the state change function
  <i>r<sub>e</sub></i> = <i>F<sub>i,<u>v</u></sub></i> and apply it to a
  system state <i>S</i> by mapping it to a set of system state changes Δ and a
  set of follow-up events <i>E'</i>:</p><p class="indented"><i>r<sub>e</sub>(S)</i> = <i>F<sub>i,<u>v</u></sub>(S)</i>
  = ⟨ Δ, <i>E'</i> ⟩</p><p>We can illustrate this with the help of our running
  example. Consider the rule r<i><sub>Arr</sub></i> defined in Table 1 above
  triggered by the event Arrival@1 in state <i>S</i><sub>0</sub> =
  {queueLength: 0}. The resulting state change function <i>F</i><sub>1</sub>
  defined by the corresponding event routine from Table 1 maps
  <i>S</i><sub>0</sub> to the set of state changes Δ = { INCREMENT
  queueLength} and the set of follow-up events <i>E'</i> = {Departure@3}. We
  show how the pair ⟨ Δ, <i>E'</i> ⟩ amounts to a transition of the simulation
  state in the next section.</p><p>In ES, a system state change is an update
  of one or more state variables. Such an update is specified in the form of
  an assignment where the right-hand side is an expression that may involve
  state variables. For instance, the state change <span style="font-family:monospace;">INCREMENT queueLength</span> is equivalent to
  the assignment <span style="font-family:monospace;">queueLength
  </span>:=<span style="font-family:monospace;"> queueLength +
  1</span>.</p><p>In general, there may be situations, where we have several
  concurrent events, that is, there may be two or more events occurring at the
  same (next-event) time. Therefore, we need to explain how to apply a set of
  rules <i>R<sub>E</sub></i> triggered by a set of events <i>E</i>, even if
  both sets are singletons in many cases.</p><p>The rule set <i>R</i> of an ES
  model can also be considered as a 2-step function that, in the first step,
  maps a set of events <i>E</i> to a state change function
  <i>R<sub>E</sub></i>, which maps a system state to a pair ⟨ Δ, <i>E'</i> ⟩
  of state changes Δ and follow-up events <i>E'</i>.</p><p>For a given set of
  events <i>E</i> and a rule set <i>R</i>, we can form the set of state change
  functions obtained from rules triggered by events from <i>E</i>:</p><p class="indented"><i>R<sub>E</sub></i> = { <i>r<sub>e</sub></i> : <i>r</i> ∈
  <i>R</i> &amp; <i>e</i> ∈ <i>E</i> &amp; <i>e</i> triggers
  <i>r</i>}</p><p>Notice that the elements <i>C</i> of <i>R<sub>E</sub></i>
  are parameter-free state change functions, which can be applied as a block,
  in parallel, to a system state <i>S:</i></p><p class="indented"><i>R<sub>E</sub>(S)</i> = ⟨ Δ, <i>E'</i> ⟩</p><p>with</p><p class="indented">Δ = ⋃ { Δ<i><sub>C</sub></i> : <i>C</i> ∈
  <i>R<sub>E</sub></i> &amp; <i>C(S)</i> = ⟨ Δ<i><sub>C</sub></i>,
  <i>E'<sub>C</sub></i> ⟩ }<br /><i>E'</i> = ⋃ { <i>E'<sub>C</sub></i> :
  <i>C</i> ∈ <i>R<sub>E</sub></i> &amp; <i>C(S)</i> = ⟨ Δ<i><sub>C</sub></i>,
  <i>E'<sub>C</sub></i> ⟩ }</p><p>Notice that when forming the union of all
  state changes brought about by applying rules from <i>R<sub>E</sub></i>, and
  likewise when forming the union of all follow-up events created by applying
  rules from <i>R<sub>E</sub></i>, the order of rule applications does not
  matter because they do not affect the applicability of each other, so any
  selection function for choosing rules from <i>R<sub>E</sub></i> and applying
  them sequentially will do, and they could also be applied simultaneously if
  such a parallel computation is supported.</p><p>However, computing a set of
  state changes Δ raises the question if this set is, in some sense,
  consistent. A simple, but too restrictive, notion of consistent state
  changes would require that if Δ contains two or more updates of the same
  state variable, all of them must be equivalent (effectively assigning the
  same value). A more liberal notion just requires that if Δ contains two or
  more updates of the same state variable, their collective application must
  result in the same value for it, no matter in which order they are
  applied.</p><p>If Δ contains inconsistent updates for a state variable, this
  may be a bug or a feature of the simulation model. If it is not a bug, a
  conflict resolution policy is needed. The simplest policy is ignoring, or
  discarding, all inconsistent updates. Another common conflict resolution
  policy is based on assigning priorities to event rules.</p><p>Consider again
  our running example with a system state <i>S</i> = {queueLength: 1} and the
  set of next events <i>N</i> = {Arrival@4, Departure@4}. Then,
  R<i><sub>N</sub></i> consists of the two parameter-free change
  functions:</p><ol>
      <li>F<sub>1</sub>: function () {Δ := { INCREMENT queueLength}; IF
      queueLength = 0 THEN <br /> <i>E'</i> := { Departure @ (4 +
      serviceDuration())}; RETURN ⟨ Δ, <i>E'</i> ⟩ }</li>

      <li>F<sub>2</sub>: function () {Δ := { DECREMENT queueLength}; IF
      queueLength &gt; 1 THEN <br /><i> E'</i> := { Departure @ (4 +
      serviceDuration())}; RETURN ⟨ Δ, <i>E'</i> ⟩}</li>
    </ol><p>No matter in which order we apply F<sub>1</sub> and F<sub>2</sub>,
  forming the union of their state changes always results in Δ = {}, because
  the incrementation and decrementation of the variable <i>queueLength</i>
  neutralize each other, and forming the union of their follow-up events
  always results in <i>E'</i> = { Departure@(4+d)} where d is the random value
  returned by the <i>serviceDuration</i>
  function.</p></section><section><h5>An Event Rule Set as a Simulation State
  Transition Function</h5><p>We show that the event rule set R of an ES model
  ⟨ SV, ET, R ⟩ defines a transition function that maps a simulation state ⟨
  <i>S</i>, <i>FEL</i> ⟩ to a successor state ⟨ <i>S'</i>, <i>FEL'</i> ⟩ in 3
  steps:</p><ol>
      <li>R maps the set of next events <i>N</i> extracted from the <i>FEL</i>
      to a set R<i><sub>N</sub></i> of state change functions of rules
      triggered by one of the next events from <i>N</i>.</li>

      <li>R<i><sub>N</sub></i> maps the current system state <i>S</i> to a set
      of state changes Δ and a set of follow-up events <i>E'</i>.</li>

      <li>The pair ⟨ Δ, <i>E'</i> ⟩ amounts to a transition of the current
      simulation state ⟨ <i>S</i>, <i>FEL</i> ⟩ by applying the updates from Δ
      to <i>S</i> yielding <i>S’</i> and by removing <i>N</i> from <i>FEL</i>
      and adding <i>E'</i>.</li>
    </ol><p>We have already explained how to obtain R<i><sub>N</sub></i> from
  R and how to apply R<i><sub>N</sub></i> to <i>S</i> for getting ⟨ Δ,
  <i>E'</i> ⟩ in the previous subsection, so we only need to provide more
  explanation for the last step: processing ⟨ Δ, <i>E'</i> ⟩ for obtaining the
  next simulation state ⟨ <i>S'</i>, <i>FEL'</i> ⟩.</p><p>Let <i>Upd</i>
  denote an update operation that takes a system state <i>S</i> and a set of
  state changes Δ, and returns an updated system state Upd( <i>S, </i>Δ). When
  the system state consists of state variables, the update operation simply
  performs variable value assignments. Using this operation, we can define the
  third step of the simulation state transition function with two sub-steps in
  the following way:</p><ol type="a">
      <li><i>S'</i> = Upd( <i>S, </i>Δ)</li>

      <li><i>FEL' = FEL <span style="font-family:monospace;">−</span> N </i>⋃
      <i>E'</i></li>
    </ol><p>This completes our definition of how the event rule set R of an ES
  model works as a transition function that computes the successor state of a
  simulation state:</p><p class="indented">R(⟨ <i>S</i>, <i>FEL </i>⟩) = ⟨<i>
  S'</i>, <i>FEL'</i> ⟩</p><p>such that for a given initial simulation state
  <b><i>S</i></b><sub>0</sub> = ⟨ <i>S</i><sub>0</sub>,
  <i>FEL</i><sub>0</sub><i> </i>⟩, we obtain a succession of states</p><p class="indented"><b><i>S</i></b><sub>0</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>1</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>2</sub> <span style="font-family:monospace;">→</span> …</p><p>by iteratively applying
  R:</p><p class="indented"><b><i>S</i></b><sub>i+1</sub> = R(
  <b><i>S</i></b><sub>i</sub>)</p><p>Consider again our running example. In
  simple cases we do not have more than one next event, so
  <i>R<sub>N</sub></i> is a singleton and we do not have to apply more than
  one rule at a time. For instance, when</p><p class="indented"><b><i>S</i></b><sub>1</sub> = ⟨{ queueLength: 1},
  {Arrival@2, Departure@3}⟩</p><p>There is only one next event: Arrival@2, so
  we do not have to form a set of applicable rules, but can immediately apply
  the rule triggered by Arrival@2 for obtaining a set of system state changes
  and a set of follow-up events:</p><p class="indented">r<i><sub>Arr</sub></i><sub> </sub>(
  <b><i>S</i></b><sub>1</sub>) = ⟨{ queueLength := 2}, {Arrival@4}⟩</p><p>Now
  consider a simulation state where we have more than one next event, like the
  following one:</p><p class="indented"><b><i>S</i></b><sub>3</sub> = ⟨{
  queueLength: 1}, {Arrival@4, Departure@4}⟩</p><p>We obtain</p><p class="indented">R( <b><i>S</i></b><sub>3</sub>) = ⟨{ queueLength: 1},
  {Arrival@5, Departure@6}⟩</p><p>assuming a random inter-arrival time sample
  of 1 and a random service duration sample of 2.</p></section></section><section class="role-section1" id="subsec_EGs"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">6.2</span>. </span>Event Graphs</h2><p><em>Event Graphs (EGs)</em> have been proposed as a diagram
  language for making <abbr title="Event-Based Simulation">ES</abbr> models by
  Schruben (1983). A node in an EG is visually rendered as a circle and
  represents a typed event variable (such that the node's name is the name of
  the associated event type). An event circle may be annotated with <em>state
  change</em> statements in the form of state variable assignments. An arrow
  (or directed edge) between two event circles (nodes) represents (a) the
  <em>causation</em> of a follow-up event in the case of a <em>conceptual</em>
  process model, or (b) the scheduling of a follow-up event according to the
  <em>event scheduling</em> paradigm in the case of a process simulation
  <em>design</em> model. </p><p>An Event Graph defining an <abbr title="Event-Based Simulation">ES</abbr> model for a service desk system
  with one state variable (<i>Q</i> for queue length) and two event types
  (<i>Arrival</i> and <i>Departure</i>) is shown in the following
  diagram:</p><figure><img src="OEMS_files/ServiceDesk0_EG.svg" width="400" /></figure><p>This model specifies three event rules, one for
  each event circle:</p><ol>
      <li>On each initial event (the leftmost unnamed circle), the variable
      <i>Q</i> is initialized by setting it to 0, and then an <i>Arrival</i>
      event is scheduled to occur immediately.</li>

      <li>When an <em><i>Arrival</i></em> event occurs, the variable <i>Q</i>
      is incremented by 1 and, if <i>Q</i> is equal to 1, a
      <em><i>Departure</i></em> event is scheduled with a delay provided by
      invoking the function <i>serviceTime</i> (representing a random
      variable); in addition (since <em><i>Arrival</i></em> events are
      exogenous), a new <em><i>Arrival</i></em> event is scheduled with a
      delay provided by invoking the function <i>recurrence</i> (also
      representing a random variable).</li>

      <li>When a <em><i>Departure</i></em> event occurs, the variable <i>Q</i>
      is decremented by 1 and, if <i>Q</i> is greater than 0 (that is, if the
      queue is non-empty), another <em><i>Departure</i></em> event is
      scheduled with a delay provided by invoking the function
      <i>serviceTime</i>.</li>
    </ol><p>In Schruben's original notation for <abbr title="Event Graph">EG</abbr>s used above:</p><ol>
      <li><p>There is an initial event (the left-most unnamed circle in the
      example <abbr title="Event Graph">EG</abbr> above) creating the initial
      state with the help of one or more initial state variable assignments
      (here Q := 0) and triggering the real start event (here:
      <i>Arrival</i>). In our improved notation for <abbr title="Event Graph">EG</abbr>s, we will drop this element in favor of
      getting simpler diagrams and assume that the initial state definition is
      taken care of separately and is not part of a process model
      diagram.</p></li>

      <li><p>The recurrence of a start event (here: <i>Arrival</i>) is
      explicitly modeled with the help of a recursive arrow (going from the
      <i>Arrival</i> event circle to the <i>Arrival</i> event circle). In our
      improved notation for <abbr title="Event Graph">EG</abbr>s, this
      recursive arrow is dropped assuming that the type definition of
      exogenous start events includes a recurrence function that is invoked by
      a simulator for automatically scheduling recurrent exogenous events
      (like <i>Arrival</i>).</p></li>

      <li><p>Conditional event scheduling arrows are indicated by annotating
      the arrows with a condition in parenthesis, as shown above for the arrow
      between <i>Arrival</i> and <i>Departure</i> and the (reverse) arrow
      between <i>Departure</i> and <i>Arrival</i>. In our improved notation
      for <abbr title="Event Graph">EG</abbr>s, we replace the parenthesis
      with brackets and use BPMN's notation for conditional &quot;sequence flow&quot;
      arrows with a mini-diamond at the arrow's start as shown below.</p></li>
    </ol><p>The same service desk model is shown in the following diagram
  using the improved notation resulting from these three
  simplifications/modifications:</p><figure><img src="OEMS_files/ServiceDesk0_EG_improved.svg" width="300" /></figure><p>Notice
  that in our improved notation for <abbr title="Event Graph">EG</abbr>s, we
  use a prefix &quot;+&quot; for delay expressions, e.g., writing &quot;+serviceTime()&quot;
  instead of &quot;serviceTime()&quot; as an annotation of the event scheduling arrow
  between <i>Arrival</i> and <i>Departure</i>, for better indicating that the
  expression represents a scheduling delay. Notice also that, to a great
  extent, we use the visual notation of BPMN, but not its semantics (e.g., we
  do not use BPMN's visual distinction between &quot;Start&quot; and &quot;Intermediate&quot;
  events). </p><p><abbr title="Event Graph">EG</abbr>s provide a visual
  modeling language with a precise semantics that captures the fundamental
  event scheduling paradigm. However, <abbr title="Event Graph">EG</abbr>s are
  a rather low-level DES modeling language: they lack a visual notation for
  (conditional and parallel) branching, do not support object-oriented state
  structure modeling (with attributes of objects taking the role of state
  variables) and do not support the concept of activities.</p><p>Formally, an
  <abbr title="Object Event Graph"><abbr title="Event Graph">EG</abbr></abbr>
  is defined on the basis of a set of <em>event types</em> <i>ET</i> and a set
  of <em>state variables</em> <i>V</i> as a directed graph ⟨ <i>N</i>,
  <i>D</i> ⟩ with nodes <i>N</i> and directed edges <i>D</i> ⊆ <i>N</i> ⨉
  <i>N</i> , such that</p><ol>
      <li><p>each node <i>n</i> ∈ <i>N</i> is associated with</p><ol>
          <li>an <em>event type</em> <i>E</i> ∈ <i>ET</i>,</li>

          <li>an <em>event variable</em> <i>e</i> representing an event of
          type <i>E</i>,</li>

          <li>a (possibly empty) set of <em>variable value assignments</em> of
          the form <i>v</i> := <i>expr</i> with <i>v</i> ∈ <i>V</i> and an
          expression <i>expr</i> formed with the help of the event variable
          <i>e</i> and variables from <i>V</i>, defining an <em>on-event state
          transition function</em>;</li>
        </ol></li>

      <li>each directed edge ⟨ <i>n</i><sub>1</sub>, <i>n</i><sub>2</sub> ⟩ ∈
      <i>D</i> may be associated with<ol>
          <li>a numeric <em>delay</em> expression δ possibly expressed with
          the help of the event variable <i>e</i> and variables from
          <i>V</i>,</li>

          <li>a <em>condition</em> (or Boolean expression) <i>C</i> expressed
          with the help of the event variable <i>e</i> and variables from
          <i>V</i>.</li>
        </ol></li>
    </ol></section></section><section class="role-chapter" id="ES-with-Objects"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">7</span>. </span>Event-Based Simulation with Objects</h1><p>Classical <em>Event-Based Simulation (ES)</em> can be extended in a
  natural way by adding the modeling concept of <em>objects</em>, such that
  the characteristics of real-world objects can be captured by the attributes
  of model objects instead of using state variables. The resulting simulation
  paradigm is called <em><strong>Object Event Simulation
  (OES)</strong></em>.</p><p>In this section, summarizing (Wagner 2020), we
  show how to extend Event Graphs by adding the modeling concept of
  <strong><em>objects</em></strong>, resulting in <strong><em>Object Event
  Graphs</em></strong>. The modeling concept of <em>objects</em> (as instances
  of <em>classes</em>) has been pioneered by <a href="http://simula67.at.ifi.uio.no/Archive/artikkel1966cacm.pdf">Dahl and
  Nygaard (1967)</a> in their simulation programming language <em>Simula</em>,
  which initiated the development of the <i><em>Object-Oriented (OO)</em></i>
  modeling and programming paradigm in Software Engineering.</p><section class="role-section1" id="subsec_The-OES-Formalism"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">7.1</span>. </span>The OES Formalism</h2><p>The OEM&amp;S paradigm is based on the <abbr title="Object Event Simulation">OES</abbr> formalism presented in (<a href="#Bibliography__Wag2017">Wagner 2017</a>), which is summarized
  below.</p>Both <em>object types</em> and <em>event types</em> are defined in
  the form of classes: with a name, a set of properties and a set of
  operations, which together define their signature. A <em>property</em> is
  essentially defined by a name and a <em>range</em>, which is either a
  datatype (like Integer or String) or an object type.<p>A set of object types
  <i>OT</i> defines a <em>predicate-logical signature</em> as the basis of a
  logical expression language <i>L<sub>OT</sub></i>: each object type defines
  a unary predicate, and its properties define binary predicates. A state
  change language <i>C<sub>OT</sub></i> based on <i>OT</i> defines state
  change statements expressed with the help of the object type names and
  property names defined by <i>OT</i>. In the simplest case, state change
  statements are property value assignments like <i>o</i>.p<sub>1</sub> := 4
  or <i>o</i>.p<sub>1</sub> := <i>o</i>.p<sub>2</sub> where <i>o</i> is an
  object variable and p<sub>1</sub>, p<sub>2</sub> are property names.</p><p>A
  set of objects <i><u>O</u></i> = {o<sub>1</sub>, o<sub>2</sub>,
  ...o<sub>n</sub>} where each of them has a state in the form of a set of
  <em>slots</em> (property-value pairs) represents a <em>system state</em>,
  that is a state of the real-world system being modeled and simulated. A
  system state <i><u>O</u></i> can be updated by a set of state changes (or,
  more precisely, state change statements) <i>Δ</i> ⊆ <i>C<sub>OT</sub></i>
  with the help of an update operation Upd. For instance, for a system state
  <i><u>O</u></i><sub>1</sub> = {o<sub>1</sub>} with o<sub>1</sub> = {
  p<sub>1</sub>: 2, p<sub>2</sub>: 5} and a set of state changes
  <i>Δ</i><sub>1</sub> = { o<sub>1</sub>.p<sub>1</sub> :=
  o<sub>1</sub>.p<sub>2</sub> } we obtain</p><div style="text-align:center;">Upd<i>( <u>O</u></i><sub>1</sub>,
  <i>Δ</i><sub>1</sub>) = {{ p<sub>1</sub>: 5, p<sub>2</sub>: 5}}</div><p>An
  <i>event expression</i> is a term E<i>(<u>x</u>)@t</i> where</p><ol>
      <li>E is an event type,</li>

      <li><i><u>x</u></i> is a (possibly empty) list of event parameters
      <i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, …, <i>x<sub>n</sub></i>
      according to the signature of the event type E,</li>

      <li><i>t</i> is a parameter for the occurrence time of events.</li>
    </ol><p>For instance, PartArrival(<i>ws</i>)@<i>t</i> is an event
  expression for describing part arrival events where the event parameter
  <i>ws</i> is of type WorkStation, and <i>t</i> denotes the arrival time. An
  individual event of type E is a <i>ground</i> event expression, <i>e</i> =
  E(<i><u>v</u></i>)@<i>i</i>, where the event parameter list <i><u>x</u></i>
  and the occurrence time parameter <i>t</i> have been instantiated with a
  corresponding value list <i><u>v</u></i> and a specific time instant
  <i>i</i>. For instance, PartArrival(ws1)@1 is a ground event expression
  representing an individual PartArrival event occurring at workstation ws1 at
  time 1.</p>A <em>Future Events List (FEL)</em> is a set of ground event
  expressions partially ordered by their occurrence times, which represent
  future time instants either from a discrete or a continuous model of time.
  The partial order implies the possibility of simultaneous events, as in the
  example {ProcessingEnd(ws1)@4, PartArrival(ws1)@4}.<p>An <i>event
  routine</i> is a procedure that essentially computes state changes and
  follow-up events, possibly based on conditions on the current state. In
  practice, state changes are often directly performed by immediately updating
  the objects concerned, and follow-up events are immediately scheduled by
  adding them to the FEL. For the OES formalism, we assume that an event
  routine is a pure function that computes state changes and follow-up events,
  but does not apply them, as illustrated by the examples in the following
  table.</p><table border="1" id="subsec_The-OES-Formalism__tblEvtRules">
      <colgroup style="text-align:center;"></colgroup>

      <colgroup></colgroup>

      <colgroup></colgroup>

      <thead>
        <tr>
          <td style="vertical-align:top;"><p><b>Event rule name / rule
          variables</b></p></td>

          <td style="text-align:center;"><p><b>ON (event
          expression)</b></p></td>

          <td style="text-align:center;"><p><b>DO (event routine)</b></p></td>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><p>r<i><sub>PA</sub> </i></p><p><i>a</i>:
          PartArrival<i><br />ws</i>: WorkStation<br /><i>ws</i> :=
          <i>a</i>.workStation</p></td>

          <td><p>PartArrival(<i>ws</i>) @ <i>t</i></p></td>

          <td><p><i>Δ</i> := { <i>ws</i>.waitingParts.push(
          <i>a</i>.part)}<br /></p><p>IF <i>ws</i>.status = AVAILABLE
          <br />THEN <i>FE</i> :=
          {ProcessingStart(<i>ws</i>)@<i>t</i>+1}<br />ELSE <i>FE</i> :=
          {}</p><p>RETURN ⟨ <i>Δ</i>, <i>FE</i> ⟩</p></td>
        </tr>

        <tr>
          <td><p>r<i><sub>PS</sub></i> </p><i>ps</i>:
          ProcessingStart<i><br />ws</i>: WorkStation<br /><i>ws</i> :=
          <i>ps</i>.workStation</td>

          <td><p>ProcessingStart(<i>ws</i>) @ <i>t</i></p></td>

          <td><p><i>Δ</i> := { ws.status := BUSY}</p><p><i>FE</i> :=
          {ProcessingEnd(<i>ws</i>)@<i>t +
          ProcessingStart.processingTime()</i>}</p><p>RETURN ⟨ <i>Δ</i>,
          <i>FE</i> ⟩ </p></td>
        </tr>

        <tr>
          <td><p>r<i><sub>PE</sub></i> </p><i>pe</i>:
          ProcessingEnd<i><br />ws</i>: WorkStation<br /><i>ws</i> :=
          <i>pe</i>.workStation</td>

          <td><p>ProcessingEnd(<i>ws</i>) @ <i>t</i></p></td>

          <td><p><i>Δ</i> := { ws.waitingParts.pop()}<br />IF
          ws.waitingParts.length = 0 <br />THEN <i>Δ</i> := <i>Δ</i> ∪
          {ws.status := AVAILABLE}</p><p>IF ws.waitingParts.length &gt; 0
          <br />THEN <i>FE</i> := {
          ProcessingStart(<i>ws</i>)@<i>t</i>+1}<br />ELSE <i>FE</i> :=
          {}</p><p>RETURN ⟨ <i>Δ</i>, <i>FE</i> ⟩ </p></td>
        </tr>
      </tbody>
    </table><p>An <b><i>event rule</i></b> associates an event expression with
  an <i>event routine F</i>:</p><div style="text-align:center;"><b>ON</b>
  E<i>(<u>x</u>)@t</i> <b>DO</b> <i>F( t, <u>x</u>)</i>,</div><p>where the
  event expression E<i>(<u>x</u>)@t</i> specifies the type E of events that
  trigger the rule, and <i>F( t, <u>x</u>)</i> is a function call expression
  for computing a set of <i>state changes</i> and a set of <i>follow-up
  events</i>, based on the event parameter values <i><u>x</u></i>, the event's
  occurrence time <i>t</i> and the current system state, which is accessed in
  the event routine <i>F</i> for testing conditions expressed in terms of
  state variables.</p><p>An <em>OE model</em> based on a state change language
  <i>C<sub>OT</sub></i> and a corresponding update operation Upd is a triple
  ⟨<i>OT, ET, R</i>⟩, consisting of a set of object types <i>OT</i>, event
  types <i>ET</i> and event rules <i>R</i>.</p>An <em>OE</em> <i>simulation
  (system) state</i> based on an <abbr title="Object Event">OE</abbr> model
  ⟨<i>OT, ET, R</i>⟩ is a triple <i>S</i> = ⟨<i>t, <u>O</u>, <u>E</u></i>⟩
  with <i>t</i> being the current simulation time, <i><u>O</u></i> being a
  <em>system state</em> (a set of objects instantiating types from <i>OT</i>),
  and <i><u>E</u></i> being a set of <em>imminent</em> events to occur at
  times greater than <i>t</i> (and instantiating types from <i>ET</i>), also
  called <em>Future Event List (FEL)</em>.<p>An event rule <i>r</i> =
  <b>ON</b> E<i>(<u>x</u>)@t</i> <b>DO</b> <i>F( t, <u>x</u>)</i> can be
  considered as a 2-step function that, in the first step, maps an event
  <i>e</i> = E(<i><u>v</u></i>)@<i>i</i> to a parameter-free state change
  function <i>r<sub>e</sub></i> = <i>F( i, <u>v</u>)</i>, which maps a system
  state <i><u>O</u></i> to a pair ⟨ <i>Δ</i>, <i>FE</i> ⟩ of system state
  changes <i>Δ</i> ⊆ <i>C<sub>OT</sub></i> and follow-up events <i>FE</i>.
  When the parameters <i>t</i> and<i> <u>x</u></i> of <i>F( t, <u>x</u>)</i>
  are replaced by the values <i>i</i> and <i><u>v</u></i> provided by a ground
  event expression E(<i><u>v</u></i>)@<i>i</i>, we also simply write
  <i>F<sub>i,<u>v</u></sub></i> instead of <i>F( i, <u>v</u>)</i> for the
  resulting parameter-free state change function.</p><p>We say that an event
  rule <i>r</i> is <i>triggered</i> by an event <i>e</i> when the event's type
  is the same as the rule's event type. When <i>r</i> is triggered by
  <i>e</i>, we can form the state change function <i>r<sub>e</sub></i> =
  <i>F<sub>i,<u>v</u></sub></i> and apply it to a system state <i><u>O</u></i>
  by mapping it to a set of state changes and a set of follow-up
  events:</p><div style="text-align:center;"><i>r<sub>e</sub>(<u>O</u>)</i> =
  <i>F<sub>i,<u>v</u></sub>(<u>O</u>)</i> = ⟨ <i>Δ</i>, <i>FE</i> ⟩</div><p>We
  can illustrate this with the help of our workstation example. Consider the
  rule r<i><sub>PA</sub></i> defined in the table above triggered by the event
  PartArrival(ws1)@1 in state <i><u>O</u></i><sub>0</sub> = {ws1.status:
  AVAILABLE, ws1.waitingParts: []}. We obtain</p><div style="text-align:center;"><i>r<sub>PA</sub>( <u>O</u><sub>0</sub> )</i> =
  <i>F</i><sub>1,ws1</sub><i>( <u>O</u><sub>0</sub> )</i> = ⟨
  <i>Δ</i><sub>1</sub>, <i>FE</i><sub>1</sub> ⟩</div><p>with
  <i>Δ</i><sub>1</sub> = { ws1.waitingParts.push( <i>a</i>.part)} and
  <i>FE</i><sub>1</sub> = {ProcessingStart@2}.</p><p>An <abbr title="Object Event">OE</abbr> model defines a <em>state transition
  system</em> where</p><ol>
      <li><p>A state is a simulation state <i>S</i> = ⟨<i>t, <u>O</u>,
      <u>E</u></i>⟩.</p></li>

      <li><p>A transition of a simulation state <i>S</i> consists of</p><ol>
          <li><p>advancing <i>t</i> to the occurrence time <i>t'</i> of the
          next events <i>NE</i> ⊆ <i><u>E</u></i>, which is the set of all
          imminent events with minimal occurrence time;</p></li>

          <li><p>processing all next events <i>e</i> ∈ <i>NE</i> by applying
          the event rules <i>r</i> ∈ <i>R</i> triggered by them to the current
          system state <i><u>O</u></i> according to</p><div style="text-align:center;"><i>r<sub>e</sub></i>( <i><u>O</u></i> ) =
          ⟨ <i>Δ<sub>e</sub> , FE<sub>e</sub></i> ⟩</div><p>resulting in a set
          of state changes <i>Δ</i> = ∪ {<i>Δ<sub>e</sub></i> | <i>e</i> ∈
          <i>NE</i> } and a set of follow-up events <i>FE</i> = ∪
          {<i>FE<sub>e</sub></i> | <i>e</i> ∈ <i>NE</i> }.</p></li>
        </ol><p>such that the resulting successor simulation state is
      <i>S'</i> = ⟨<i> t', <u>O</u>', <u>E</u>'</i> ⟩ with <i><u>O</u>'</i> =
      Upd( <i><u>O</u></i>, <i>Δ</i>) and <i><u>E</u>'</i> = <i><u>E</u></i> −
      <i>NE</i> ∪ <i>FE</i>.</p></li>
    </ol><p>Notice that the OES formalism first collects all state changes
  brought about by all the simultaneous next events (from the set <i>NE</i>)
  of a simulation step before applying them. This prevents the state changes
  brought about by one event from <i>NE</i> to affect the application of event
  rules for other events from <i>NE</i>, thus avoiding the problem of
  non-determinism through the potential non-confluence (or
  non-serializability) of parallel events.</p><p>OE simulators are computer
  programs that implement the OES formalism. Typically, for performance
  reasons, discrete event simulators do not first collect all state changes
  brought about by all the simultaneous next events (the set <i>NE</i>) of a
  simulation step before applying them, but rather apply them immediately in
  each triggered event routine. However, this approach takes the risk of an
  unreliable semantics of certain simulation models in favor of
  performance.</p></section><section class="role-section1" id="subsec_OEGs"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">7.2</span>. </span>Object Event Graphs</h2><p>The following basic DPMN diagram shows an <abbr title="Object Event Graph">OEG</abbr> defining a process pattern that is
  instantiated by the above discrete event process
  example.</p><figure id="subsec_OEGs__lof__5"><div><img src="OEMS_files/WS1_PDM.svg" width="650" /></div><figcaption><span class="role-label">Figure <span class="role-number">7-1</span>. </span>A basic DPMN Process Diagram showing an
  <abbr title="Object Event Graph">OEG</abbr>.</figcaption></figure><p>This
  process model is based on the following Object Event (OE) class
  model:</p><figure id="subsec_OEGs__lof__6"><div><img src="OEMS_files/WS1_IDM.svg" width="420" /></div><figcaption><span class="role-label">Figure <span class="role-number">7-2</span>. </span>A basic <abbr title="Object Event">OE</abbr>
  class model defining an object type and three event
  types.</figcaption></figure><p>Notice that the multiplicity 1 (standing for
  &quot;exactly one&quot;) at the association end touching the object class
  <i>WorkStation</i> expresses the constraint that exactly one workstation
  must participate in any event of one of the associated types
  (<i>PartArrival</i>, <i>ProcessingStart</i>, or <i>ProcessingEnd</i>), while
  the multiplicity 0..1 (standing for &quot;at most one&quot;) at the other association
  ends (touching one of the three event classes) expresses the constraint
  that, at any moment, a workstation participates in at most one
  <i>PartArrival</i> event, in at most one <i>ProcessingStart</i> event, and
  in at most one <i>ProcessingEnd</i> event. Notice that a further constraint
  should be added: at any moment, a workstation must not participate in both a
  <i>ProcessingStart</i> and a <i>ProcessingEnd</i> event.</p><p>An <abbr title="Object Event Graph">OEG</abbr> specifies a set of chained event
  rules, one rule for each event circle of the model. The above <abbr title="Object Event Graph">OEG</abbr> specifies the following three event
  rules:</p><ol>
      <li>On each <i>PartArrival</i> event, the <i>inputBufferLength</i>
      attribute of the associated <i>WorkStation</i> object is incremented and
      if the workstation's <i>status</i> attribute has the value AVAILABLE,
      then a new <i>ProcessingStart</i> event is scheduled to occur
      immediately.</li>

      <li>When a <em><i>ProcessingStart</i></em> event occurs, the associated
      <i>WorkStation</i> object's <i>status</i> attribute is changed to BUSY
      and a <em><i>ProcessingEnd</i></em> event is scheduled with a delay
      provided by invoking the <i>processingTime</i> function defined in the
      <i>ProcessingStart</i> event class.</li>

      <li>When a <em><i>ProcessingEnd</i></em> event occurs, the
      <i>inputBufferLength</i> attribute of the associated <i>WorkStation</i>
      object is decremented and if the <i>inputBufferLength</i> attribute has
      the value 0, the associated <i>WorkStation</i> object's <i>status</i>
      attribute is changed to AVAILABLE. If the <i>inputBufferLength</i>
      attribute has a value greater than 0, a new
      <em><i>ProcessingStart</i></em> event is scheduled to occur
      immediately.</li>
    </ol><p>The formal (transition system) semantics of <abbr title="Object Event Graph">OEG</abbr>s, based on the semantics of event
  rules as transition functions, has been presented in (<a href="#Bibliography__Wag2017">Wagner 2017</a>). It can be shown that
  the <abbr title="Object Event Graph">OEG</abbr> diagram language is a
  conservative extension of the Event Graph diagram language by means of a
  homomorphic embedding of Event Graphs in <abbr title="Object Event Graph">OEG</abbr>s.</p><p>Formally, an <abbr title="Object Event Graph">OEG</abbr> is defined on the basis of a set of
  object types <i>OT</i> and a set of event types <i>ET</i> as a directed
  graph ⟨ <i>N</i>, <i>D</i> ⟩ with nodes <i>N</i> and directed edges <i>D</i>
  ⊆ <i>N</i> ⨉ <i>N</i> , such that</p><ol>
      <li><p>each node <i>n</i> ∈ <i>N</i> is associated with</p><ol>
          <li>an <em>event type</em> <i>E</i> ∈ <i>ET</i> with event
          participation roles <i>P</i><sub><i>E</i></sub>,</li>

          <li>an <em>event variable</em> <i>e</i> representing an event of
          type <i>E</i>,</li>

          <li>a (possibly empty) set of auxiliary (shortcut) <em>object
          variables</em> <i>o</i> defined with the help of event participation
          roles <i>p</i> ∈ <i>P</i><sub><i>E</i></sub> by setting o :=
          <i>e</i>.<i>p</i>,</li>

          <li>a (possibly empty) set of definitions of <em>on-event object
          state transition functions</em> { f<sub><i>p</i></sub> | <i>p</i> ∈
          <i>P</i><sub><i>E</i></sub> };</li>
        </ol></li>

      <li>each directed edge ⟨ <i>n</i><sub>1</sub>, <i>n</i><sub>2</sub> ⟩ ∈
      <i>D</i> may be associated with<ol>
          <li>a numeric <em>delay</em> expression δ possibly expressed with
          the help of the variables associated with <i>n</i><sub>1</sub>,</li>

          <li>a <em>condition</em> (or Boolean expression) <i>C</i> expressed
          with the help of the variables associated with
          <i>n</i><sub>1</sub>.</li>
        </ol></li>
    </ol></section></section><section class="role-chapter" id="SimpleActivities-Intro"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">8</span>. </span>Simple Activities</h1><p>A simple activity is an activity with zero or more participants, none of which is having a special meaning (such as being a resource or a
  processing object).</p><section class="role-section1" id="secCM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">8.1</span>. </span>Conceptual Modeling of Simple Activities</h2><p>Conceptually, an activity is a composite event that is composed of,
  and temporally framed by, a pair of start and end events. Consequently,
  whenever a model contains a pair of related start and end event types, like
  <i>processing start</i> and <i>processing end </i>in the model of a
  manufacturing workstation shown on the left-hand side of <a class="role-figure-ref" href="#secCM__figWorkstationCIM"><span class="role-label">Figure <span class="role-number">8-1</span></span></a> and <a class="role-figure-ref" href="#secCM__figWorkstationCPM"><span class="role-label">Figure <span class="role-number">8-2</span></span></a>, they
  can be replaced with a corresponding activity type, like <i>processing</i>,
  as shown on the right-hand side.</p><figure class="threecells" id="secCM__figWorkstationCIM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">8-1</span>. </span>Introducing an
  activity type in a conceptual information model of a single workstation
  system.</figcaption><div><img src="OEMS_files/WS_CIM_2.svg" style="min-width:300px" width="350" /><img src="OEMS_files/RightArrow.svg" width="60" /><img src="OEMS_files/WS-Activity_CIM.svg" style="min-width:300px" width="350" /></div></figure><p>It is obvious that applying this replacement
  pattern leads to a conceptual and visual simplification of the models
  concerned.</p><figure class="threecells" id="secCM__figWorkstationCPM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">8-2</span>. </span>Introducing an activity type in a conceptual
  process model of a single workstation system.</figcaption><div><img src="OEMS_files/WS_CPM_2.svg" width="450" /><img src="OEMS_files/RightArrow.svg" width="60" /><img src="OEMS_files/WS-Activity_CPM.svg" width="400" /></div></figure></section><section class="role-section1" id="secDesM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">8.2</span>. </span>Design Modeling of Simple Activities</h2><p>Like in a conceptual model, also in a design model, a pair of
  corresponding activity start event and end event circles, like
  <code>ProcessingStart</code> and <code>ProcessingEnd</code> in the source
  models shown in <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">8-3</span></span></a> and <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">8-4</span></span></a>, can be replaced with a corresponding
  activity rectangle, like <code>Processing</code>, as in the target models
  shown in these figures.</p><section><h4>Extending basic OE class design
  models by adding activity types</h4><figure id="secDesM__figWorkstationIDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">8-3</span>. </span>Going from
  basic OEM to <abbr title="Object Event">OE</abbr> class models by
  introducing activity types.</figcaption><div style="display:flex; flex-direction: column"><div><img src="OEMS_files/WS2_IDM_2.svg" width="500" /></div><div><img src="OEMS_files/DownArrow.svg" width="30" /></div><div><img src="OEMS_files/WS3_IDM.svg" width="530" /></div></div></figure><p>In the case
  of an <abbr title="Object Event">OE</abbr> class design model, this
  replacement pattern implies allocating all features (attributes,
  associations and operations) of the classes defining the start and the end
  event type in the class defining the corresponding activity type, possibly
  with renaming some of them. In the example of <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">8-3</span></span></a>, there is only one such feature: the
  class-level operation <code>ProcessingStart::processingTime</code>, which is
  allocated to <code>Processing</code> and renamed to
  <code>time</code>.</p></section><section id="secDesM__secAddingActivityRectanglesToPDMs"><h4>Extending Object Event Graphs by
  adding Activity rectangles</h4><figure id="secDesM__figWorkstationPDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">8-4</span>. </span>Going from basic DPMN to DPMN-A process models by
  introducing Activity rectangles.</figcaption><div style="display:flex; flex-direction: column"><div><img src="OEMS_files/WS2_PDM.svg" width="550" /></div><div><img src="OEMS_files/DownArrow.svg" width="30" /></div><div><img src="OEMS_files/WS3_PDM.svg" width="550" /></div></div></figure><p>In the case
  of a process design model, the rewrite pattern implies that an Event circle
  pair consisting of an Event circle intended to represent activity start
  events and an Event circle intended to represent related activity end
  events, with an event scheduling arrow from the start to the end Event
  circle annotated by a delay expression, is replaced by an Activity rectangle
  such that:</p><ol>
      <li>All Data Objects attached to the end Event circle get attached to
      the Activity rectangle (since an activity occurs when it it is
      completed).</li>

      <li>All event scheduling arrows going out from the end Event circle are
      turned into event scheduling arrows going out from the Activity
      rectangle.</li>

      <li>All start event scheduling arrows are replaced with corresponding
      activity scheduling arrows having an additional creation parameter
      assignment for the <em>duration</em> of a scheduled activity, which is
      set to the delay expression defined for the end event scheduling arrow.
      In the example above, the duration parameter in the annotation of the
      two activity scheduling arrows is set to <code>Processing::time()</code>
      in the target diagram, which is the same as the delay
      <code>ProcessingStart::processingTime</code> in the source diagram.</li>

      <li>When the start Event circle has one or more attached Data Objects or
      any outgoing event scheduling arrow that does not go to the end Event
      circle, then a start Event circle has to be included in the Activity
      rectangle for attaching the Data Object(s) and as the source of the
      outgoing event scheduling arrow(s).</li>
    </ol><p>This <em>Activity-Start-End Rewrite Pattern</em>, which can also
  be applied in the inverse direction, replacing an Activity rectangle with an
  Event circle pair, defines the meaning of an Activity rectangle in a DPMN
  diagram. It allows reducing a DPMN-A diagram with Activity rectangles to an
  Object Event Graph (a basic DPMN diagram without Activity
  rectangles).</p><p>Notice that, like the source model, also the target model
  of <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">8-4</span></span></a> specifies three event rules:</p><ol>
      <li>On each <em>PartArrival</em> event, the arrived part is added to the
      workstation's input buffer and if the workstation's status is AVAILABLE,
      then a new <i>Processing</i> activity is scheduled to start immediately
      with a duration provided by invoking the <i>time</i> function defined in
      the <i>Processing</i> activity class.</li>

      <li>When a <em><i>Processing</i></em> activity starts, the workstation's
      status is changed to BUSY.</li>

      <li>When a <em><i>Processing</i></em> activity ends, the processed part
      is removed from the input buffer and, if the input buffer is not empty,
      a new <i>Processing</i> activity is scheduled to start immediately,
      otherwise (if the input buffer is empty) the workstation's status is
      changed to AVAILABLE.</li>
    </ol></section><section><h4>An alternative process design model of the
  single workstation system</h4><p>Based on the same information design model,
  shown in the target model of <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">8-3</span></span></a>, we can make
  another process design model of the single workstation system as an
  alternative to the target model of <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">8-4</span></span></a>. This
  alternative model makes it more clear that a workstation is, in fact, an
  exclusive resource of its processing activity. The concepts of resources and
  resource-constrained activities are discussed in the following sections, and
  in <a class="role-section1-ref" href="#secDesM-2"><span class="role-label">Section <span class="role-number">9.2</span></span></a>, it is
  shown how to simplify the basic DPMN model of <a class="role-figure-ref" href="#secDesM__figWS3PDM2"><span class="role-label">Figure <span class="role-number">8-5</span></span></a> by
  using the higher-level modeling elements introduced in DPMN-A.</p><figure id="secDesM__figWS3PDM2"><figcaption><span class="role-label">Figure <span class="role-number">8-5</span>. </span>Allocating the workstation as a resource of
  Processing activities</figcaption><img src="OEMS_files/WS3_PDM2.svg" width="500" /></figure></section></section></section><section class="role-chapter" id="ResourceConstrainedActivities-Intro"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">9</span>. </span>Resource-Constrained Activities</h1><p>A <em>Resource-Constrained Activity</em> is an activity that
  requires certain resources for being executed. Such an activity can only be
  started when the required resources are available and can be allocated to
  it. </p><p>At any point in time, a resource required for performing an
  activity may be <em>available</em> or not. A resource is not available, for
  instance, when it is <em>busy</em> or when it is <em>out of
  order</em>.</p><aside class="rightbox40"><h2>Summary</h2><ol>
      <li>A Resource-Constrained Activity can only be started when the
      required resources are available.</li>

      <li>An <abbr title="Object Event">OE</abbr> Class Diagram includes
      <em>Resource Role</em> associations between Resource-Constrained
      Activity types <i>A</i> and resource object types <i>R</i>. Their
      association ends at the side of <i>R</i> correspond to special
      properties of <i>A</i> called <em>Resource Roles</em>.</li>

      <li>The resources that are available for being allocated to a planned
      activity are provided by <em>Resource Pools</em> managed by <em>Process
      Owners</em>. A Resource Pool can be explicitly modeled in an OE Class
      Diagram as a collection-valued reference property of the object type
      representing the Process Owner.</li>

      <li>A simulation model assigns a Resource Pool to each Resource Role,
      either implicitly or explicitly. An implicit assignment is provided by
      the default assumption that there is one pool for each resource object
      type.</li>

      <li>A <em>Resource Type</em> is defined in an <abbr title="Object Event">OE</abbr> Class Diagram as a special object type
      that has a resource <em>status</em> attribute and is the range of a
      Resource Role and possibly also of a Resource Pool property.</li>

      <li><em>Resource Cardinality Constraints</em> and <em>Multitasking
      Constraints</em> are defined in an <abbr title="Object Event">OE</abbr>
      Class Diagram in the form of multiplicities of the respective
      association ends of Resource Role associations.</li>

      <li>A <em>Resource-Dependent Activity Scheduling (RDAS)</em> arrow is a
      high-level modeling element of DPMN Process Diagrams, merging the
      semantics of event scheduling arrows with the Allocate-Release modeling
      pattern.</li>

      <li>OEM-A extends basic OEM by adding activities, resource roles,
      resource cardinality constraints, resource pools, resource types and
      RDAS arrows. Notice that most of these resource modeling elements are
      expressed in an <abbr title="Object Event">OE</abbr> Class Diagram, and
      only the possible event flows are expressed in a DPMN Process Diagram
      with the help of event scheduling arrows and <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr> arrows.</li>
    </ol></aside><p>Resources are objects of a certain type. The resource
  objects of an activity include its <em>performer</em>, as expressed in the
  diagram shown in <a class="role-figure-ref" href="#ResourceConstrainedActivities-Intro__figActRes"><span class="role-label">Figure <span class="role-number">9-1</span></span></a>. While in a conceptual model,
  describing a real-world system, a performer is required for any activity, a
  simulation design model may abstract away from the performer of an
  activity.</p><p>For instance, a consultation activity may require a
  consultant and a room. Such <em>resource cardinality constraints</em> are
  defined at the type level. When defining the activity type
  <code>Consultation</code>, these resource cardinality constraints are
  defined in the form of two mandatory associations with the object types
  <code>Consultant</code> and <code>Room</code> such that both associations'
  ends have the multiplicity 1 (&quot;exactly one&quot;). Then, in a simulation run, a
  new <code>Consultation</code> activity can only be started, when both a
  <code>Consultant</code> object and a <code>Room</code> object are
  available.</p><p>In an OE Class Diagram, an object type that has a resource
  <em>status</em> attribute and is the range of both a Resource Role and a
  Resource Pool property can be viewed as a <em>resource
  type</em>.</p><p><em>Activity Networks (ANs)</em> extend <abbr title="Object Event Graph">OEG</abbr>s by adding activity nodes (in the form
  of rectangles with rounded corners) and <em>Resource-Dependent Activity
  Scheduling (RDAS)</em> arrows.</p><p>For all types of resource-constrained
  activities, or, more precisely, for all activity nodes of an <abbr title="Activity Network">AN</abbr>, a simulator can automatically collect
  the following statistics:</p><ol>
      <li><i>Throughput</i> statistics: the numbers of enqueued and dequeued
      planned activities, and the numbers of started and completed
      activities.</li>

      <li><i>Queue length</i> statistics: the average and maximum length of
      its queue of planned activities.</li>

      <li><i>Cycle time</i> statistics: the minimum, average and maximum cycle
      time, which is the sum of the waiting time and the activity
      duration.</li>

      <li><i>Resource utilization</i> statistics: the percentage of time each
      resource object involved is busy with an activity of that type.</li>
    </ol><p>In addition, a simulator can automatically collect the percentage
  of time each resource object involved is idle or out-of-order.</p><figure id="ResourceConstrainedActivities-Intro__figActRes"><div><img alt="???" src="OEMS_files/ResourceConstrained-Activities.svg" width="600" /></div><figcaption><span class="role-label">Figure <span class="role-number">9-1</span>. </span>Typically, the performer of an activity is a
  resource object.</figcaption></figure><p>For modeling resource-constrained
  activities, we need to define their types. As can be seen in <a class="role-figure-ref" href="#ResourceConstrainedActivities-Intro__figIndividualsAndTypes"><span class="role-label">Figure <span class="role-number">9-2</span></span></a>, a resource-constrained activity type is
  composed of </p><ol>
      <li>a set of <em>properties</em> and a set of <em>operations</em>, as
      any entity type,</li>

      <li>a set of <strong>resource roles</strong>, each one having the form
      of a reference property with a name, an object type as range, and a
      multiplicity that may define a <strong>resource cardinality
      constraint</strong> like, e.g., &quot;exactly one resource object of this
      type is required&quot; or &quot;at least two resource objects of this type are
      required&quot;.</li>
    </ol><p>The resource roles defined for an activity type may include the
  performer role.</p><figure id="ResourceConstrainedActivities-Intro__figIndividualsAndTypes"><figcaption><span class="role-label">Figure <span class="role-number">9-2</span>. </span>Activity
  types may have special properties representing resource
  roles.</figcaption><div><img alt="???" src="OEMS_files/Types-with-ResourceRoles.svg" width="500" /></div></figure><p>These considerations show that a simulation
  language for simulating activities needs to allow defining activity types
  with two kinds of properties: ordinary properties and resource roles. At
  least for the latter ones, it must be possible to define multiplicities for
  defining resource cardinality constraints. These requirements are fulfilled
  by <abbr title="Object Event">OE</abbr> Class Diagrams where resource roles
  are defined as special properties categorized by the stereotype «resource
  role» or, in short, «rr».</p><p>The extension of basic OEM by adding the
  concepts needed for modeling resource-constrained activities (in particular,
  resource roles with constraints, resource pools, and resource-dependent
  activity scheduling arrows) is called <em>OEM-A</em>.</p><section class="role-section1" id="secCM-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">9.1</span>. </span>Conceptual Modeling of Resource-Constrained Activities</h2>Modeling resource-constrained activities has been a major issue in the
  field of <em>Discrete Event Simulation (DES)</em> since its inception in the
  nineteen-sixties, while it has been neglected and is still considered an
  advanced topic in the field of <em>Business Process Modeling (BPM)</em>. The
  concept of resource-constrained activities is at the center of both DES and
  BPM. But both fields have developed different, and even incompatible,
  concepts of business process simulation.<p>In the <abbr title="Discrete Event Simulation">DES</abbr> paradigm of <em>Processing
  Networks</em>, Gordon (1961) has introduced the resource management
  operations <em>Seize</em> and <em>Release</em> in the simulation language
  GPSS for allocating and de-allocating (releasing) resources. Thus, GPSS has
  established a standard modeling pattern for resource-constrained activities,
  which has become popular under the name of
  <em>Seize</em>-<em>Delay</em>-<em>Release</em> indicating that for
  simulating a resource-constrained activity, its resources are first
  allocated (&quot;seized&quot;), and then, after some delay representing the duration
  of the simulated activity, they are de-allocated (&quot;released&quot;).</p><section id="secCM-2__secResPools"><h4>Resource roles, process owners and resource
  pools</h4><p>As an illustrative example, we consider a hospital consisting
  of medical departments where patients arrive for getting a medical
  examination performed by a doctor. A medical examination, as an activity,
  has three participants: a patient, a medical department, and a doctor, but
  only one of them plays a resource role: doctors. This can be indicated in an
  <abbr title="Object Event">OE</abbr> Class Diagram by using the stereotype
  «resource role» for categorizing the association ends that represent
  resource roles, as shown in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>.</p><figure id="secCM-2__figResRoles"><figcaption><span class="role-label">Figure <span class="role-number">9-3</span>. </span>A conceptual information model of the activity
  type &quot;examinations&quot; with resource roles.</figcaption><div><img alt="???" src="OEMS_files/MedDep_CIM1.svg" width="500" /></div></figure><p>Notice that
  both the event type <em>patient arrivals</em> and the activity type
  <em>examinations</em> have a (mandatory functional) reference property
  <em>process owner</em>. This implies that both patient arrival events and
  examination activities happen at a specific medical department, which is
  their process owner in the sense that it owns the process types composed of
  them. A process owner is called &quot;Participant&quot; in BPMN (in the sense of a
  collaboration participant) and visually rendered in the form of a container
  rectangle called &quot;Pool&quot;.</p><p>In <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>, the resource
  role of doctors corresponds to the <em>performer</em> role. In BPMN,
  <em>Performer</em> is considered to be a special type of resource role.
  According to (BPMN 2011), a performer can be &quot;a specific individual, a
  group, an organization role or position, or an organization&quot;.<a class="role-footnote-ref" href="#__FN1" id="__FNR1">[1]</a>In BPMN, <em>Performer</em> is
  specialized into the <em>HumanPerformer</em> of an activity, which is, in
  turn, specialized into <em>PotentialOwner</em> denoting the &quot;persons who can
  claim and work&quot; on an activity of a given type. &quot;A potential owner becomes
  the actual owner [...] by explicitly claiming&quot; an activity. Allocating a
  human resource to an activity by leaving the choice to those humans that
  play a suitable resource role is characteristic for workflow management
  systems, while in traditional DES approaches to resource handling, as in
  Arena, Simio and AnyLogic, (human) resources are assigned to a task (as its
  performer) based on certain policies.</p><p>Thus, the term &quot;performer&quot;
  subsumes several types of performers. We will, by default, use it in the
  sense of a human performer.</p><p>One of the main reasons for considering
  certain objects as resources is the need to collect <em>utilization
  statistics</em> (either in an operational information system, like a
  workflow management system, or in a simulation model) by recording the use
  of resources over time (their <em>utilization</em>) per activity type. By
  designating resource roles in information models, these models provide the
  information needed in simulations and information systems for automatically
  collecting utilization statistics.</p><p>In the hospital example, a medical
  department, as the process owner, is the organizational unit that is
  responsible for reacting to certain events (here: patient arrivals) and
  managing the performance of certain processes and activities (here: medical
  examinations), including the allocation of resources to these processes and
  activities. For being able to allocate resources to activities, a process
  owner needs to manage <em>resource pools</em>, normally one for each
  resource role of each type of activity (if pools are not shared among
  resource roles). A resource pool is a collection of resource objects of a
  certain type. For instance, the three X-ray rooms of a diagnostic imaging
  department form a resource pool of that department.</p><p>Resource pools can
  be modeled in an OE Class Diagram by means of special associations between
  object classes representing process owners (like <em>medical
  departments</em>) and resource classes (like <em>doctors</em>), where the
  association ends, corresponding to collection-valued properties representing
  resource pools, are stereotyped with «resource pool», as shown in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>. At any point in time, the resource objects of a
  resource pool may be <em>out of order</em> (like a defective machine or a
  doctor who is not on schedule), <em>busy</em> or <em>available</em>.</p><p>A
  process owner has special procedures for allocating available resources from
  resource pools to activities. For instance, in the model of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>, a medical department has the procedure &quot;allocate a
  doctor&quot; for allocating a doctor to a medical examination. These resource
  allocation procedures may use various policies, especially for allocating
  human resources, such as first determining the suitability of potential
  resources (e.g., based on expertise, experience and previous performance),
  then ranking them and finally selecting from the most suitable ones (at
  random or based on their turn). See also (Arias et al 2018).</p><p>The
  conceptual process model shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label">Figure <span class="role-number">9-4</span></span></a> is based on
  the information model above. It refers to a medical department as the
  <em>process owner</em>, visualized in the form of a <em>Pool</em> container
  rectangle, and to <i>doctor objects</i>, as well as to the event type
  <i>patient arrivals</i> and to the activity type
  <i>examinations</i>.</p><figure id="secCM-2__figMedDepCPM1"><figcaption><span class="role-label">Figure <span class="role-number">9-4</span>. </span>A conceptual
  process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>.</figcaption><div><img alt="???" src="OEMS_files/MedDep_CPM1.svg" /></div></figure><p>This process model
  describes two causal regularities in the form of the following two event
  rules, each stated with two bullet points: one for describing all the state
  changes and one for describing all the follow-up events brought about by
  applying the rule.</p><ol>
      <li><p>When a new patient arrives:</p><ul>
          <li>if a doctor is available, then she is allocated to the
          examination of that patient; otherwise, a new planned examination is
          queued up;</li>

          <li>if a doctor has been allocated, then start an examination of the
          patient.</li>
        </ul></li>

      <li><p>When an examination is completed by a doctor:</p><ul>
          <li>if the queue of planned examinations is empty, then the doctor
          is released;</li>

          <li>otherwise, the next planned examination by that doctor is
          scheduled to start immediately.</li>
        </ul></li>
    </ol><p>These conceptual event rules describe the real-world dynamics of a
  medical department according to business process management decisions.
  Changes of the waiting line and (de-)allocations of doctors are considered
  to be state changes (in the, not necessarily computerized, information
  system) of the department, as they are expressed in Data Object rectangles,
  which represent state changes of affected objects caused by an event in
  DPMN.</p><p>Notice that the model of <a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label">Figure <span class="role-number">9-4</span></span></a> abstracts
  away from the fact that after allocating a doctor, patients first need to
  walk to the room before their examination can start. Such a simplification
  may be justified if the walking time can be neglected or if there is no need
  to maximize the productive utilization of doctors who, according to this
  process model, have to wait until the patient arrives at the room. Below,
  this model is extended for allowing to allocate rooms and doctors such that
  patients have to wait for doctors, and not the other way
  around.</p></section><section><h4>Switching roles: doctors as
  patients</h4><p>The same person who is a doctor at a diagnostic imaging
  department may be treated as a patient of that department. It's a well-known
  fact that in the real world people may switch roles and may play several
  roles at the same time, but many modeling approaches/platforms fail to admit
  this. For instance, the simulation language (SIMAN) of the well-known DES
  modeling tool Arena does not treat resources and processing objects
  (&quot;entities&quot;) as roles, but as strictly separate categories. This language
  design decision was a meta-modeling mistake, as admitted by Denis Pegden,
  the main creator of SIMAN/Arena, in (Drogoul et al 2018) where he says &quot;it
  was a conceptualization mistake to view Entities and Resources as different
  constructs&quot;. </p><p>In <a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label">Figure <span class="role-number">9-5</span></span></a>, the above model is
  extended by categorizing the classes <i>doctors</i> and <i>patients</i> as
  «role type» classes and adding the «kind» class <i>people</i> as a supertype
  of <i>doctors</i> and <i>patients</i>, we create the possibility that a
  person may play both roles: the role of a doctor and the role of a patient,
  albeit not at the same time. The object type categories «kind» and «role
  type» have been introduced to conceptual modeling by Guizzardi
  (2005).</p><figure id="secCM-2__figKindsRoles"><figcaption><span class="role-label">Figure <span class="role-number">9-5</span>. </span>A conceptual information
  model with doctors and patients as people.</figcaption><div><img alt="???" src="OEMS_files/MedExam_CM3.svg" width="600" /></div></figure></section><section><h4>Queueing planned
  activities</h4><p>Whenever an activity is to be performed but cannot start
  due to a required resource not being available, the <em>planned
  activity</em> is placed in a queue as a waiting job. Thus, in the case of a
  medical examination of a patient, as described in the model of <a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label">Figure <span class="role-number">9-5</span></span></a>, the <em>waiting line</em> represents, in fact, a
  queue of planned examinations (involving patients), and not a queue of
  waiting patients. </p><p>This consideration points to a general issue:
  modeling resource-constrained activities implies modeling queues of planned
  activities, while there is no need to consider (physical) queues of
  (physical) objects. Consequently, even if a real-world system includes a
  physical queue (of physical objects), an OEM-A model may abstract away from
  its physical character and consider it as a queue of planned activities
  (possibly including pre-allocated resources). While a physical queue implies
  that there is a maximum capacity, a queue of planned activities does not
  imply this. For instance, when a medical department does not require
  patients to queue up in a waiting area for obtaining an examination, but
  accepts their registration for an examination by phone, the resulting queue
  of waiting patients is not a physical queue (but rather a queue of planned
  examinations) and there is no need to limit the number of waiting patients
  in the same way as in the case of queuing up in a waiting area with limited
  space.</p><p>A planned activity can only start, when all required resources
  have been allocated to it. Thus, a planned examination of a patient can only
  start, when both a room and a doctor have been allocated to it. Let's assume
  that when a patient <i>p</i> arrives, only a room is available, but not a
  doctor. In that case, the available room is allocated to the planned
  examination, which is then placed in a queue since it still has to wait for
  the availability of a doctor. Only when a doctor becomes available, e.g.,
  via the completion of an examination of another patient or via an arrival of
  a doctor, the doctor can be allocated as the last resource needed to start
  the planned examination of patient <i>p</i>. </p><p>As a consequence of
  these considerations, the <em>waiting line</em> of a medical department
  modeled in <a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label">Figure <span class="role-number">9-5</span></span></a> as an ordered collection of
  patients is renamed to <em>planned walks</em> in <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">9-6</span></span></a>. In addition, a property <em>planned
  examinations</em>, which holds an ordered collection of patient-room pairs,
  is added to the class <em>medical departments</em>. These model elements
  reflect the hospital's business process practice to maintain a list of
  patients waiting for the allocation of a room to walk to and a list of
  planned examinations, each with a patient waiting for a doctor in an
  examination room.</p></section><section><h4>Decoupling the allocation of
  multiple resources</h4><p>For being more realistic, we consider the fact
  that patients first need to be walked by nurses to the room allocated to
  their examination before the examination can start. Thus, in the model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">9-6</span></span></a>, we add a second activity type, <em>walks to
  room</em>, involving people (typically, nurses and patients) walking to an
  examination room. </p><figure id="secCM-2__figMedDepCIM4"><figcaption><span class="role-label">Figure <span class="role-number">9-6</span>. </span>Adding the
  activity type &quot;walks to room&quot; to the conceptual information
  model.</figcaption><div><img alt="???" src="OEMS_files/MedExam_CIM4.svg" width="600" /></div></figure> <figure id="secCM-2__figMedDepCPM2"><figcaption><span class="role-label">Figure <span class="role-number">9-7</span>. </span>A
  conceptual process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">9-6</span></span></a>.</figcaption><div><img alt="???" src="OEMS_files/MedDep_CPM2.svg" /></div></figure><p>This process model
  describes three causal regularities in the form of the following three event
  rules:</p><ol>
      <li><p>When a new patient arrives:</p><ul>
          <li>if a room and a nurse are available, they are allocated to the
          walk of that patient to that room, otherwise a new planned walk is
          placed in the corresponding queue;</li>

          <li>if a room has been allocated, then the nurse starts walking the
          patient to the room.</li>
        </ul></li>

      <li><p>When a walk of a patient and nurse to a room is completed:</p><ul>
          <li>if there is still a planned walk in the queue and a room is
          available, then the room is allocated and the nurse is re-allocated
          to the walk of the next patient to that room.<br />if a doctor is
          available, she is allocated to the examination of that patient, else
          a new planned examination of that patient is queued up;</li>

          <li>if a doctor has been allocated, then the examination of that
          patient starts<br />if the nurse has been re-allocated, she starts
          walking the next patient to the allocated room.</li>
        </ul></li>

      <li><p>When an examination of a patient is completed by a doctor in a
      particular room:</p><ul>
          <li>if there is still a planned examination (of another patient in
          another room), then re-allocate the doctor to that planned
          examination, else release the doctor;<br />if the waiting line is
          not empty, re-allocate the room to the next patient, else release
          the room;</li>

          <li>if the doctor has been re-allocated to a planned examination,
          that examination starts;<br />if the room has been re-allocated to
          another patient, that patient starts walking to the room.</li>
        </ul></li>
    </ol><p>Notice that the process type described in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM2"><span class="role-label">Figure <span class="role-number">9-7</span></span></a> does not consider the fact that doctors have to
  walk to the examination room too, which could be modeled by adding a
  <em>doctors' walks to room</em> Activity rectangle after the patients'
  <em>walks to room</em> Activity rectangle.</p><p>For being able to collect
  informative utilization statistics, it is required to distinguish the total
  time a resource is allocated (its 'gross utilization') from the time it is
  allocated for productive activities (its 'net utilization'). Thus, only
  <em>examinations</em> would be classified as productive activities, while
  <em>walks to room</em> would rather be considered a kind of set-up
  activities.</p><section><h4>Re-engineering the process type by centralizing
  the re-allocation of resources</h4><p>In the process type described in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM2"><span class="role-label">Figure <span class="role-number">9-7</span></span></a>, the re-allocation of released resources is
  handled in the event rules of activity end events:</p><ul>
      <li>when a nurse's and patient's walk to a room ends, the nurse is free
      to be re-allocated; so if there is another planned walk and a room is
      available, the nurse is re-allocated to a walk of the next patient to
      that room;</li>

      <li>when an examination ends, its resources (a doctor and a room) are
      re-allocated, if planned activities are waiting for them.</li>
    </ul><p>This approach requires that the same re-allocation logic is
  repeated in the event rules of all activity types associated with that type
  of resource, implying that all performers involved would have to know and
  execute the same re-allocation logic. It is clearly preferable to centralize
  this logic in a single event rule, which can be achieved by introducing
  <em>release resource request</em> events following activities that do not
  need to keep resources allocated, as shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM3"><span class="role-label">Figure <span class="role-number">9-8</span></span></a>
  where the re-allocation of doctors and rooms is decoupled from the
  examination activities and centralized (e.g., in a special resource
  management unit) by adding the two event types <em>room release
  requests</em> and <em>doctor release requests</em> modeling simultaneous
  events that follow examinations.</p><figure id="secCM-2__figMedDepCPM3"><figcaption><span class="role-label">Figure <span class="role-number">9-8</span>. </span>An improved process model based on the
  information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">9-6</span></span></a>.</figcaption><div><img alt="???" src="OEMS_files/MedDep_CPM3.svg" width="700" /></div></figure><p>This
  process model describes an improved business process with six event
  rules:</p><ol>
      <li><p>When a new patient arrives:</p><ul>
          <li>if a room and a nurse are available, they are allocated to the
          walk of that patient to that room, otherwise a new planned walk is
          placed in the corresponding queue;</li>

          <li>if a room has been allocated, then the nurse starts walking the
          patient to the room.</li>
        </ul></li>

      <li><p>When a walk of a patient and nurse to a room is completed:</p><ul>
          <li>if a doctor is available, she is allocated to the examination of
          that patient, else a new planned examination of that patient is
          queued up;</li>

          <li>if a doctor has been allocated, then the examination of that
          patient starts; in addition, a nurse release request is issued.</li>
        </ul></li>

      <li><p>When a nurse release request has been issued:</p><ul>
          <li>if the waiting line is not empty and a room is available,
          allocate the room and re-allocate the nurse to the next patient,
          else release the nurse;</li>

          <li>if the nurse has been re-allocated to another patient, she
          starts walking that patient to the room.</li>
        </ul></li>

      <li><p>When an examination is completed:</p><ul>
          <li>[no state change]</li>

          <li>a room release request is issued (e.g., by notifying a resource
          management clerk or the department's information system), and, in
          parallel, a doctor release request is issued.</li>
        </ul></li>

      <li><p>When a room release request is received by a resource
      manager:</p><ul>
          <li>if the waiting line is not empty and a nurse is available,
          allocate the nurse and re-allocate the room to the next patient,
          else release the room;</li>

          <li>if the room has been re-allocated to another patient, the nurse
          starts walking that patient to the room.</li>
        </ul></li>

      <li><p>When a doctor release request is received by a resource
      manager:</p><ul>
          <li>if there is still a planned examination (of another patient in
          another room), then re-allocate the doctor to that planned
          examination, else release the doctor;</li>

          <li>if the doctor has been re-allocated to a planned examination,
          that examination starts.</li>
        </ul></li>
    </ol><p>Notice that, in the general case, instead of scheduling several
  simultaneous release requests, each for a single resource, when an activity
  completes, a single joint release request for all used resources should be
  scheduled, allowing to re-allocate several of the released resources
  jointly.</p></section><section><h4>Displaying the process owner and activity
  performers</h4><p>The process owner and the involved performers can be
  displayed in an OEM process model by using a rectangular <em>Pool</em>
  container for the process owner and Pool partitions called <em>Lanes</em>
  for the involved activity performers, as shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">9-9</span></span></a>. Notice that, as opposed to BPMN, where lanes do
  not have a well-defined meaning, but can be used for any sort of arranging
  model elements, DPMN Lanes represent organizational actors playing the
  resource role of <em>performer</em>.</p><figure id="secCM-2__figMedDepCPM4"><figcaption><span class="role-label">Figure <span class="role-number">9-9</span>. </span>Displaying the process owner and activity
  performers in a conceptual process model.</figcaption><div><img alt="???" src="OEMS_files/MedDep_CPM4.svg" width="650" /></div></figure></section><section id="secCM-2__secNonExclusiveRes"><h4>Non-exclusive resources</h4><p>In OEM, a
  resource is exclusive by default, that is, it can be used in at most one
  activity at the same time, if no <em>parallel participation</em>
  multiplicity is specified. For instance, in all information models above
  (e.g., in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>), the participation associations
  between the resource classes <i>rooms</i> and <i>doctors</i> and the
  activity classes <i>walks to room</i> and <i>examinations</i> do not specify
  any <em>parallel participation</em> multiplicity (for the association end at
  the side of the activity class), but just the common (historical
  participation) multiplicity of &quot;*&quot; expressing that resources participate in
  zero or more activities over time (without an upper bound).</p><p>OEM
  extends UML Class Diagrams by adding the association end stereotype
  «parallel» for expressing <em>parallel participation</em>
  multiplicities.</p><p>A non-exclusive resource can be simultaneously used in
  more than one activity. The maximum number of activities, in which a
  non-exclusive resource can participate at the same time, is normally
  specified at the type level for all resource objects of that type using the
  upper bound of a parallel participation multiplicity. In general, there may
  be cases where it should be possible to specify this at the level of
  individual resource objects. For instance, larger examination rooms may
  accommodate more examinations than smaller ones.</p><p>A resource can be
  exclusive with respect to all types of activities (which is the default
  case) or it can be exclusive with respect to specific types of activities.
  For instance, in the model of <a class="role-figure-ref" href="#secCM-2__figExclusiveResByType"><span class="role-label">Figure <span class="role-number">9-10</span></span></a>, a
  parallel participation multiplicity of 0..1 is defined both for the
  participation of rooms in walks and in examinations. This means a room can
  participate in at most one walk and in at most one examination at the same
  time, which is a different business rule, allowing to walk patients to a
  room even if it is currently used for an examination, compared to the model
  of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a>, allowing to walk patients to a room only if
  it is currently not being used for an examination.</p><figure id="secCM-2__figExclusiveResByType"><figcaption><span class="role-label">Figure <span class="role-number">9-10</span>. </span>Adding parallel participation
  multiplicities for rooms participating both in walks and examinations at the
  same time.</figcaption><div><img alt="???" src="OEMS_files/MedExam_CIM5.svg" width="500" /></div></figure></section></section></section><section class="role-section1" id="secDesM-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">9.2</span>. </span>Resource-Constrained Activities in Simulation Design Models</h2><p>In simulation design models, resource-constrained activities can be
  modeled in two ways: </p><ol>
      <li>either abstracting away from the structure of resource object types
      and individual resource objects, and only representing a resource object
      type in the form of a named resource pool with a quantity (or
      <em>counter</em>) attribute holding the number of available resources,
      or</li>

      <li>explicitly representing resource object types and individual
      resource objects of that type as members of a collection representing a
      resource pool.</li>
    </ol><p>While the first approach is simpler, the second approach allows
  modeling various kinds of non-availability of specific resources (e.g., due
  to failures or due to not being in the shift plan).</p><p>For any resource
  object type <i>Res</i>, the three operations described in the following
  table <a href="#secDesM-2__tblResManOps"></a> are needed.</p><table border="1" id="secDesM-2__tblResManOps">
      <thead>
        <tr>
          <th>Resource management operation</th>

          <th>General meaning</th>

          <th>Resource counter approach</th>

          <th>Resource pool approach</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <th><i>isResAvailable</i></th>

          <td>test if a resource of type <i>Res</i> is available and return
          <i>true</i> or <i>false</i></td>

          <td>test if the corresponding resource counter attribute has a value
          that is greater than 0</td>

          <td>test if the number of available resource objects in the resource
          pool is greater than 0</td>
        </tr>

        <tr>
          <th><i>allocateRes</i></th>

          <td>allocate a resource object of type <i>Res</i></td>

          <td>decrement resource counter attribute</td>

          <td>select (and return) a resource object from the set of available
          resource objects in the resource pool (using an allocation policy)
          and designate it as BUSY</td>
        </tr>

        <tr>
          <th><i>releaseRes</i></th>

          <td>de-allocate a resource object of type <i>Res</i></td>

          <td>increment resource counter attribute</td>

          <td>take a resource object of type <i>Res</i> as argument and
          designate it as AVAILABLE</td>
        </tr>
      </tbody>
    </table><p>In both approaches, it is natural to add these operations to
  the object type representing the process owner of the activities concerned,
  as in the models shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">9-11</span></span></a> and <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a>.</p><p>In the first approach, for each resource
  object type in the conceptual model, a resource counter attribute is added
  to the object type representing the process owner and the conceptual model's
  resource object types are dropped.</p><p>In the second approach, the
  conceptual model's resource object types are elaborated by adding an
  enumeration attribute <em>status</em> holding a resource status value such
  as AVAILABLE or BUSY. For each resource object type, a collection-valued
  property (such as <em>rooms</em> or <em>doctors</em>) representing a
  resource pool is added to the object type representing the process
  owner.</p><section><h4>A simple model with resource counters</h4><p>Using
  the conceptual information model shown in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">9-3</span></span></a> as a starting point, we first rename all
  classes and properties according to OO naming conventions and replace each
  of the two (conceptual) operations <em>allocate a room</em> and <em>allocate
  a doctor</em> with a triple of
  <i>isAvailable</i>/<i>allocate</i>/<i>release</i> operations for the two
  resource object classes <em>Room</em> and <em>Doctor</em> in the
  <em>MedicalDepartment</em> class, where we also add the counter attributes
  <em>nmrOfRooms</em> and <em>nmrOfDoctors</em>. Then, the two resource object
  classes <em>Room</em> and <em>Doctor</em> are dropped. The result of this
  elaboration is the information design model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">9-11</span></span></a>.</p><figure id="secDesM-2__figMedDep1IDM1"><figcaption><span class="role-label">Figure <span class="role-number">9-11</span>. </span>An
  information model for the simplified design with the resource counters
  nmrOfRooms and nmrOfDoctors.</figcaption><div><img src="OEMS_files/MedExam1_IDM1.svg" width="500" /></div></figure><p>Using the
  conceptual process model shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label">Figure <span class="role-number">9-4</span></span></a> as
  a starting point and based on the type definitions of the information design
  model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">9-11</span></span></a>, we get the following process
  design.</p><figure id="secDesM-2__figMedDep1PDM1"><figcaption><span class="role-label">Figure <span class="role-number">9-12</span>. </span>A process design model
  based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">9-11</span></span></a>.</figcaption><div><img src="OEMS_files/MedDep1_PDM1.png" width="500" /></div></figure><p>This process
  model defines the following two event rules. </p><table border="1">
      <thead>
        <tr>
          <th>ON pa: PatientArrival</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>md : MedicalDepartment <br />resAllocated : Boolean<br />md :=
          pa.medicalDepartment</td>
        </tr>

        <tr>
          <td>IF md.isRoomAvailable() AND md.isDoctorAvailable()<br />THEN
          md.allocateRoom(); md.allocateDoctor(); resAllocated :=
          true<br />ELSE md.waitingPatients.push( pa.patient); resAllocated :=
          false</td>
        </tr>

        <tr>
          <td>IF resAllocated SCHEDULE Examination( patient:=pa.patient,
          medicalDepartment:=md)</td>
        </tr>
      </tbody>
    </table><table border="1">
      <thead>
        <tr>
          <th>ON ex: Examination</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>md : MedicalDepartment <br />anotherPatientFetched :
          Boolean<br />p: Patient<br />md := ex.medicalDepartment</td>
        </tr>

        <tr>
          <td>IF md.waitingPatients.length = 0<br />THEN md.releaseRoom();
          md.releaseDoctor(); anotherPatientFetched := false<br />ELSE p :=
          md.waitingPatients.pop(); anotherPatientFetched := true</td>
        </tr>

        <tr>
          <td>IF anotherPatientFetched SCHEDULE Examination( patient:=p,
          medicalDepartment:=md)</td>
        </tr>
      </tbody>
    </table><p>Notice that the event scheduling arrows of <a class="role-figure-ref" href="#secDesM-2__figMedDep1PDM1"><span class="role-label">Figure <span class="role-number">9-12</span></span></a>, and also the SCHEDULE statements of the
  corresponding event rule tables, do not contain assignments of the duration
  of activities, since it is assumed that, by default, whenever an activity
  type has an operation <em>duration()</em>, the duration of activities of
  this type are assigned by invoking this
  operation.</p></section><section><h4>A general model with resource objects
  as members of resource pools</h4><p>In a more general approach, instead of
  using resource counter attributes, explicitly modeling resource object
  classes (like <em>Room</em> and <em>Doctor</em>) allows representing
  resource roles (stereotyped with «res») and resource pools (stereotyped with
  «pool») in the form of collections (like <em>md.rooms</em> and
  <em>md.doctors</em>) and modeling various forms of non-availability of
  resources (such as machines being defective or humans not being in the shift
  plan) with the help of corresponding resource status values (such as
  OUT_OF_ORDER). The result of this elaboration is the information design
  model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a>.</p><figure id="secDesM-2__figMedDep1IDM2"><figcaption><span class="role-label">Figure <span class="role-number">9-13</span>. </span>An <abbr title="Object Event">OE</abbr> class model with resource object
  types for modeling resource roles and pools.</figcaption><div><img src="OEMS_files/MedExam1_IDM2.svg" /></div></figure><p>For an <abbr title="Object Event">OE</abbr> class model,
  like the one shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a>, the following
  completeness constraint must hold: when an object type <i>O</i> (like
  <i>Doctor</i>) participates in a «res» association (a resource role
  association) with an activity type <i>A</i> (like <i>Examination</i>), the
  process owner object type of <i>A</i> (<i>MedicalDepartment</i>) must have a
  «pool» association with <i>O</i>.</p><figure id="secDesM-2__figMedDep1PDM2"><figcaption><span class="role-label">Figure <span class="role-number">9-14</span>. </span>A process design model based on the
  information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a>.</figcaption><div><img src="OEMS_files/MedDep1_PDM2.png" /></div></figure></section><section><h4>Extending
  OE Class Diagrams by adding a «resource type» category</h4><p>The
  information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a> contains two
  object types, <i>Room</i> and <i>Doctor</i>, which are the range of resource
  role and resource pool properties (association ends stereotyped «res» and
  «pool»). Such object types can be categorized as «resource type» with the
  implied meaning that they inherit a resource status attribute from a
  pre-defined class <code>Resource</code>, as shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM3"><span class="role-label">Figure <span class="role-number">9-16</span></span></a>.</p><figure id="secDesM-2__lof__26"><figcaption><span class="role-label">Figure <span class="role-number">9-15</span>. </span>Any resource type
  <i>R</i> extends the pre-defined object type
  <code>Resource</code></figcaption><div><img src="OEMS_files/Resource-Object.svg" /></div></figure><p>The introduction of
  resource types to OEM class models allows simplifying models by dropping the
  following modeling items from <abbr title="Object Event">OE</abbr> class models, making them part of the
  implicit semantics:</p><ol>
      <li>the <i>status</i> attributes of object types representing resource
      types, which are implicitly inherited;</li>

      <li>the pre-defined enumeration <i>ResourceStatusEL</i>;</li>

      <li>the resource management operations <i>isAvailable</i>,
      <i>allocate</i> and <i>release</i>, which are implicitly inherited by
      any resource type; and</li>

      <li>the planned activity queues may possibly be implicitly represented
      for any resource-constrained activity type in the form of ordered
      multi-valued reference properties of its process owner object type.</li>
    </ol> This is shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM3"><span class="role-label">Figure <span class="role-number">9-16</span></span></a>.<figure id="secDesM-2__figMedDep1IDM3"><figcaption><span class="role-label">Figure <span class="role-number">9-16</span>. </span>A simplified version of the model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">9-13</span></span></a> </figcaption><div><img src="OEMS_files/MedExam1-DM3.svg" /></div></figure></section><section id="secDesM-2__RevisitingManufacturingWS"><h4>Revisiting the manufacturing workstation
  example</h4><p>A manufacturing workstation, or a &quot;server&quot; in the terminology
  of Operation Research, represents a resource for the processing activities
  performed at/by it. This was left implicit in the <abbr title="Object Event">OE</abbr> class model shown on
  the right-hand side of <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">8-3</span></span></a>. Using the
  new modeling elements (resource types, resource roles and resource pools),
  the processing activities of a workstation can be explicitly modeled as
  resource-constrained activities, leading to the <abbr title="Object Event">OE</abbr> class model shown in
  <a class="role-figure-ref" href="#secDesM-2__figWS3IDM3"><span class="role-label">Figure <span class="role-number">9-17</span></span></a> and to a more high-level and more readable
  process model compared to the process model of <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">8-4</span></span></a>.
  </p><figure id="secDesM-2__figWS3IDM3"><figcaption><span class="role-label">Figure <span class="role-number">9-17</span>. </span>An OE Class Diagram modeling a
  single workstation system with resource-constrained processing activities
  </figcaption><div><img src="OEMS_files/WS3_IDM3.svg" /></div></figure></section><section><h4>Decoupling
  the allocation of multiple resources</h4><p>In a simplified simulation
  design for the extended scenario (with patients and nurses first walking to
  examination rooms before doctors are allocated for starting the
  examinations) described by the conceptual models of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">9-6</span></span></a> and <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">9-9</span></span></a>, we do not consider the walks of
  doctors, but only the walks of nurses and patients. For simplicity, we drop
  the superclass <i>people</i> and associate the activity type
  <i>WalkToRoom</i> with the <i>Patient</i> and Nurse classes. The result of
  this elaboration is the information design model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label">Figure <span class="role-number">9-18</span></span></a>.</p><figure id="secDesM-2__figMedDep2IDM2"><figcaption><span class="role-label">Figure <span class="role-number">9-18</span>. </span>An
  information design model for decoupling the allocation of rooms and
  doctors.</figcaption><div><img src="OEMS_files/MedExam2_IDM2.svg" /></div></figure><figure id="secDesM-2__figMedDep2PDM1"><figcaption><span class="role-label">Figure <span class="role-number">9-19</span>. </span>A process design model based on the
  information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label">Figure <span class="role-number">9-18</span></span></a>.</figcaption><div><img src="OEMS_files/MedDep2_PDM1.png" /></div></figure><p>This process design model
  defines three event rules. Notice that the <i>Examination</i> event rule
  either re-allocates the doctor to the next planned examination and schedules
  it, if there is one, or it releases the doctor and re-allocates the room to
  the next planned walk-to-room and schedules it, if there is
  one.</p></section><section><h4>Centralizing the re-allocation of
  resources</h4><p>As shown before, in the conceptual process models of <a class="role-figure-ref" href="#secCM-2__figMedDepCPM3"><span class="role-label">Figure <span class="role-number">9-8</span></span></a> and <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">9-9</span></span></a>, the re-allocation of resources can be
  centralized with the help of resource release request events and the process
  owner and the involved performers can be displayed by using a Pool that is
  partitioned into Lanes for the involved activity performers, resulting in
  the model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label">Figure <span class="role-number">9-20</span></span></a>.</p><figure id="secDesM-2__figMedDep4PDM1"><figcaption><span class="role-label">Figure <span class="role-number">9-20</span>. </span>Representing the process owner as a Pool and
  activity performers as Lanes in a process design
  model.</figcaption><div><img src="OEMS_files/MedDep4_PDM1.png" /></div></figure></section></section><section class="role-section1" id="secAllocateReleasePattern"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">9.3</span>. </span>Introducing Resource-Dependent Activity Scheduling Arrows</h2><p>The conceptual process model shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">9-9</span></span></a> and the process design model shown in
  <a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label">Figure <span class="role-number">9-20</span></span></a> exhibit a general pattern for
  modeling a sequence of two resource-constrained activities of types
  <i>A</i><sub>1</sub> and <i>A</i><sub>2</sub> shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">9-21</span></span></a>. For describing this
  <strong>Allocate-Release Modeling Pattern</strong>, we assume that </p><ol>
      <li>the process owner maintains queues for planned activities:
      <i>q</i><sub>1</sub> for for planned activities of type
      <i>A</i><sub>1</sub>, and <i>q</i><sub>2</sub> for planned activities of
      type <i>A</i><sub>2</sub>, both defined as queue-valued (i.e., ordered
      multi-valued) reference properties of the process owner in the
      underlying information model;</li>

      <li>the underlying information model specifies the sets of resources
      <i>R</i><sub>1</sub> and <i>R</i><sub>2</sub> required by
      <i>A</i><sub>1</sub> and <i>A</i><sub>2</sub>;</li>

      <li>the set of resources required by <i>A</i><sub>2</sub> but not by
      <i>A</i><sub>1</sub> is denoted by
      <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub>;</li>

      <li>the set of resources required by <i>A</i><sub>1</sub> and by
      <i>A</i><sub>2</sub> is denoted by
      <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub>.</li>
    </ol><figure id="secAllocateReleasePattern__figAllocRelPatternCPM"><figcaption><span class="role-label">Figure <span class="role-number">9-21</span>. </span>A conceptual modeling
  pattern for a sequence of resource-constrained
  activities</figcaption><div><img alt="???" src="OEMS_files/AllocRelPattern_CPM.svg" /></div></figure><p>We can describe the
  execution semantics of the <em>Allocate-Release Modeling Pattern</em> for
  the case of a succession of an activity of type <i>A</i><sub>1</sub> by
  another activity of type <i>A</i><sub>2</sub> in the following way:</p><ol>
      <li>ON <i>start event</i>:<ol type="a">
          <li>If the resources <i>R</i><sub>1</sub> required by
          <i>A</i><sub>1</sub> are available, they are allocated; otherwise, a
          planned <i>A</i><sub>1</sub> activity is added to the task queue
          <i>q</i><sub>1</sub>.</li>

          <li>If the resources <i>R</i><sub>1</sub> have been allocated, a new
          activity of type <i>A</i><sub>1</sub> is started.</li>
        </ol></li>

      <li>WHEN <i>an activity of type <i>A</i><sub>1</sub></i> is
      completed:<ol type="a">
          <li>If available, the resources
          <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> are allocated; otherwise,
          a planned <i>A</i><sub>2</sub> activity with reserved resources
          <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> is added to the task queue
          <i>q</i><sub>2</sub>.</li>

          <li>If <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> have been
          allocated, a new activity of type <i>A</i><sub>2</sub> (with
          resources <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> and
          <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub>) is started. In addition,
          the release of <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> is
          requested.</li>
        </ol></li>

      <li>ON <i>release request</i> for
      <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub>:<ol type="a">
          <li>If <i>q</i><sub>1</sub> is not empty and the resources
          <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> required by both
          <i>A</i><sub>1</sub> and <i>A</i><sub>2</sub> are available, they
          are allocated and <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> are
          re-allocated to head( <i>q</i><sub>1</sub>); otherwise,
          <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> are released.</li>

          <li>If the resources <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> have
          been re-allocated, a new activity of type <i>A</i><sub>1</sub> is
          started.</li>
        </ol></li>

      <li>WHEN <i>an activity of type <i>A</i><sub>2</sub></i> completes:<ol type="a">
          <li>There is no state change.</li>

          <li>An immediate release request for <i>R</i><sub>2</sub> is
          caused/scheduled.</li>
        </ol></li>

      <li>ON <i>release request</i> for <i>R</i><sub>2</sub>:<ol type="a">
          <li>If <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> is nonempty: if
          <i>q</i><sub>1</sub> is not empty and the resources
          <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> required by
          <i>A</i><sub>1</sub>, but not yet allocated, are available, they are
          allocated and <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> are
          re-allocated to head(<i> q</i><sub>1</sub>); otherwise,
          <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> are released. If
          <i>q</i><sub>2</sub> is not empty, then re-allocate
          <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> to head(<i>
          q</i><sub>2</sub>); otherwise,
          <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> are released.</li>

          <li>If <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> have been
          re-allocated, a new activity of type <i>A</i><sub>1</sub> is
          started. If <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> have been
          re-allocated, a new activity of type <i>A</i><sub>2</sub> is
          started.</li>
        </ol></li>
    </ol><p>Since the Allocate-Release Modeling Pattern defines a generic
  algorithm for scheduling resource-constrained activities as well as
  allocating and releasing resources, its (pseudo-)code does not have to be
  included in a DPMN Process Diagram, but can be delegated to an OE simulator
  supporting the resource-dependent scheduling of resource-constrained
  activities according to this pattern. This approach allows introducing new
  DPMN modeling elements for expressing the Allocate-Release Modeling Pattern
  in a concise way, either leaving allocate-release steps completely implicit,
  as in the DPMN Process Diagram of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">9-22</span></span></a>, or
  explicitly expressing them, as in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">9-23</span></span></a>.</p><p>The most important new DPMN
  modeling element introduced are <em>Resource-Dependent </em><em>Activity
  Scheduling</em> (RDAS) arrows pointing to resource-constrained activities,
  as in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">9-22</span></span></a>. These arrows are high-level
  modeling elements representing the implicit allocate-release logic exhibited
  in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">9-21</span></span></a>. Thus, the meaning of the model of
  <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">9-22</span></span></a> is provided by the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">9-21</span></span></a>.</p><figure id="secAllocateReleasePattern__figAllocRelPatternPDM2"><figcaption><span class="role-label">Figure <span class="role-number">9-22</span>. </span>Using <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr> arrows in a
  conceptual process model.</figcaption><div><img alt="???" src="OEMS_files/AllocRelPattern_PDM2.svg" width="400" /></div></figure><p>It is
  an option to display the implicit allocate-release steps with
  <i>Allocate</i> and <i>Release</i> rectangles together with <em>simple
  control flow</em> arrows, as between the <i>start event</i> circle and the
  <i>Allocate R1</i> rectangle in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">9-23</span></span></a>.</p><figure id="secAllocateReleasePattern__figAllocRelPatternPDM1"><figcaption><span class="role-label">Figure <span class="role-number">9-23</span>. </span>Displaying the implicit
  allocate-release steps.</figcaption><div><img alt="???" src="OEMS_files/AllocRelPattern_PDM1.svg" width="600" /></div></figure><p>The
  meaning of the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">9-23</span></span></a> is the same
  as that of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">9-22</span></span></a>, which is provided by the
  model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">9-21</span></span></a>. The fact that, using <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr> arrows, the
  allocate-release logic of resource-constrained activities does not have to
  be explicitly modeled and displayed in a process model shows the power of
  founding a process model on an information model, since the entire resource
  management logic can be expressed in terms of resource roles, constraints
  and pools in an information model. This is in contrast to the common
  approach of industrial simulation tools, such as Simio and AnyLogic, which
  require defining resource roles, constraints and pools as well as explicit
  allocate-release steps in the process model, in a similar way as shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">9-23</span></span></a>.</p><section><h4>The Standard
  Allocate-Release Algorithm</h4><p>For each activity type, it has to be
  decided, if the resources required for a planned activity of that type are
  allocated at once or successively as soon as they become available. We call
  these two allocation policies <em>Single-Step Allocation (SSA)</em> and
  <em>Multi-Step Allocation (MSA)</em>.</p><p>We can describe the <em>Standard
  Allocate-Release Algorithm</em> for the case of an event of type <i>E</i>
  succeeded by an activity of type <i>A</i><sub>1</sub> succeeded by another
  activity of type <i>A</i><sub>2</sub>, with <i>R</i><sub>i</sub> and
  <i>q</i><sub>i</sub> being the set of resource roles and the task queue of
  <i>A</i><sub>i</sub>, in the following way:</p><ol>
      <li>WHEN an event <i>e</i>@<i>t</i> of type <i>E</i> occurs:<ol type="a">
          <li>A planned activity <i>a</i> of type <i>A</i><sub>1</sub> is
          created. If all <i>R</i><sub>1</sub> resources are available, they
          are allocated to <i>a</i>. Otherwise: (1) if MSA, then all available
          <i>R</i><sub>1</sub> resources are allocated to <i>a</i>; (2)
          <i>a</i> is added to the task queue <i>q</i><sub>1</sub>. </li>

          <li>If all <i>R</i><sub>1</sub> resources have been allocated to
          <i>a</i>, it is started.</li>
        </ol></li>

      <li>WHEN an activity <i>a</i><sub>1</sub> of type
      <i><i>A</i></i><sub>1</sub> is completed:<ol type="a">
          <li>A planned activity <i>a</i><sub>2</sub> of type
          <i>A</i><sub>2</sub> is created. If all
          <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> resources are available,
          they are allocated to <i>a</i><sub>2</sub> and
          <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> are re-allocated from
          <i>a</i><sub>1</sub> to <i>a</i><sub>2</sub> (resulting in an
          allocation of all <i>R</i><sub>2</sub> resources to
          <i>a</i><sub>2</sub>). Otherwise: (1) if MSA, then all available
          <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> resources are allocated to
          <i>a</i><sub>2</sub> and <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub>
          are re-allocated from <i>a</i><sub>1</sub> to <i>a</i><sub>2</sub>;
          (2) <i>a</i><sub>2</sub> is added to <i>q</i><sub>2</sub>.</li>

          <li>If all <i>R</i><sub>2</sub> resources have been allocated to
          <i>a</i><sub>2</sub>, it is started. In addition, if MSA, the
          release of all <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> resources
          is requested, else the release of all <i>R</i><sub>1</sub> resources
          is requested.</li>
        </ol></li>

      <li>ON <i>release request</i> for
      <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub>:<ol type="a">
          <li>If <i>q</i><sub>1</sub> is not empty and the resources
          <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> required by both
          <i>A</i><sub>1</sub> and <i>A</i><sub>2</sub> are available, they
          are allocated and <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> are
          re-allocated to head( <i>q</i><sub>1</sub>); otherwise,
          <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> are released.</li>

          <li>If the resources <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> have
          been re-allocated, a new activity of type <i>A</i><sub>1</sub> is
          started.</li>
        </ol></li>

      <li>WHEN <i>an activity of type <i>A</i><sub>2</sub></i> completes:<ol type="a">
          <li>There is no state change.</li>

          <li>An immediate release request for <i>R</i><sub>2</sub> is
          caused/scheduled.</li>
        </ol></li>

      <li>ON <i>release request</i> for <i>R</i><sub>2</sub>:<ol type="a">
          <li>If <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> is nonempty: if
          <i>q</i><sub>1</sub> is not empty and the resources
          <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> required by
          <i>A</i><sub>1</sub>, but not yet allocated, are available, they are
          allocated and <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> are
          re-allocated to head(<i> q</i><sub>1</sub>); otherwise,
          <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> are released. If
          <i>q</i><sub>2</sub> is not empty, then re-allocate
          <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> to head(<i>
          q</i><sub>2</sub>); otherwise,
          <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> are released.</li>

          <li>If <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> have been
          re-allocated, a new activity of type <i>A</i><sub>1</sub> is
          started. If <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> have been
          re-allocated, a new activity of type <i>A</i><sub>2</sub> is
          started.</li>
        </ol></li>
    </ol><p>Since the Allocate-Release Modeling Pattern defines a generic
  algorithm for scheduling resource-constrained activities as well as
  allocating and releasing resources, its (pseudo-)code does not have to be
  included in a DPMN Process Diagram, but can be delegated to an OE simulator
  supporting the resource-dependent scheduling of resource-constrained
  activities according to this pattern. This approach allows introducing new
  DPMN modeling elements for expressing the Allocate-Release Modeling Pattern
  in a concise way, either leaving allocate-release steps completely implicit,
  as in the DPMN Process Diagram of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">9-22</span></span></a>, or
  explicitly expressing them, as in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">9-23</span></span></a>.</p><p>Connecting two Activity
  rectangles with an <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr> arrow in a DPMN
  process diagram implies DPMN's standard allocate-release algorithm according
  to which required resources that have not been allocated before are
  allocated immediately before an activity requiring them is started and
  released immediately after this activity is completed if they are not
  required by a successor activity. More precisely, when an activity of type
  <i>A</i> is completed, any resource that is not required by a successor
  activity of type <i>B</i> will be allocated to the next enqueued activity of
  type <i>A</i>, if there is one, or otherwise released.</p><p>Whenever
  another (non-standard) Allocate-Release logic is needed, it has to be
  expressed explicitly using conditional event scheduling arrows instead of
  <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr>
  arrows.</p></section><section><h4>Example 1: Simplifying the workstation
  process model</h4><p>We can now simplify the workstation model using the
  resource type category for <i>WorkStation</i> in the <abbr title="Object Event">OE</abbr> class model and a resource-dependent activity
  scheduling arrow from the arrival event to the processing activity in the
  DPMN process model. The resulting class model is shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2IdmRewrite"><span class="role-label">Figure <span class="role-number">9-26</span></span></a>.</p><figure id="secAllocateReleasePattern__figWS3IDM3"><figcaption><span class="role-label">Figure <span class="role-number">9-24</span>. </span>Modeling WorkStation as a resource
  type</figcaption><div><img alt="???" src="OEMS_files/WS3_IDM3.svg" /></div></figure><p>The simplification of the
  process model of <a class="role-figure-ref" href="#secDesM__figWS3PDM2"><span class="role-label">Figure <span class="role-number">8-5</span></span></a> results in the
  model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figWS3PDM3"><span class="role-label">Figure <span class="role-number">9-25</span></span></a>.</p><figure id="secAllocateReleasePattern__figWS3PDM3"><figcaption><span class="role-label">Figure <span class="role-number">9-25</span>. </span>A simplified version of the workstation process
  model using an <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr>
  arrow.</figcaption><div><img alt="???" src="OEMS_files/WS3_PDM3.svg" width="270" /></div></figure></section><section><h4>Example 2: Simplifying
  the medical department process model</h4><p>We can now simplify the medical
  department model using the resource type category for <i>Doctor</i>,
  <i>Room</i> and <i>Nurse</i> in the OEM class model and resource-dependent
  activity scheduling arrows in the DPMN process model. The resulting class
  model is shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2IdmRewrite"><span class="role-label">Figure <span class="role-number">9-26</span></span></a>.</p><figure id="secAllocateReleasePattern__figMedDep2IdmRewrite"><figcaption><span class="role-label">Figure <span class="role-number">9-26</span>. </span>A simplified version of the medical
  department information model with Doctor and Room as resource
  types</figcaption><div><img alt="???" src="OEMS_files/MedExam2_IDM2.svg" /></div></figure><p>The simplification of the
  rather complex process model of <a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label">Figure <span class="role-number">9-20</span></span></a>
  by using resource-dependent activity scheduling arrows results in the model
  of <a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2PdmRewrite"><span class="role-label">Figure <span class="role-number">9-27</span></span></a>.</p><figure id="secAllocateReleasePattern__figMedDep2PdmRewrite"><figcaption><span class="role-label">Figure <span class="role-number">9-27</span>. </span>A simplified version of the medical
  department process model using <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr>
  arrows.</figcaption><div><img alt="???" src="OEMS_files/MedDep4_PDM2.svg" width="500" /></div></figure></section></section><section class="role-section1" id="secOrganizationModeling"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">9.4</span>. </span>Organization Modeling Concepts</h2><p>The activities of a business process are typically performed by
  human resources holding certain <em>organizational positions</em> that
  authorize them to play certain <em>organizational roles</em> within an
  organization or organizational unit. It is, therefore, natural that
  <em>Activity-Based DES</em> modeling includes organization modeling
  concepts. In particular, the concept of <em>resource roles</em> and the
  related concepts of <em>organizational roles</em> and <em>organizational
  positions</em> are paramount to Activity-Based DES modeling.</p><p>Many
  <em>resource modeling</em> concepts, such as <em>resource roles</em>
  (including <em>performer roles</em>) and <em>resource pools</em>, can be
  captured in information models in the form of categorized (&quot;stereotyped&quot;)
  UML class modeling elements such as «rr» for <em>resource role</em>
  association ends, «pr» for <em>performer role</em> association ends, and
  «rp» for <em>resource pool</em> association ends, leading to an extension of
  UML Class Diagrams, called <abbr title="Object Event">OE</abbr> Class
  Diagrams, such as the following one: </p><figure><div style="display:flex; justify-content: space-between; "><img alt="OE class model of medical departments" src="OEMS_files/MedDep_CIM2a.svg" width="500" /></div></figure><p>This conceptual <abbr title="Object Event">OE</abbr> class model describes two activity types,
  &quot;walks to rooms&quot; and &quot;examinations&quot;, each one associated with</p><ol>
      <li>the object type &quot;medical departments&quot;, providing the (business)
      <em>process owner</em>; implying that each specific walk-to-room or
      examination activity is performed by human resources of, and within a
      business process owned by, that department;</li>

      <li>a <em>performer</em> object type (&quot;nurses&quot; or &quot;doctors&quot;) via a
      <em>performer role</em> («pr») association end, providing the activity
      performer (as a special type of resource);</li>

      <li>another <em>resource</em> object type via a <em>resource role</em>
      («rr») association end, providing another resource of each activity (a
      &quot;room&quot;).</li>
    </ol><p>In addition, the model describes three types of <em>resource
  pools</em> by means of «rp» association ends, such that each resource pool
  is associated with a <em>process owner</em> maintaining the pool and
  providing the resources corresponding to one of the three resource
  roles.</p><p>Notice that in a <em>conceptual</em> <abbr title="Object Event">OE</abbr> class model, each activity type should have a
  <em>performer role</em> («pr») association, while in an <abbr title="Object Event">OE</abbr> class <em>design</em> model (being part of a
  simulation design model), it is an option to abstract away from the
  distinction of performers among the resources of an activity and simply
  consider all its resources (including its performer) as plain resources.
  This is common in management science and Operations Research, where the main
  interest is in obtaining general performance statistics for resources, such
  as their utilization, no matter if they are active resources (performers) or
  not.</p><p>We show how further organization modeling concepts can be
  introduced to <abbr title="Object Event Modeling and Simulation">OEM&amp;S</abbr>.</p><h4>Refining
  Object Types to Resource (Role) Types and Performer (Role)
  Types</h4><p>While a <em>resource role</em> of an activity type denotes an
  association end, corresponding to a reference property of the class
  implementing the activity type, a <em>resource</em> (or <em>performer</em>)
  <em>role type</em> denotes an object type that is the range of a
  <em><em>resource</em> (or <em>performer</em>) role</em>. For simplicity, we
  say &quot;resource type&quot; (or &quot;performer type&quot;) instead of &quot;resource role type&quot;
  (or &quot;performer role type&quot;).</p><p>For all «object type» classes of an <abbr title="Object Event">OE</abbr> class model that are the range of a
  <em>performer role</em> or a <em>resource role</em>, it may be an option to
  replace their «object type» category with a «performer type» or «resource
  type» category, as shown for the object types &quot;nurses&quot;, &quot;doctors&quot; and
  &quot;rooms&quot; in the following refined model:</p><figure><div><img alt="???" src="OEMS_files/MedDep_CIM2b.svg" width="500" /></div></figure><p>Notice that
  typically each resource type is the range of one resource role and
  represents a resource pool for it. A resource type may be the target class
  of more than one resource role association end and its population may be
  segmented into several resource pools such that at least one pool is
  assigned to each resource role. </p><p>However, the replacement of the
  «object type» category of a class with a (performer or resource) role type
  category is only an option, if all instances of the class are playing that
  role. In the above example, if there are doctors who do not perform
  examinations (but only surgical operations), then the object type &quot;doctors&quot;
  cannot be turned into a performer type &quot;doctors&quot; for examinations, but would
  have to be partitioned into two subtypes, &quot;surgeons&quot; and &quot;examination
  doctors&quot;, such that the latter would be a performer type for
  examinations.</p><p>In <abbr title="Object Event Modeling and Simulation">OEM&amp;S</abbr>, a human
  performer type is implicitly a subtype of the pre-defined object type
  <i>Person</i>. This makes it possible that a doctor, as a person that
  performs examinations, may also be a patient in an examination (of course,
  with the constraint that a person cannot be the same examination's doctor
  and patient).</p><h4>Refining Performer Types to Organizational
  Positions</h4><p>An <em>organizational position</em> is defined by a name
  and a set of human performer types representing the roles of the position
  holders. For instance, in a medical department, the organizational position
  <i>Nurse</i> may be defined by the set of performer types <i>Guide</i> and
  <i>ExaminationAssistant</i>, where a <i>Guide</i> is required for guiding a
  patient to an examination room and an <i>ExaminationAssistant</i> is
  required for assisting a doctor in a medical
  examination.</p><p>Computationally, an <em>organizational position</em> is
  an object type that is co-extensional with all of its performer types,
  implying that its instances (position holders) are human resources that can
  be allocated for performing any activity associated with any of these
  performer types. This implies that any instance (or &quot;holder&quot;) of an
  organizational position is a person and that any organizational position is
  a subtype of the kind <i>Person</i>. </p><p>For instance, the organizational
  position <i>Nurse</i> is co-extensional with the performer types
  <i>Guide</i> and <i>ExaminationAssistant</i>, with the meaning that nurses
  may play the role of guides or the role of examination assistants, and any
  guide, as well as any examination assistant, is a nurse.</p><p>In simple
  cases, an organizational position is defined by just one performer type for
  one particular performer role. </p><p>In <abbr title="Object Event Modeling and Simulation">OEM&amp;S</abbr>, for each
  organizational position (like <i>Clerk</i>) consisting of the performer
  roles p<sub>1</sub>,...,p<sub>n</sub>, there is a default resource pool, or
  better: performer pool, (like <i>clerks</i>) that includes all employees
  holding that position. This pool will be used for allocating the performers
  of activities with a performer role p<sub>i</sub>.</p><p>These
  considerations lead to the following refined version of the medical
  department model shown in the diagram above:</p><figure><div><img alt="???" src="OEMS_files/MedDep-Positions_CIM.svg" width="500" /></div></figure><p>Notice
  that in this refined model, we have also categorized the object type
  &quot;patients&quot; as «person role type» and the object type &quot;medical departments&quot;
  as «organizational unit type». In <abbr title="Object Event Modeling and Simulation">OEM&amp;S</abbr>, a person role
  type, like <i>Patient</i>, is implicitly a subtype of the pre-defined object
  type <i>Person</i>, allowing a doctor to be a patient. An organizational
  unit, as an instance of an organizational unit type, may own one or more
  business processes.</p><h4>Assigning business process types and business
  goals to organizational agents</h4><p>An organizational agent, which is
  either an organization, an organizational unit or an organizational role
  player, can own <em>business process types</em> and can have <em>business
  goals</em>, which allow improving business processes by refactoring business
  process models, including resource allocation policies, and by changing the
  populations of resource pools, in such a way that the goals of the process
  owner (and those of its super-agents) are satisfied.</p><p>Consider the
  following example: </p><figure class="role-example" id="secOrganizationModeling__lox__1"><figcaption><span class="role-label">Example <span class="role-number">9-1</span>. </span>Example from
  <a href="https://www.signavio.com/post/business-goals-archimate/">Modeling
  Business Goals with ArchiMate</a>.</figcaption><p>A business company has a
  Marketing department owning a Lead Generation process, a Business
  Development unit owning a Lead Qualification process, a Sales department
  owning a Sales process and a Customer Success department owning a Customer
  Success process. The company has the overall top-level goals &quot;increase
  profit&quot;, &quot;increase customer satisfaction&quot;, and &quot;increase employee
  motivation&quot;. </p><p>Without the overall company goals in mind, each
  organizational unit is prone to optimize their subprocess without keeping an
  eye on the long-term implications:</p><ul>
      <li>Marketing maximizes lead output and ignores that most leads it
      generates won’t be qualifiable.</li>

      <li>In its struggle to identify high-quality leads in a mass of
      low-quality lead data, Business development is overly eager to interpret
      leads as ‘qualified’, even if it is clear that many leads they forward
      to Sales can’t be turned into long-term customers.</li>

      <li>Sales tries to close as many deals as possible, without considering
      churn and missed up-sell opportunities if the product can’t deliver on
      the promises made.</li>

      <li>Customer success can’t do more than fight the fires of customer
      dissatisfaction.</li>
    </ul><p>This behavior is often encouraged by middle management that sets
  simple and easily quantifiable short-term performance goals for the team
  that reports to them, without keeping the big picture in
  mind.</p></figure><p>There are different ways of expressing business goals.
  In simulation modeling, we need operational forms of business goals, that
  is, expressions in a formal language. We consider three forms of business
  goals: </p><ol>
      <li><em>Definite goals</em> (like &quot;raise the overall revenue by at least
      25%&quot;) are defined by a logical condition (like relativeRevenueRise &gt;=
      0.25) that can be checked by a simulator.</li>

      <li><em>Variable change goals</em> are defined by a combination of one
      of the verbs &quot;increase&quot; or &quot;decrease&quot; with the name of a variable (like
      &quot;profit&quot;, &quot;customer satisfaction&quot; or &quot;costs&quot;).</li>

      <li><em>Optimization goals</em> are (more ambitious) special variable
      change goals defined by a combination of one of the verbs &quot;maximize&quot; or
      &quot;minimize&quot; with the name of a variable (like &quot;profit&quot;, &quot;customer
      satisfaction&quot; or &quot;costs&quot;).</li>
    </ol><p></p></section><section class="role-section1" id="ResourceModeling-Intro"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">9.5</span>. </span>Resource Modeling</h2><p>Whenever an activity of a certain type is to be performed, various
  resources may be required for performing it and have to be allocated first.
  We can distinguish between ‘active’ (or <em>performer</em>) resources, such
  as human resources, robots or IT systems, which execute activities, and
  ‘passive’ resources, such as rooms or devices, which are used by performers
  for executing activities.</p><p>Business process models focus on describing
  the possible sequences of events and activities, based on conditional and
  parallel branching. But they may also describe resource roles, which
  associate resources of a certain type with activities of a certain type.
  </p><p>In the field of Business Process Management (BPM), there is a
  tendency to consider workflow processes as paradigmatic for business
  processes. However, workflow processes typically only have (human) performer
  resources, while business processes in general often have one or more
  passive resources in addition to a performer. Due to this tendency, BPM
  research often adopts a simplistic view of business processes. </p><p>E.g.,
  in (Pufahl et al. 2021), resource allocation is defined as the “assignment
  of a process task to the most appropriate resource”, while in general, it’s
  the other way around: resources are assigned to a task. The authors also
  point out that the vast majority of BPM research studies on resource
  allocation make the assumption that a task requires just one resource and a
  resource cannot be used in more than one task at the same time. As opposed
  to this simplistic view of business processes in BPM, in DES, tasks can have
  more than one required resource, and resources may be used in more than one
  task at the same time. </p><p>It is important to distinguish between the
  passive resources required for performing an activity and the inputs
  required for performing a <em>processing</em> (or <em>transformation</em>)
  activity. While the passive resources used in an activity survive the
  activity, and can be reused in the next one, inputs are either processed, or
  transformed, into outputs of the activity, and cannot be reused for the next
  activity. In the literature, this conceptual distinction is often not made.
  Instead, e.g., in (Russell et al. 2004; Goel and Lin 2021), <em>processing
  activity</em> inputs are called ‘consumable resources’. However, resources
  cannot be ‘consumed’, but they can be worn out by activities, such that if
  their degree of wear falls below a certain threshold, they can no longer be
  used and are depleted.</p><p>For various reasons, resources can go out of
  order: machines may fail or may have to get scheduled maintenance, nurses or
  doctors may get sick or may be out-of-duty or off-shift. Consequently, both
  planned and unexpected resource outages may have to be modeled.</p><section class="role-section2" id="ResMod-Constraints"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">9.5.1</span>. </span>Resource Cardinality Constraints and Multitasking
    Constraints</h3><p>Since activities require resources, and resources are allocated to
  planned activities, it is crucial to understand the relationship between
  activities and resources. An important part of its meaning are <em>resource
  cardinality constraints</em> and <em>multitasking
  constraints</em>.</p><p>Business process models do not only describe the
  possible sequences of events and activities, but they also describe the
  dependency of activities on resources. For instance, in a BPMN process
  diagram, a Lane <i>L</i> (such as the <i>doctors</i> lane in the BPMN
  process diagram below) may represent a resource type such that the diagram
  specifies for any Activity rectangle <i>A</i> in <i>L</i> (such as
  <i>examinations</i>) that an activity of type <i>A</i> is performed by a
  resource of type <i>L</i>. </p><figure id="ResMod-Constraints__figExamDoc"><figcaption><span class="role-label">Figure <span class="role-number">9-28</span>. </span>Doctors
  perform examinations.</figcaption><div><img alt="???" src="OEMS_files/doctors-perform-examinations_BPMN.svg" width="250" /></div></figure><p>While using a container shape, such as a
  BPMN Lane, for assigning elements, such as activities, to the element
  represented by the container shape (viz, a resource role) is a good way of
  visually expressing a many-to-one relationship between activity types and
  resource roles (all activity types within a Lane do have exactly one
  resource role), it does not allow expressing one-to-many or many-to-many
  relationships between activity types and resource roles. </p><p>Therefore,
  the BPMN Lane notation can only be used for specifying a performer resource
  role for activities that do not require resources of other types, and where
  we have a one-to-one association: (1) a resource can be allocated to <em>at
  most one</em> activity, and (2) an activity is performed by <em>exactly
  one</em> resource.</p><p>In general, though, the relationships between
  activities (of some type) and resources (of some type) can be best described
  by binary relationship types in an information model, such as by binary
  associations in a UML class diagram with <em>multiplicity</em> expressions
  at both ends. <a class="role-figure-ref" href="#ResMod-Constraints__figExamDocRoom"><span class="role-label">Figure <span class="role-number">9-29</span></span></a> shows two one-to-one
  associations between the activity type <i>examinations</i> and the object
  types <i>rooms</i> and <i>doctors</i> associating a room as a (passive)
  resource and a doctor as a performer resource to an examination
  activity.</p><figure id="ResMod-Constraints__figExamDocRoom"><figcaption><span class="role-label">Figure <span class="role-number">9-29</span>. </span>An examination requires
  two resources: a room and a doctor.</figcaption><div><img alt="???" src="OEMS_files/Exam-Doc.svg" width="600" /></div></figure><p>The association
  end at the side of the object type <i>doctors</i> is categorized as a
  <em>resource role</em> with the help of UML’s stereotype notation. The
  multiplicity expression at the resource role end is called <em>resource
  multiplicity</em>. In our example, the resource multiplicity at the
  <i>doctors</i> end is ”1” (an abbreviation of &quot;1..1&quot;), which means that
  exactly one doctor is required for performing an examination, defining a
  <em>resource cardinality constraint</em> that is a conjunction of a
  <em>minimum resource cardinality constraint</em> (&quot;at least one&quot;) and a
  <em>maximum resource cardinality constraint</em> (&quot;at most one&quot;).</p>In
  general, a multiplicity expression defines both a lower bound and an upper
  bound. When the lower bound of a resource multiplicity is greater than 0, it
  defines a <em>minimum resource cardinality constraint</em>. When the upper
  bound of a resource multiplicity is a natural number greater than 0, it
  defines a <em>maximum resource cardinality constraint</em>. The resource
  multiplicity 0..* (where * stands for <em>unbounded)</em>, which does not
  define any resource cardinality constraint, is rather unusual since normally
  all activities require at least one resource (their performer).<p>The
  multiplicity of the association end at the other side (of the activity type)
  represents a <em>multitasking constraint</em>, which defines if a resource
  is exclusively allocated to an activity, or to how many activities a
  resource can be allocated at the same time. In our example, the multiplicity
  0..1 represents a multitasking constraint stating that, at any point in
  time, a doctor can be associated with, or perform, either no examination or
  at most one examination. </p><p>In an Object-Oriented (OO) programming
  approach, the computational meaning of a resource role is provided by a
  corresponding property in the class implementing the activity type. In the
  above example, the resource role association of &quot;examinations&quot; with
  &quot;doctors&quot; leads to a property <i>doctor</i> in the class <i>Examination</i>,
  as shown in <a class="role-figure-ref" href="#ResMod-Constraints__figExam"><span class="role-label">Figure <span class="role-number">9-30</span></span></a>.</p><p>When activities admit using more
  resources than required, this means they can be started as soon as the
  required number of resources are available, but they can also be started
  with a greater number of resources, typically implying a faster
  performance.</p><figure id="ResMod-Constraints__figExam"><figcaption><span class="role-label">Figure <span class="role-number">9-30</span>. </span>The class
  <i>Examination</i> implementing the corresponding activity
  type.</figcaption><div><img alt="???" src="OEMS_files/Examination.svg" width="120" /></div></figure><p>While the model shown in <a class="role-figure-ref" href="#ResMod-Constraints__figExamDocRoom"><span class="role-label">Figure <span class="role-number">9-29</span></span></a> is an example of a <em>one-to-one</em>
  association between an activity type and a resource object type, which is
  the only option in BPMN process models, we consider the cases of
  <em>one-to-many</em>, <em>many-to-one</em> and <em>many-to-many</em>
  associations in the following subsections.</p><section><h4>One-to-Many
  Relationships</h4><p>An example of a one-to-many relationship between
  activity types and resource object types is the association between ”load
  truck” activities and ”wheel loader” resources shown in <a class="role-figure-ref" href="#ResMod-Constraints__figLoadWheelLoaders"><span class="role-label">Figure <span class="role-number">9-31</span></span></a>.</p><figure id="ResMod-Constraints__figLoadWheelLoaders"><figcaption><span class="role-label">Figure <span class="role-number">9-31</span>. </span>The loading of a truck requires at
  least one, and can be handled by at most two, wheel
  loaders.</figcaption><div><img alt="???" src="OEMS_files/Load-Loaders.svg" width="320" /></div></figure><p>Notice that in this diagram, the «resource
  role» designation of the association end at the side of “wheel loaders” has
  been abbreviated by the keyword «rr». Its resource multiplicity of 1..2
  specifies a <em>minimum resource cardinality constraint</em> of “at least
  one” and a <em>maximum resource cardinality constraint</em> of “at most
  two”, meaning that one wheel loader is required and a second one is
  admissible. When an activity does not require, but admits of, using more
  than one resource (of the same type), this typically means that the duration
  of the activity is the more decreasing the more resources are being
  used.</p><p>The one-to-many resource role association of ”load truck” with
  ”wheel loaders” leads to a property <i>wheelLoaders</i> in the activity
  class <i>LoadTruck</i>, as shown in <a class="role-figure-ref" href="#ResMod-Constraints__figLoadTruck"><span class="role-label">Figure <span class="role-number">9-32</span></span></a>. Notice
  that this property has the multiplicity 1..2, which means that it is
  collection-valued and has either a singleton or a two-element collection
  value.</p><figure id="ResMod-Constraints__figLoadTruck"><figcaption><span class="role-label">Figure <span class="role-number">9-32</span>. </span>The class LoadTruck
  implementing the corresponding activity type.</figcaption><div><img alt="Load Truck activity rectangle" src="OEMS_files/LoadTruck.svg" width="200" /></div></figure><p>When activities admit using more resources
  than required, this means they can be started as soon as the required number
  of resources are available, but they can also be started with a greater
  number of resources, typically implying a shorter
  duration.</p></section><section><h4>Many-to-One Relationships</h4><p>An
  example of a many-to-one relationship between activity types and resource
  object types is the association between ”examination” activities and
  ”examination room” resources shown in <a class="role-figure-ref" href="#ResMod-Constraints__figExamRoom"><span class="role-label">Figure <span class="role-number">9-33</span></span></a>.</p><figure id="ResMod-Constraints__figExamRoom"><figcaption><span class="role-label">Figure <span class="role-number">9-33</span>. </span>An
  examination room may be used by up to 3 examinations at the same
  time.</figcaption><div><img alt="???" src="OEMS_files/Exam-Room.svg" width="350" /></div></figure><p>In this example, examination rooms (as
  resources) admit of up to three examinations being performed at the same
  time. Such a <em>multitasking constraint</em> can be implemented with the
  help of a (multitasking) <em>capacity</em> attribute of the class
  implementing the resource object type. If such a constraint applies to all
  instances of a resource object type, <em>capacity</em> would be a
  class-level (”static”) attribute, which is rendered underlined in a UML
  class diagram, as shown in the following model:</p><figure><div><img alt="Load Truck activity rectangle" src="OEMS_files/ExaminationRoom.svg" width="150" /></div></figure><p>Alternatively, if different examination
  rooms have different capacities, then <em>capacity</em> would be an ordinary
  (instance-level) attribute of the class
  <i>ExaminationRoom</i>.</p></section><section><h4>Many-to-Many
  Relationships</h4><p>Examples of many-to-many relationships between activity
  types and resource object types are rare and typically involve activities
  going on with interruptions. An example is the association between ”teaching
  a course” activities and ”teacher” resources shown in <a class="role-figure-ref" href="#ResMod-Constraints__figTeaching"><span class="role-label">Figure <span class="role-number">9-34</span></span></a>. In this example, the teaching of a course admits
  at most two teachers who may be involved in at most 7 course teaching
  activities at the same time.</p><figure id="ResMod-Constraints__figTeaching"><figcaption><span class="role-label">Figure <span class="role-number">9-34</span>. </span>The
  teaching of a course is performed by teachers.</figcaption><div><img alt="???" src="OEMS_files/Teaching-Teachers.svg" width="400" /></div></figure></section></section><section class="role-section2" id="ResMod-OrganizationalPositions"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">9.5.2</span>. </span>Organizational Positions and Resource Pools</h3><p>Since a business process happens in the context of an organization,
  it is natural to consider the concept of <em>organizational positions</em>,
  which has been introduced in <a class="role-section1-ref" href="#secOrganizationModeling"><span class="role-label">Section <span class="role-number">9.4</span></span></a>.
  </p><p>Resource roles (including performer roles), resource types (including
  performer types), organizational positions and resource pools are defined in
  an <abbr style="Object-Event">OE</abbr> class model. A <i>resource role</i>
  of an activity type is a special type of property having a resource type as
  its range.</p><p>A <em>performer role</em> of an activity type has a
  <em>performer type</em> as its range. For instance, in the following <abbr title="Object Event">OE</abbr> class model, the (implicitly named) performer
  role <i>orderTaker</i> of the activity type <i>TakeOrder</i> has the
  performer type <i>OrderTaker</i> as its range. Likewise the object type
  <i>PizzaMaker</i> is a performer type. A performer type may be an
  organizational position. For instance, in the following <abbr title="Object Event">OE</abbr> class model, both <i>OrderTaker</i> and
  <i>PizzaMaker</i> are organizational positions, for which an organization
  hires a number of human resources, forming corresponding resource pools
  (called <i>orderTakers</i> and <i>pizzaMakers</i>). These resource pools
  correspond to the direct populations of the two organizational
  positions.</p><figure><img alt="conceptual information model describing object, event and activity types" src="OEMS_files/Pizzeria-AlternativeResourceSubtyping_IDM.svg" width="450" /></figure><p>An organizational position may subsume more than
  one performer role. In the model above, the organizational position
  <i>PizzaMaker</i> is an alternative resource subtype of the organizational
  position <i>OrderTaker</i>, as indicated by the generalization arrow with
  the category keyword «ar» (a UML &quot;stereotype&quot;).</p><p>When a resource pool
  represents an organizational position charged with playing <i>n</i>
  performer roles, it is used by all <i>n</i> corresponding activity
  types.</p><p>It is an option that the resources of an alternate resource
  pool, corresponding to an alternative resource subtype, are associated with
  a lower <em>proficiency level</em> increasing both the duration of
  activities and their <em>rework probabilities</em>.</p></section><section class="role-section2" id="ResMod-Alternative-resources"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">9.5.3</span>. </span>Alternate Resource Pools</h3><p>Certain activities allow alternative resources, when no standard
  resources are available. For instance, in a pizza service company, when no
  order taker is available, and a new order call comes in, an available pizza
  baker can take the order. Or in a hospital, where nurses guide patients to
  an examination room, when no nurse is available, a receptionist can guide a
  patient to an examination room.</p><p>The general conceptual pattern is that
  for certain types of activities <i>A</i> (like <i>GuideToRoom</i>), a
  resource role <i>r</i> (like <i>guide</i>) may be played not only by
  instances of its direct resource type <i>R</i> (like <i>Guide</i>), but also
  by instances of an alternative resource type <i>R'</i> (like
  <i>ExaminationAssistant</i>) or an organizational position <i>P</i> (like
  <i>Nurse</i>), if they are a subtypes of <i>R</i> (<i>Guide</i>).</p><p>When
  the resource type <i>R</i> is not abstract, then its instances are the
  preferred resources of activities of type <i>A</i>, and its (possibly
  preference-rank-annotated) alternate resource subtypes specify types of
  alternative resources.</p><p>By default, for any non-abstract resource type
  <i>R</i> and for any organizational position <i>P</i> assigned as the range
  of a resource role <i>r</i>, an <abbr style="Object-Event">OE</abbr>
  simulator can create a resource pool with the same (yet pluralized) name,
  pooling objects instantiating <i>R</i> or <i>P</i>, and assign it to
  <i>r</i> as the preferred resource pool. </p><p>An alternate resource pool
  can be defined in an <abbr title="Object Event">OE</abbr> class model by
  means of an <em>alternate resource subtyping arrow</em> (a UML
  generalization arrow designated with «ar») between the alternative resource
  type and the resource type concerned as shown in the following diagram,
  where <i>PizzaMaker</i> is modeled as an alternative resource subtype of
  <i>OrderTaker:</i></p><figure><img alt="conceptual information model describing object, event and activity types" src="OEMS_files/Pizzeria-AlternativeResourceSubtyping_IDM.svg" width="450" /></figure></section><section class="role-section2" id="ResMod-Task-priorities"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">9.5.4</span>. </span>Task Priorities</h3><p>Whenever an activity of type A1 ends and there is still another A1
  task in the queue, the activity's resources would be re-used for the next A1
  task unless there is another task (say, of type A2) with higher priority
  waiting for one of the resources (r1). In that case, r1 is allocated to that
  task, and all other resources are allocated to the next A1 task, which still
  has to wait for r1 becoming available again.</p><p>For example, in a pizza
  service, where incoming orders can be taken by pizza makers, and
  <i>TakeOrder</i> tasks have a higher priority than <i>MakePizza</i> tasks,
  when a <i>MakePizza</i> activity performed by a pizza maker in an oven ends
  while there is still another <i>MakePizza</i> task in the queue and there is
  also a <i>TakeOrder</i> task in the queue, the pizza maker is allocated to
  the <i>TakeOrder</i> task and the oven is allocated to the next
  <i>MakePizza</i> task, which has to wait for a pizza maker becoming
  available.</p><p><b>Algorithmically</b>: Whenever an activity a1 of type A1
  ends, collect all pairs &lt;r, t&gt; such that r is a resource used by a1
  and t is the next task of an activity type A from the dependent activity
  types DAT of pool(r) with the highest priority among all DAT with task
  priorities higher than A1. For all these pairs &lt;r, t&gt;, allocate r to
  t. Allocate the remaining resources of a1 to the next A1 task, if there is
  any, otherwise release them. </p><p></p></section><section class="role-section2" id="ResMod-Activity-Preemption"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">9.5.5</span>. </span>Activity Preemption</h3><p>An ongoing activity may be preempted by a higher-priority task
  requiring a resource used by the ongoing activity. In such a case, the
  activity is either aborted or suspended, and the required resource is
  released from it and allocated to the higher-priority task. A suspended
  activity may be later resumed when a resource of the required type becomes
  available again.</p></section><section class="role-section2" id="ResMod-Resource-Outages"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">9.5.6</span>. </span>Resource Outages</h3><p>For various reasons, resources can go out of order: machines may
  fail or may have to get scheduled maintenance, nurses or doctors may get
  sick or may be out-of-duty or off-shift. Consequently, both planned and
  unexpected resource outages may have to be modeled.</p><p>While human
  resources being out-of-duty or off-shift can be modeled with the help of
  service time calendars, scheduled maintenance may be modeled in the form of
  maintenance activities recurring with a fixed interval. Unexpected resource
  outages are <em>resource failures</em>.</p><h4>Modeling Resource
  Failures</h4><p>Resource failures can be modeled with the help of two types
  of events: <em>failure</em> and <em>recovery</em>, and two related random
  variables: <em>time-to-next-failure</em> and <em>failure time</em>. In this
  approach, the next resource failure event occurs <i>x</i> time units after a
  recovery event, where <i>x</i> is obtained by invoking the random variable
  sampling function <code>timeToNextFailure()</code>. Each failure event
  triggers a recovery event, which is scheduled with a delay of <i>y</i> time
  units where <i>y</i> is obtained by invoking the random variable sampling
  function <code>failureTime()</code>.</p><p>This simple approach applies both
  to non-human and human resources.</p><p>Further modeling options:</p><ul>
      <li>Allow specifying a <em>time-to-first-failure</em>, in addition to
      the <em>time-to-next-failure</em>.</li>

      <li>Allow counting only the busy time of a resource, instead of the
      total time, for determining its next failure time.</li>
    </ul><h4>Modeling the Repair of Failed Resources </h4><p>In activity-based
  simulation, the basic failure modeling approach can be refined by modeling
  the <em>repair</em> of a failed non-human resource as an activity whose
  duration is provided by the random variable <em>repair time</em> and which
  requires a repair person as a resource, such that the total failure time is
  the sum of the two random variables <em>repair lead time</em> (the time
  needed for getting a repair person to start the repair) and <em>repair
  time</em>. </p><p>Then, when a <em>failure</em> event occurs, it triggers a
  <em>repair</em> activity to start with a delay of <i>x</i> time units and a
  duration of <i>y</i> time units, where <i>x</i> =
  <code>repairLeadtime()</code> and <i>y</i> = <code>repairTime()</code>. The
  next failure event is scheduled to occur <i>z</i> time units after a
  <em>repair</em> end event, where <i>z</i> is obtained by invoking the random
  variable sampling function <code>timeToNextFailure()</code>.</p><h4>Modeling
  the Scheduled Maintenance of Resources</h4><p>Non-human resources, such as
  machines, may undergo periodic maintenance for preventing them to fail in
  the near future. This can be modeled by scheduling periodic
  <em>maintenance</em> activities every <i>x</i> time units where <i>x</i> =
  <code>maintenanceIntervall()</code>, along with periodic failure events.
  </p><p>When a <em>maintenance</em> activity starts before the next scheduled
  <em>failure</em> event has occurred, the simulator has to retract this event
  from the <em>Future Event List</em> for implementing its prevention by the
  maintenance activity. The next <em>failure</em> event is scheduled to occur
  <i>x</i> time units after the <em><em>maintenance</em></em> end event, where
  <i>x</i> is obtained by invoking the random variable sampling function
  <code>timeToNextFailure()</code>. </p><p>When a resource fails before its
  next scheduled <em>maintenance</em> has started, the scheduled
  <em>maintenance</em> is cancelled (the simulator has to retract the
  scheduled <em>maintenance</em> start event) and, instead, the
  <em>failure</em> event triggers a <em>repair</em> activity. Only when the
  <em>repair</em> activity ends, the next <em>maintenance</em> activity is
  scheduled with a delay of <i>y</i> time units where <i>y</i> is obtained by
  invoking the random variable sampling function
  <code>maintenanceTime()</code>.</p><p>Further modeling options:</p><ul>
      <li>Allow specifying a <em>time-to-first-maintenance</em>, in addition
      to the maintenance interval <em>time-to-next-maintenance</em>.</li>

      <li>Allow specifying the recurrence of maintenance activities with a
      <em>schedule</em> instead of a (typically fixed) maintenance
      interval.</li>
    </ul><h4>Defining General Elements for Modeling Resource Outages</h4><p>A
  simulation framework/language should support resource outage modeling by
  allowing to define for each (non-human) resource object type the three pairs
  of (typically random variable) time functions introduced above and
  summarized in the following class diagram.</p><figure><div><img alt="???" src="OEMS_files/AbstractResource.svg" width="300" /></div></figure><p>These
  pairs of time functions have to be used incrementally: specifying
  maintenance time functions requires specifying repair time functions, which,
  in turn, requires specifying failure time functions.</p><h4>Resource Outage
  Modeling in AnyLogic</h4><p>AnyLogic is a state-of-the-art DES modeling
  tool/framework. It allows defining recurrent failures (not with follow-up
  recovery events, but only with follow-up repair activities) and maintenance
  for each <a href="https://anylogic.help/library-reference-guides/process-modeling-library/resourcepool.html">Resource
  Pool</a>. There is the option to use only the busy time of a resource for
  computing its next failure time. For repair activities, there is no
  possibility to distinguish between repair lead time and repair time. For
  maintenance activities, it can be defined which task priority they have and
  if they are preemptive or not. Neither for repair nor for maintenance
  activities, performer resources can be assigned. </p></section></section></section><section class="role-chapter" id="secPN-CM"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">10</span>. </span>Conceptual Modeling of Processing Networks</h1><p>For accommodating PN modeling, OEM-A is extended by adding
  pre-defined types for processing objects, entry node objects, arrival
  events, processing node objects, processing activities, exit objects and
  departure events, resulting in <em>OEM-PN</em>. These &quot;built-in&quot; types,
  which are described in <a class="role-figure-ref" href="#secPN-CM__figPredefinedTypes4PN_CM"><span class="role-label">Figure <span class="role-number">10-1</span></span></a>, allow
  making PN models based on them simply by making a process model (with DPMN)
  without the need of making an information/class model as its foundation, as
  shown in <a class="role-figure-ref" href="#secPN-CM__figDmvCPM"><span class="role-label">Figure <span class="role-number">10-2</span></span></a>.</p><figure id="secPN-CM__figPredefinedTypes4PN_CM"><figcaption><span class="role-label">Figure <span class="role-number">10-1</span>. </span>A conceptual OEM class model
  defining built-in types for conceptual PN modeling</figcaption><div><img alt="???" src="OEMS_files/PN-PredefinedTypes-CM.svg" width="400" /></div></figure><section><h4>An example of a conceptual PN
  model: Department of Motor Vehicles</h4><p>As a simple example of a PN
  simulation model we consider a Department of Motor Vehicles (DMV) with two
  consecutive service desks: a reception desk and a case handling desk. When a
  customer arrives at the DMV, she first has to queue up at the reception desk
  where data for her case is recorded. The customer then goes to the waiting
  area and waits for being called by the case handling desk where her case
  will be processed. After completing the case handling, the customer leaves
  the DMV via the exit.</p><p>Customer arrivals are modeled with an «entry
  node» element (with name “DMV entry”), the two consecutive service desks are
  modeled with two «processing node» elements, and the departure of customers
  is modeled with an «exit node» element (with name “DMV exit”).</p><p>DPMN is
  extended by adding the new modeling elements of</p><ol>
      <li><em>Entry/Processing/Exit Node</em> rectangles representing node
      objects that take the form of stereotyped UML object rectangles;</li>

      <li><em>Processing Flow</em> arrows representing the combination of an
      object flow arrow with an RDAS arrow (pointing to processing nodes),
      having a special arrow head consisting of a circle and three bars, as
      shown in <a class="role-figure-ref" href="#secPN-CM__figDmvCPM"><span class="role-label">Figure <span class="role-number">10-2</span></span></a>;</li>

      <li><em>Object-Event Flow</em> arrows, representing the combined
      object-event flow from processing nodes to exit nodes, as shown in <a class="role-figure-ref" href="#secPN-CM__figDmvCPM"><span class="role-label">Figure <span class="role-number">10-2</span></span></a>.</li>
    </ol><figure id="secPN-CM__figDmvCPM"><figcaption><span class="role-label">Figure <span class="role-number">10-2</span>. </span>A PN model using the new DPMN
  modeling elements of PN Node rectangles, Processing Flow arrows and
  Object-Event Flow arrows</figcaption><div><img alt="???" src="OEMS_files/DMV_CPM.svg" width="600" /></div></figure></section><section><h4>Using both Processing
  Flow arrows and Event Flow arrows</h4><p>While a Processing Flow arrow
  between two nodes implies both a flow of the processing object to the
  successor node and the resource-dependent scheduling of the next processing
  activity, an Event Flow arrow from a processing node to an Event circle
  represents an event flow where a processing activity end event
  causes/schedules another event, as illustrated in the example of <a class="role-figure-ref" href="#secPN-CM__figDMVCPM2"><span class="role-label">Figure <span class="role-number">10-3</span></span></a>.</p><figure id="secPN-CM__figDMVCPM2"><figcaption><span class="role-label">Figure <span class="role-number">10-3</span>. </span>A DPMN-PN
  process diagram with an Event Scheduling arrow </figcaption><div><img alt="???" src="OEMS_files/DMV_CPM2.svg" width="600" /></div></figure></section></section><section class="role-chapter" id="secPN-DM"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">11</span>. </span>Processing Network Design Models</h1><p>For accommodating PN modeling, OEM-A is extended by adding pre-defined types for processing objects, entry node objects, arrival events,
  processing node objects, processing activities, exit objects and departure events, resulting in <em>OEM-PN</em>. These &quot;built-in&quot; types, as
  described in <a class="role-figure-ref" href="#secPN-DM__figPredefinedTypes4PN"><span class="role-label">Figure <span class="role-number">11-1</span></span></a>, allow making PN models based on them simply by making a process model with DPMN without the need
  of making an OEM class model as its foundation, as shown in <a class="role-figure-ref" href="#secPN-DM__figWS3PDM-PN"><span class="role-label">Figure <span class="role-number">11-2</span></span></a>.</p><figure id="secPN-DM__figPredefinedTypes4PN"><figcaption><span class="role-label">Figure <span class="role-number">11-1</span>. </span>An OEM
  class design model defining built-in types for making PN design models</figcaption><div><img alt="???" src="OEMS_files/PN-PredefinedTypes.svg" /></div></figure><p>Notice that the range of the properties <i>arrivalRecurrence</i>, <i>successorNodes</i> and
  <i>duration</i> of the built-in object types <i>EntryNode</i> and <i>ProcessingNode</i> is <code>Function</code>, which means that the value of such
  a property for a specific node is a specific function. While the standard UML semantics does not support such an extension of the semantics of
  properties in the spirit of the <em>Functional Programming</em> paradigm, its implementation in a functional OO programming language like
  JavaScript, where objects can have instance-level functions/methods, is straightforward.</p><p>The property <i>successorNodes</i> allows to express
  a function that provides, for any given entry or processing node, a (possibly singleton) set of processing nodes or exit nodes. Such a function can
  express several cases of routing a processing object from a node to one or more successor nodes:</p><ol>
      <li>a fixed unique successor node for modeling a series of processing nodes connected by (possibly conditional) object flow
      arrows, as in <a class="role-figure-ref" href="#secPN-DM__figDmvPDM"><span class="role-label">Figure <span class="role-number">11-4</span></span></a>;</li>
      <li>a conditional unique successor node for modeling an Exclusive (XOR) Gateway leading to one of several possible successor nodes;</li>
      <li>a variable subset of a set of potential successor nodes for modeling an Inclusive (OR) Gateway;</li>
      <li>a fixed set of successor nodes for modeling a Parallel (AND) Gateway;</li>
    </ol><p> In a DPMN diagram, the set of successor nodes of a node is defined by Flow Arrows, possibly in combination with
  Gateways.</p><section><h4>PN example 1: a single workstation</h4><p>Part arrivals are modeled with an «entry node» element (with name “partEntry”),
  the workstation is modeled with a «processing node» element, and the departure of parts is modeled with an «exit node» element (with name
  “partExit”).</p><p>DPMN is extended by adding the new modeling elements of <em>PN Node</em> rectangles, representing node objects with associated
  event types, and <em>PN Flow</em> arrows, representing combined object-event flows. PN Node rectangles take the form of stereotyped UML object
  rectangles, while PN Flow arrows have a special arrow head, as shown in <a class="role-figure-ref" href="#secPN-DM__figWS3PDM-PN"><span class="role-label">Figure <span class="role-number">11-2</span></span></a>. </p><figure id="secPN-DM__figWS3PDM-PN"><figcaption><span class="role-label">Figure <span class="role-number">11-2</span>. </span>A PN
  model of a workstation system using PN Node rectangles and PN Flow arrows</figcaption><div><img alt="???" src="OEMS_files/WS3_PDM-PN.svg" width="450" /></div></figure></section><section><h4>PN example 2: a workstation may have to rework parts</h4><p>Parts that turn out to be defective
  after being processed need to be reworked. This can be modeled by adding an attribute percentDefective to the object type Workstation and suitable
  logic to the Processing activity end event rule such that in percentDefective % of all cases a processed part cannot depart the system (i.e., is not
  removed from the input buffer), but is being reworked by another Processing activity.</p><figure id="secPN-DM__figWS4PDM-PN"><figcaption><span class="role-label">Figure <span class="role-number">11-3</span>. </span>A PN model of a
  workstation system where parts may have to be reworked </figcaption><div><img alt="???" src="OEMS_files/WS4_PDM-PN.svg" width="550" /></div></figure></section><section><h4>PN example 3: Department of Motor Vehicles</h4><p>A Department of Motor Vehicles (DMV) has two
  consecutive service desks: a reception desk and a case handling desk. When a customer arrives at the DMV, she first has to queue up at the reception
  desk where data for her case is recorded. The customer then goes to the waiting area and waits for being called by the case handling desk where her
  case will be processed. After completing the case handling, the customer leaves the DMV via the exit.</p><p>Customer arrivals are modeled with an
  «entry node» element (with name “dmvEntry”), the two consecutive service desks are modeled with two «processing node» elements, and the departure of
  customers is modeled with an «exit node» element (with name “dmvExit”).</p><figure id="secPN-DM__figDmvPDM"><figcaption><span class="role-label">Figure <span class="role-number">11-4</span>. </span>A PN model using the new DPMN modeling
  elements of PN Node rectangles and PN Flow arrows</figcaption><div><img alt="???" src="OEMS_files/DMV_PDM.svg" width="600" /></div></figure></section></section></section><section class="role-part" id="AgentBasedDES-Intro"><h1 class="role-part-title"><span class="role-label">Part <span class="role-number">III</span>. </span>Agent-Based Modeling and Simulation</h1><p>The term &quot;agent-based modeling&quot; is an umbrella term that subsumes
  many different approaches to simulation, typically focused on modeling
  (collections of) entities/objects/individuals/&quot;agents&quot; and their
  interactions with each other and with their environment. In any case, since
  the interactions of agents are based on discrete perception and action
  events, it is natural to define an agent-based modeling and simulation
  approach as an extension of a <abbr title="Discrete Event Simulation">DES</abbr> approach, such that it is an
  option to use the concept of agents along with the more basic concepts of
  objects and events. Along these lines, OEM&amp;S can be extended by adding
  the concept of agents, together with concepts of perception and action
  events as well as communication, resulting in <em>Agent/Object Event
  Modeling and Simulation (A/OEM&amp;S)</em>.</p><p>In academic research, the
  term &quot;agent-based&quot; M&amp;S is used ambiguously both for
  <em>individual-based</em> and <em>cognitive agent</em> M&amp;S. The former,
  which is also called &quot;microscopic&quot; simulation (or
  <em>micro-simulation</em>), is focused on modeling (collections of)
  individuals and their interactions with each other and with their
  environment for modeling complex systems, whereas the latter is more
  concerned with modeling the cognitive state and cognitive operations of an
  agent. </p><p>Consequently, it seems natural to distinguish between a weak
  concept of agents, which we call <em>basic agents</em>, where agents are
  entities that interact with their environment and with each other, and a
  strong concept, called <em>cognitive agents</em>, that is based on modeling
  the cognitive (or mental) state and operations of agents. </p><p>The
  cognitive state of basic agents has only one component: their information
  state containing propositional information about their environment and about
  themselves resulting both from <em>perception</em> and from
  <em>communication</em>. A propositional information item of an information
  state can be expressed in the form of a <em>triple statement</em> (or,
  simply, <em>triple</em>), which is an atomic predicate logic sentence that
  consists of (1) an <em>object name</em>, (2) a <em>property name</em>, and
  (3) a <em>property value</em>. Such an information item can be viewed as a
  <em>belief</em> of an agent, or as a <em>knowledge</em> item (where
  knowledge means correct information or true belief).</p><p>Beliefs represent
  the typically partial and sometimes incorrect subjective information of
  agents about their environment and about themselves. They are the most basic
  component of the cognitive state of an agent. The simplest model of a
  cognitive state only consists of beliefs, while more advanced models may
  also include commitments, goals, intentions, emotions, etc. </p><p>Many
  agent-based (in particular, individual-based) M&amp;S approaches do not
  attempt to support the incompleteness of beliefs/information or the
  possibility of incorrect beliefs/information. They make the (tacit)
  assumption that agents have <em>perfect information</em> and focus on
  modeling interactive behavior: (1) the interaction of an agent with its
  inanimate environment via a perception-action cycle, and (2) the
  communication between agents.</p><p>A general model of the interactive
  behavior of agents depends, at least, on their information state, which is
  </p><ol>
      <li>queried for decision making, and from which information items are
      retrieved for informing other agents;</li>

      <li>updated when new information is obtained by means of perception or
      communication.</li>
    </ol><p>In the general case of a cognitive agent with possibly false
  beliefs, its <em>belief state</em> (or <em>subjective information
  state</em>) has to be represented as a kind of restricted and modified
  duplicate of the objective information state managed by the simulator,
  requiring a more complex simulator architecture. Within such an
  architecture, the information state of a <em>perfect information agent</em>
  has to be short-circuited with the objective information state managed by
  the simulator.</p><section class="role-chapter" id="BasicAgents"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">12</span>. </span>Basic Agents with Perfect Information</h1><p>Basic agents are objects that (1) have an information state, (2)
  may have perceptions of their environment affecting their information state,
  and (3) may communicate with each other and, as a consequence, change their
  information state. We define <em>perfect information</em> agents as basic
  agents that </p><ol>
      <li>have <em>complete</em> and <em>correct</em> information about all
      objects they know;</li>

      <li>are <em>sincere</em>: they do not provide intentionally incorrect
      information in their communications with other agents (that is, they do
      not lie).</li>
    </ol><p>Condition 1 does not hold for physical agents in the real-world,
  such as humans, animals or robots. Rather it's a simplifying assumption that
  we may want to make in a simulation model abstracting away from the
  limitations of real-world agents. Condition 2 typically holds for robots
  (and other artifact agents), but not for humans.</p><p>In <abbr title="Agent/Object Event Modeling and Simulation">A/OEM&amp;S</abbr>,
  agents are, by default, perfect information agents with</p><ol>
      <li><p>two collection-valued properties, <i>objects</i> and
      <i>agents</i>, which represent their information state: the
      (non-agentive) objects and the agents they know;</p></li>

      <li><p>two generic &quot;event-handling&quot; operations that are invoked by the
      simulator when processing perception events or message events:</p><ol>
          <li><i>onReceive</i> for handling <em>in-message events</em> (i.e.,
          for receiving messages),</li>

          <li><i>onPerceive</i> for handling <em>perception events</em> (i.e.,
          for processing perceptions), and</li>
        </ol></li>

      <li><p>two generic operations for performing actions and sending
      messages:</p><ol>
          <li><em>perform</em> for performing an action (by scheduling an
          <i>action event</i>),</li>

          <li><i>send</i> for sending a message to one or more other agents
          (by scheduling a <i>message event</i> with one or more
          <em>receivers</em>).</li>
        </ol></li>
    </ol><p>Notice that <strong><em>actions are events</em></strong> and we
  therefore also call them <em>action events</em>. Sending a message
  corresponds to a <em>send message</em> action, which is also called an
  <em>out-message action event</em>.</p><p>These operations are depicted in
  the following diagram showing an <abbr title="Agent/Object Event Modeling and Simulation">A/OEM&amp;S</abbr>
  meta-model fragment:</p><figure><img alt="A conceptual process model in the form of a DPMN diagram" src="OEMS_files/AOES-AgtObj.svg" width="350" /></figure><p>In <abbr title="Agent/Object Event Modeling and Simulation">A/OEM&amp;S</abbr>, the
  behavior of an agent is based on in its event handling operations
  <i>onPerceive</i> and <i>onReceive</i> for reacting to perceptions and to
  incoming messages, as well as <i>perform</i> and <em>send</em> for
  performing actions and sending messages.</p><p>In a standalone
  (non-distributed) simulator for <abbr title="Agent/Object Event Modeling and Simulation">A/OEM&amp;S</abbr>, the
  most efficient way of implementing inter-agent communication is achieved by
  having the sender directly invoking a message reception method of the
  receiver (corresponding to synchronous message passing).</p><p>However, such
  an implementation (by direct method invocation) would bypass the fundamental
  <em>event scheduling</em> mechanism of OEM&amp;S, which also warrants the
  occurrence time consistency of events. Each perception event and each action
  should be scheduled as an event, i.e., added to the simulator's <em>Future
  Events List (FEL)</em>, such that it can be processed by the simulator on
  its occurrence time.</p><p>When the simulator processes a perception event
  as an objective (external) event from the FEL, it invokes the
  <i>onPerceive</i> event-handling method of the perceiver agent, which
  corresponds to a subjective (internal) perception event that is induced by
  the objective perception event.</p><p>In <abbr title="Agent/Object Event Modeling and Simulation">A/OEM&amp;S</abbr>,
  performing a <em>send message</em> action corresponds to scheduling a
  <em>message event</em> with a message, a sender and a receiver. When the
  simulator processes a message event as an objective (external) event from
  the FEL, it invokes the <i>onReceive</i> event-handling method of the
  receiver agent, which corresponds to a subjective (internal) message
  reception event that is induced by the objective message event.</p><p>There
  are two alternative architectures for simulating agents and their
  interactions with their environment and with each other:</p><ol>
      <li>An <em>interleaved architecture</em> (based on next-event time
      progression) that interleaves the processing of events and the execution
      of agent behavior.</li>

      <li>A <em>round-based architecture</em> (based on incremental time
      progression) that, in a loop, transmits to each agent all perception and
      message events that affect it, and then waits for the resulting state
      changes and action events created by each agent, before it proceeds with
      first processing the state changes and then processing the next events.
      This approach guarantees that the behavior (and state changes) of an
      agent at each simulation step is not affected by the behavior (and state
      changes) of other agents at the same simulation step, but only by their
      past behavior (and state changes).</li>
    </ol><p>The interleaved architecture, allowing the immediate processing of
  perception events and message events by the simulator, is simpler and more
  efficient..</p><section class="role-section1" id="Perception-Action"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">12.1</span>. </span>Perception and Action</h2><p>Agents may perceive objects and events in their environment and, in
  response, take certain actions, possibly causing changes in their
  environment.</p><p>One can distinguish between a passive and an active form
  of perception. Passive perception takes place asynchronously, while an agent
  is busy or idle, in the form of (instantaneous) perception events, while
  active perception requires the agent to perform a perceptive action or
  activity (like scanning the neighborhood). In general, agents are exposed to
  perception events and may react in response to them. </p><blockquote class="role-note"><p>In the case of physical agents, like robots, passive
  perception events are created by a sensor containing an event detector, such
  as a Proximity Infra-Red (PIR) sensor, which has its output pin going high
  whenever it detects an infra-red emitting object (e.g., a human or a medium
  to large sized animal) in its reach. Active perceptions are created by
  querying the measurement value of a sensor containing a quality detector,
  such as a DHT22 temperature and humidity sensor. The distinction between
  event detectors and quality detectors has been proposed in (Diaconescu and
  Wagner 2015).</p></blockquote><p>Perception events typically lead to an
  update of existing beliefs or to the creation of new beliefs.</p></section><section class="role-section1" id="Communication"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">12.2</span>. </span>Communication</h2><p>There are various forms of communication between agents. In
  particular, we can distinguish between <em>verbal</em> and
  <em>non-verbal</em> communication. We are only concerned with verbal
  communication, which is based on messages. </p><h4>Ontological
  Considerations</h4><p>Conceptually, a <em>communication event</em> is
  composed of two successive atomic events: an <em>out-message event</em>
  (corresponding to a <em>send message</em> action of the sender) and a
  correlated <em>in-message event</em> (or message reception by the receiver).
  This is illustrated by the following diagram:</p><figure><img alt="A conceptual process model in the form of a DPMN diagram" src="OEMS_files/AOES-CommunicationConcepts.svg" width="450" /></figure><p>This concept diagram expresses the following
  ontological stipulations:</p><ul>
      <li><p>A message is sent from a sender agent to one or more receiver
      agents via an <em>out-message event</em>.</p></li>

      <li><p>A message from a sender agent is received by a receiver agent via
      an <em>in-message event</em>.</p></li>

      <li><p>A <em>communication event</em> consists of a pair of correlated
      out/in message events <i>out</i> and <i>in</i>, such that the following
      conditions hold:</p><ul>
          <li><i>in</i>.<i>message</i> = <i>out</i>.<i>message</i></li>

          <li><i>in</i>.<i>receiver</i> is included in
          <i>out</i>.<i>receivers</i></li>

          <li><i>in</i>.<i>sender</i> = <i>out</i>.<i>sender</i></li>

          <li><i>in</i>.<i>occurrenceTime</i> &gt;
          <i>out</i>.<i>occurrenceTime</i></li>
        </ul></li>
    </ul><p>Communication events may lead to updates (and deletions) of
  existing beliefs or to the creation of new beliefs, especially in
  <em>information exchange</em> processes based on <em>Tell-Ask-Reply</em>
  messages.</p><h4>Message Types</h4><p>Each message is of a certain type
  defining its properties and implicit semantics. There are two kinds of
  message types: </p><ol>
      <li><strong>User-defined problem/domain-specific message types</strong>:
      the structure of such a message type is defined within a simulation
      model in the form of a class defining its properties; their semantics is
      defined in the <i>receive</i> methods of receiver agents in terms of how
      messages of such a type are processed.</li>

      <li><strong>Pre-defined problem/domain-independent message
      types</strong>: <em>Tell</em> and <em>Ask/Reply</em> are examples of
      problem/domain-independent message types that may be supported by a
      simulator. As they refer to general <em>speech acts</em>, the semantics
      of these message types should be based on the philosophical <em>speech
      act theory</em> of Austin and Searle.</li>
    </ol><figure><img alt="A conceptual process model in the form of a DPMN diagram" src="OEMS_files/AOES-MessageTypes.svg" width="550" /></figure><p>There are
  two prominent agent communication language standards: <a href="http://www.fipa.org">FIPA</a> and KQML (Finin et al 1997), both
  defining domain-independent standard message types with a semantics based on
  speech act theory. We briefly describe the rules for processing
  <em>Tell</em>, <em>Ask</em>, <em>Reply</em> and <i>Request</i>
  messages:</p><dl>
      <dt>Tell</dt>

      <dd><p>Using this message type, agents may communicate some of their
      beliefs to other agents, without being asked. In general, a teller may
      tell the truth or may lie; and in both cases the provided information
      may or may not be correct.</p><blockquote class="role-notice"><p>A
      <i>Tell</i> message is similar to what is called a <i>Signal</i> in the
      <em>Unified Modeling Language (UML)</em> where a Signal is sent
      asynchronously from an object to another object. The event rule for
      processing a Signal reception event is defined by specifying a
      <i>Reception</i> operation in the classifier of the receiver object,
      such that this operation has the same name as the type of the Signal
      (and a corresponding signature). We do not use these UML concepts (and
      the UML terminology) since they are too limited.</p></blockquote></dd>

      <dt>Ask</dt>

      <dd>Using this message type, an agent may query another agent about some
      of its beliefs. Queries are expressed in a suitable <em>query
      language</em>, such as the RDF-based query language SPARQL. An asker
      expects to receive an answer via a Reply message some time later.</dd>

      <dt>Reply</dt>

      <dd>This message type is used for replying to a previously received Ask
      message. In general, the answers provided may or may not be correct.
      Therefore, askers should only update their beliefs according to the
      received answers when they trust the replier.</dd>

      <dt>Request</dt>

      <dd>This message type is used by an agent for requesting another agent
      to perform a certain action. Such a request can be either accepted or
      rejected.</dd>
    </dl><p>Since a perfect information agent already has complete information
  about the objects it knows, </p><ul>
      <li>sending a query via an Ask message only makes sense if the query may
      retrieve objects the sender does not yet know;</li>

      <li>sending an answer via a Reply message only makes sense if the answer
      provides information about objects the receiver does not yet know;</li>

      <li>receiving a statement via a Tell message only makes sense if the
      statement provides information about an object the receiver does not yet
      know.</li>
    </ul></section><section class="role-section1" id="InterleavedAgentSimulation"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">12.3</span>. </span>Interleaved Agent Simulation</h2><p>In interleaved agent simulation, the simulator processes a
  <i>PerceptionEvent</i> by invoking the method <i>onPerceive</i> of the
  perceiver agent. An agent performs an action, e.g., in response to a
  perception, with the help of its <i>perform</i> method, which schedules a
  corresponding <i>ActionEvent</i> that is then processed by the simulator.
  </p><p>Likewise, message-based communication is implemented by having the
  sender agent invoking its <i>send</i> method, which schedules a
  <i>MessageEvent</i> that is then processed by the simulator by invoking the
  <i>onReceive</i> method of the receiver agent. In this way, a
  <i>MessageEvent</i> is inserted into the simulation log and it is guaranteed
  that, as required above, the time when a message is received is later than
  the time it has been sent (<i>in</i>.<i>occurrenceTime</i> &gt;
  <i>out</i>.<i>occurrenceTime</i>).</p><h4>Perception and Action</h4><p>For
  supporting perception events and actions, the <abbr title="Object Event Modeling and Simulation">OEM&amp;S</abbr> concept
  <em>Event</em> is extended in the following way:</p><figure><img alt="A conceptual process model in the form of a DPMN diagram" src="OEMS_files/AOES-Perception-Action.svg" width="450" /></figure><p>This
  means that</p><ol>
      <li>The pre-defined (abstract) object type <i>Agent</i> has two abstract
      methods for perception and action:<ol>
          <li><i>onPerceive</i> to be invoked with a <i>perception</i>
          argument, which is a <i>PerceptionEvent</i>,</li>

          <li><i>perform</i> to be invoked with an <i>action</i> argument,
          which is an <i><i>Action</i></i>.</li>
        </ol></li>

      <li>There are two pre-defined (abstract) event types:
      <i>PerceptionEvent</i> and <i>Action</i>.</li>

      <li>A <i>PerceptionEvent</i> has a <i>perceiver</i> reference and may
      have additional attribute values.</li>

      <li>When a <i>PerceptionEvent</i> is processed by the simulator, it
      invokes the <i>onPerceive</i> method of the <i>perceiver</i> agent and
      passes the <i>perception</i> (event). This implies that the code for
      realizing the effects of a perception event is included in the agent
      class (in its definition of the <i>onPerceive</i> method).</li>

      <li>An <i>Action</i> event has a <i>performer</i> reference and may have
      additional attribute values.</li>

      <li>When an agent performs an action by invoking the <i>perform</i>
      method, an <i>Action</i> event is scheduled, which is then processed by
      the simulator by invoking the <i>onEvent</i> method defined in the
      action event class. This implies that the code for realizing the effects
      of an action is included in the action event class (in its definition of
      the action event handler <i>onEvent</i>).</li>
    </ol><h4>Message-Based Communication</h4><p>The following diagram shows
  the new <abbr title="Agent/Object Event Modeling and Simulation">A/OEM&amp;S</abbr>
  elements added to the OEM&amp;S meta-model:</p><figure><img alt="A conceptual process model in the form of a DPMN diagram" src="OEMS_files/AOES-MessageEvent.svg" width="450" /></figure><p>This means
  that</p><ol>
      <li>The pre-defined (abstract) class <i>Agent</i> has the abstract
      method <i>onReceive</i> to be invoked with a <em>message</em> and a
      <i>sender</i> reference.</li>

      <li>There is a pre-defined event type <i>MessageEvent</i>.</li>

      <li>A <i>MessageEvent</i> has a <i>message</i> attribute value, which is
      a string or a composite value.</li>

      <li>When a <i>MessageEvent</i> occurs, the simulator invokes the
      <i>onReceive</i> method of the <i>receiver</i> agent and passes the
      <i>message</i> attribute value. This implies that the code for realizing
      the effects of an in-message event is included in the agent class (in
      its definition of the <i>onReceive</i> method).</li>
    </ol><p>In a distributed simulator for A/OEM&amp;S, where all agents of a
  simulation scenario run as different processes (on different computers)
  without a shared simulator state, and, consequently, message passing would
  be asynchronous, it would be natural to implement both out-message events
  and in-message events, as described above.</p><h4>Agent-Based Simulation
  with OESjs</h4><p>Typically, a sender agent sends a message (or schedules a
  <i>MessageEvent</i>) within its <i>onPerceive</i> or <i>onReceive</i>
  methods, that is, in response to a perception or to a message reception. In
  <a href="https://sim4edu.com/oesjs/core4/">OESjs-Core4</a>, this could be
  programmed in the following way:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">class Doctor extends <b>aGENT</b> {
  constructor({ id, name, status}) {
    super( id, name);
    this.status = status;
  }
  <b>onReceive</b>( msg, sender) {
    switch (msg.type) {
    case &quot;ASK&quot;: 
      const answer = this.processQuery( msg.query),
            reply = new rEPLY( answer),
            receiver = sender;
      this.<b>send</b>( reply, receiver));
      break;
    case &quot;REPLY&quot;:
      ... 
    }
  }
}</pre></td></tr></tbody></table><p>Often, a <i>PerceptionEvent</i> is scheduled as a consequence of an
  action event with the meaning that the action is perceived by another agent.
  A <i>PerceptionEvent</i> is processed by the simulator by invoking the
  <i>onPerceive</i> method of the <i>perceiver</i> agent while passing the
  <i>perception</i> attribute value. </p><p>An <i>Action</i> is typically
  performed by an agent within its <i>onPerceive</i> or <i>onReceive</i>
  methods in response to a perception or to a message reception. In OESjs,
  this could be programmed in the following way:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">class Doctor extends <b>aGENT</b> {
  constructor({ id, name, status}) {
    super( id, name);
    this.status = status;
  }
  <b>onPerceive</b>( perceptionEvt) {
    switch (perceptionEvt.constructor.name) {
    case &quot;CovidSymptom&quot;:
      this.<b>perform</b>( new <b>aCTION</b>(&quot;performPCR&quot;));
      break;
    }
  }
}</pre></td></tr></tbody></table></section></section><section class="role-chapter" id="BasicAgentsWithImperfectInformation-Intro"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">13</span>. </span>Basic Agents with Imperfect Information</h1><p>Basic agents with imperfect information have incomplete information
  about the objects (and agents) they know, and they may have incorrect
  information.</p></section><section class="role-chapter" id="Contracts-Intro"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">14</span>. </span>Contracts</h1><p>Contracts regulate the behavior of the contract parties in the
  scope of a business relationship. Since nation states impose contract laws
  upon their legal entities, the clauses of a contract are legally binding,
  that is, they can be legally enforced if the contract has been violated by a
  party.</p><p>Based on the work of the philosophers of law Hohfeld and Alexy,
  as summarized in the UFO-L article, we model contract clauses as defining
  </p><ol>
      <li>either <em>legal entitlements:</em> rights, permissions, powers, and
      immunities;</li>

      <li>or <em>legal burdens:</em> duties, no-rights, subjections, and
      disabilities.</li>
    </ol><p>Per Leif Wenar in Stanford Encyclopedia of Philosophy: “Rights
  are: (1) entitlements [not] to perform certain actions, or [not] to be in
  certain states; and/or (2) entitlements that others [not] perform certain
  actions or [not] be in certain states”.<br /></p><p>Legal entitlements and
  legal burdens are complementary in the sense that</p><p>Another inspiring
  work is Symboleo (see their SoSyM 2022 article &quot;Specification and Analysis
  of Legal Contracts with Symboleo&quot;).</p><p></p></section><section class="role-chapter" id="CognitiveAgents-Intro"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">15</span>. </span>Cognitive Agents</h1><p>T.B.D.</p></section></section><div class="role-backmatter" id="backmatter"><section class="role-section1" id="Bibliography"><h2 class="role-section1-title">Bibliography</h2><ul>
      <li>Aalst, Wil M. P. van der. 2021. &quot;Concurrency and Objects Matter!
      Disentangling the Fabric of Real Operational Processes to Create Digital
      Twins&quot;. In A. Cerone and P. C. ̈Olveczky (Eds.): <em>Proceedings of
      International Colloquium on Theoretical Aspects of Computing (ICTAC
      2021)</em>, LNCS 12819, pp. 3–17.</li>

      <li>Allen, G.N., and S.T. March. 2003. Modeling temporal dynamics for
      business systems. <em>Journal of Database Management</em>, 14,
      21–36.</li>

      <li>Almeida, J.P.A., R. Falbo and G. Guizzardi. 2019. Events as Entities
      in Ontology-Driven Conceptual Modeling, in <em>Proceedings of 38th
      International Conference on Conceptual Modeling</em>, ER 2019, Salvador,
      Brazil, November 4–7, 2019.</li>

      <li>Diaconescu, M. and G. Wagner. 2015. Modeling and Simulation of
      Web-of-Things Systems Part 1: Sensor Nodes. In L. Yilmaz, W. K. V. Chan,
      I. Moon, T. M. K. Roeder, C. Macal and M. D. Rossetti (Eds.),
      <em>Proceedings of the 2015 Winter Simulation Conference</em>. pp.
      3061–3072. Piscataway, New Jersey: Institute of Electrical and
      Electronics Engineers. <a href="http://www.informs-sim.org/wsc15papers/300.pdf">http://www.informs-sim.org/wsc15papers/300.pdf</a></li>

      <li>Casati, R., and A. Varzi, <a href="http://plato.stanford.edu/archives/win2015/entries/events/" rel="noopener" target="_blank">Events</a>, in: E.N. Zalta (Ed.), <em>The
      Stanford Encyclopedia of Philosophy</em>, 2015.</li>

      <li>Chen, P. 1976. The entity-relationship model – toward a unified view
      of data. <em>ACM Transactions on Database Systems</em>, 1(1):9–36.</li>

      <li>Fine, K. 2022. Acts and embodiment, <em>Metaphysics</em>, 5:1,
      14–28.</li>

      <li>Finin T., Y. Labrou and J. Mayfield. 1997. KQML as an agent
      communication language. In J. Bradshaw (Ed.), <em>Software Agents</em>,
      MIT Press, Cambridge.</li>

      <li>Gordon, G. 1961. A general purpose systems simulation program. In
      <em>AFIPS '61: Proceedings of the Eastern Joint Computer
      Conference</em>, 87–104, New York: Association for Computing
      Machinery.</li>

      <li>Griffo, C., J.P.A. Almeida, G. Guizzardi, and J.C. Nardi. 2021.
      Service contract modeling in Enterprise Architecture: An ontology-based
      approach, <em>Information Systems</em> 101.</li>

      <li id="Bibliography__GuaGui2024">Guarino, N., and G. Guizzardi. 2024. Processes as
      variable embodiments. <em>Synthese</em> vol. 203, article no. 104.
      https://doi.org/10.1007/s11229-024-04505-2</li>

      <li>Guizzardi, G., A. Botti Benevides, C. M. Fonseca, D. Porello, J. P.
      A. Almeida, and T. P. Sales. 2022. UFO: Unified Foundational Ontology,
      <em>Applied Ontology</em> 17, 1–44.</li>

      <li id="Bibliography__Loch1998">Loch C.H. 1998. <a href="http://ie.technion.ac.il/serveng/Lectures/Loch.pdf">Operations
      Management and Reengineering</a>, <em>European Management Journal</em>
      16, pp. 306–317.</li>

      <li>March, S., and G. Allen. 2009. Conceptual Modeling of Events for
      Active Information Systems. In Sugumaran, V. (Ed.). <i>Distributed
      Artificial Intelligence, Agent Technology, and Collaborative
      Applications</i>. IGI Global.
      https://doi.org/10.4018/978-1-60566-144-5</li>

      <li>Markowitz, H., B. Hausner, and H. Karr. 1962. <em>SIMSCRIPT: A
      Simulation Programming Language</em>. Englewood Cliffs, N. J.: Prentice
      Hall. Available from <a href="https://www.rand.org/content/dam/rand/pubs/research_memoranda/2009/RM3310.pdf">https://www.rand.org/content/dam/rand/pubs/research_memoranda/2009/RM3310.pdf</a></li>

      <li>McCarthy, W.E. 1979. An Entity-Relationship View of Accounting
      Models. <em>The Accounting Review</em>, Vol. LIV, No. 4.</li>

      <li><p>Pegden, C.D. and D.A. Davis. 1992. “Arena: a SIMAN/Cinema-Based
      Hierarchical Modeling System”. In <i>Proceedings of the 1992 Winter
      Simulation Conference</i>, edited by J.J. Swain, D. Goldsman, R.C.
      Crain, and J.R. Wilson, 390–399. Piscataway, New Jersey: Institute of
      Electrical and Electronics Engineers, Inc.</p></li>

      <li><span lang="en-GB">Pegden, C.D</span>. 2010. “Advanced Tutorial:
      Overview of Simulation World Views”. In <i>Proceedings of the 2010
      Winter Simulation Conference</i>, edited by B. Johansson, S. Jain, J.
      Montoya-Torres, J. Hugan, and E. Yücesan, 643−651. Piscataway, New
      Jersey: Institute of Electrical and Electronics Engineers, Inc.
      Available from <a href="http://www.informs-sim.org/wsc10papers/019.pdf">http://www.informs-sim.org/wsc10papers/019.pdf</a></li>

      <li>Petri, C. A. 1962. <em>Kommunikation mit Automaten</em>. Ph. D.
      thesis, Institut für Instrumentelle Mathematik, Bonn. English
      Translation, 1966: <em>Communication with Automata</em>, Technical
      Report RADC-TR-65-377, Rome Air Development Center, Air Force Systems
      Command, Griffiss Air Force Base, New York.</li>

      <li>Ross, R.G. 2023. <em><a href="https://www.brsolutions.com/rules-shaping-behavior-and-knowledge-book.html" rel="noopener" target="_blank">Rules: Shaping Behavior and
      Knowledge</a></em>. Business Rule Solutions, LLC.</li>

      <li>Russell, N., A. H. ter Hofstede, D. Edmond, and W. M. van der Aalst.
      2004. Workflow Resource Patterns. http://www.
      workflowpatterns.com/patterns/resource/, accessed 2022-04-15.</li>

      <li>Schruben, L.W. 1983. Simulation Modeling with Event Graphs.
      <i>Communications of the ACM</i> 26, pp. 957–963. <a href="https://dl.acm.org/citation.cfm?id=358460">https://dl.acm.org/citation.cfm?id=358460</a></li>

      <li>Tauzovich, B. 1991. Toward Temporal extensions of the
      Entity-Relationship Model. <em>Proceedings of the 10th International
      Conference on Entity Relationship Approach</em>, San Mateo, California:
      E-R Institute, pp. 136-179.</li>

      <li>Standridge, C.R. 2013. <i>Beyond Lean: Simulation in Practice</i>,
      Second Edition, Open Access book, available from <a href="https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books">https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books</a>.</li>

      <li>Vincent, P., K. Iijima, A. Leow, M. West, and O. Matvitskyy. 2022.
      Magic Quadrant for Enterprise Low-Code Application Platforms. Gartner
      Report G00759450.</li>

      <li id="Bibliography__Wag2017">Wagner, G. 2017. An Abstract State Machine Semantics
      for Discrete Event Simulation. In <i>Proceedings of the 2017 Winter
      Simulation Conference</i>. Piscataway, NJ: Institute of Electrical and
      Electronics Engineers. Available from <a href="https://www.informs-sim.org/wsc17papers/includes/files/056.pdf">https://www.informs-sim.org/wsc17papers/includes/files/056.pdf</a>.</li>

      

      <li id="Bibliography__Wag2018">Wagner, G. 2018. Information and Process Modeling for
      Simulation – Part I: Objects and Events. Journal of Simulation
      Engineering, vol. 1, 2018. <a href="https://articles.jsime.org/1/1">https://articles.jsime.org/1/1</a>.</li>

      <li id="Bibliography__Wag2022">Wagner, G. 2022. <a href="http://ceur-ws.org/Vol-3211/CR_099.pdf" rel="noopener" target="_blank">Object Event Modeling for DES and IS Engineering</a>.
      <em>Proceedings of the ER Forum 2022</em>. In: Link, S., I.
      Reinhartz-Berger, J. Zdravkovic, D. Bork and S. Srinivasa (Eds.). volume
      3211. CEUR Workshop Proceedings.</li>

      <li>Zeigler, B.P. 1976. <em>Theory of Modeling and Simulation</em>.
      Wiley, New York.</li>
    </ul></section><section class="role-index" id="_index"><h1 class="role-index-title">Index</h1></section></div></section><div class="role-footnotes"><hr class="role-footnote-separator" /><div class="role-footnote" id="__FN1"><a class="role-footnote-number" href="#__FNR1">[1]</a> See Section 10.2.2 in the BPMN 2.0 specification. This
  enumeration should be extended by adding artificial agents, such as robots,
  embedded systems and software systems.</div></div></body></html>