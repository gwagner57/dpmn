<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8" /><title>Discrete Event Simulation with DPMN, Simio and AnyLogic</title><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="DES-DPMN-OESjs-Simio-AnyLogic_files/ebook.css" rel="stylesheet" type="text/css" /><meta content="This book explains how to design discrete event simulations with the Discrete Event Process Modeling Notation (DPMN) and how to implement them with Simio and AnyLogic. DPMN is based on the Object Event Modeling and Simulation (OEM&amp;S) paradigm, representing a general Discrete Event Simulation approach based on object-oriented modeling and event scheduling." name="description" /><style>/*<![CDATA[*/
div.role-book-title-div {
  text-align: center;
}
h1.role-book-title {
  margin: 4em 0;
  padding-bottom: 0;
  border-bottom-style: none;
}
span.button {
  outline: 1px solid;
  background: aliceblue;
}
}/*]]>*/</style></head><body><section class="role-book" id="DES-DPMN-OESjs-Simio-AnyLogic"><div class="role-book-title-div"><h1 class="role-book-title">Discrete Event Simulation with DPMN, Simio and AnyLogic</h1><div class="role-content" id="DES-DPMN-OESjs-Simio-AnyLogic-content-1"><div id="DES-DPMN-OESjs-Simio-AnyLogic-content-1__subtitle">How to design simulations with DPMN and implement them with OESjs, Simio and AnyLogic</div><div id="DES-DPMN-OESjs-Simio-AnyLogic-content-1__authors">Gerd Wagner <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a></div><p>Copyright © 2021 G. Wagner</p><p>Draft version, published 2021-02-22.</p><h2>Abstract</h2><p>This book explains how to design discrete event simulations with the Discrete Event Process Modeling Notation (DPMN) and how to implement them with Simio and AnyLogic. DPMN is based on the Object Event Modeling and Simulation (OEM&amp;S) paradigm, representing a general Discrete Event Simulation approach based on object-oriented modeling and event scheduling.</p><p>This book is also available in the following formats:  </p></div></div><div class="role-frontmatter" id="frontmatter"><section class="role-toc" id="toc"><h1 class="role-toc-title">Table of Contents</h1><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-lof"><a class="role-lof-ref" href="#lof">List of Figures</a></li><li class="role-booklist-entry booklist-entry-for-lot"><a class="role-lot-ref" href="#lot">List of Tables</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#chIntroduction"><span class="role-label"><span class="role-number">1</span>. </span>Introduction to Discrete Event Simulation Engineering</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#What-is-DES"><span class="role-label"><span class="role-number">1.1</span>. </span>What Is Discrete Event Simulation?</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secMDE"><span class="role-label"><span class="role-number">1.2</span>. </span>Model-Driven Engineering</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secUML"><span class="role-label"><span class="role-number">1.3</span>. </span>Information Modeling with UML Class Diagrams</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secBPMN"><span class="role-label"><span class="role-number">1.4</span>. </span>Process Modeling with BPMN and DPMN</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secOEMS"><span class="role-label"><span class="role-number">1.5</span>. </span>Object Event Modeling and Simulation</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secProcesses"><span class="role-label"><span class="role-number">1.6</span>. </span>Discrete Event Processes, Business Processes and Processing Processes</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index"><span class="role-label"><span class="role-number">2</span>. </span>Event-Based Simulation</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#ES-without-Objects"><span class="role-label"><span class="role-number">2.1</span>. </span>Event-Based Simulation without Objects</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#OEM-Example-Workstation"><span class="role-label"><span class="role-number">2.2</span>. </span>Modeling a Manufacturing Workstation as a Queueing System</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index-2"><span class="role-label"><span class="role-number">3</span>. </span>Activity-Based Simulation</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#index-3"><span class="role-label"><span class="role-number">3.1</span>. </span>Simple Activities</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secCM"><span class="role-label"><span class="role-number">3.1.1</span>. </span>Conceptual Modeling of Simple Activities</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secDesM"><span class="role-label"><span class="role-number">3.1.2</span>. </span>Design Modeling of Simple Activities</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#index-4"><span class="role-label"><span class="role-number">3.2</span>. </span>Resource-Constrained Activities</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secCM-2"><span class="role-label"><span class="role-number">3.2.1</span>. </span>Conceptual Modeling of Resource-Constrained Activities</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secDesM-2"><span class="role-label"><span class="role-number">3.2.2</span>. </span>Resource-Constrained Activities in Simulation Design Models</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#secAllocateReleasePattern"><span class="role-label"><span class="role-number">3.2.3</span>. </span>The Allocate-Release Modeling Pattern</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index-5"><span class="role-label"><span class="role-number">4</span>. </span>Processing Activities and Processing Networks</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secPN-CM"><span class="role-label"><span class="role-number">4.1</span>. </span>Conceptual Modeling of Processing Networks</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secPN-DM"><span class="role-label"><span class="role-number">4.2</span>. </span>Processing Network Design Models</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#SimioConceptsAndTerminology"><span class="role-label"><span class="role-number">4.3</span>. </span>Simio Concepts and Terminology</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#AnyLogicConceptsAndTerminology"><span class="role-label"><span class="role-number">4.4</span>. </span>AnyLogic Concepts and Terminology</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#index-6"><span class="role-label"><span class="role-number">5</span>. </span>Case Studies</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Make-and-Deliver-Pizza"><span class="role-label"><span class="role-number">5.1</span>. </span>Make and Deliver Pizza</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#Make-and-Deliver-Pizza-OESjs"><span class="role-label"><span class="role-number">5.1.1</span>. </span>Implementation with OESjs</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ImplementationWithAnyLogic"><span class="role-label"><span class="role-number">5.1.2</span>. </span>Implementation with AnyLogic</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ImplementationWithSimio"><span class="role-label"><span class="role-number">5.1.3</span>. </span>Implementation with Simio</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Load-Haul-Dump"><span class="role-label"><span class="role-number">5.2</span>. </span>The Load-Haul-Dump Model</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#Load-Haul-Dump-OESjs"><span class="role-label"><span class="role-number">5.2.1</span>. </span>Implementation with OESjs</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ImplementationWithAnyLogic-2"><span class="role-label"><span class="role-number">5.2.2</span>. </span>Implementation with AnyLogic</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ImplementationWithSimio-2"><span class="role-label"><span class="role-number">5.2.3</span>. </span>Implementation with Simio</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#index-7"><span class="role-label"><span class="role-number">5.3</span>. </span>Diagnostic Clinic</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ImplementationWithSimio-3"><span class="role-label"><span class="role-number">5.3.1</span>. </span>Implementation with Simio</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#ImplementationWithAnyLogic-3"><span class="role-label"><span class="role-number">5.3.2</span>. </span>Implementation with AnyLogic</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Bibliography">Bibliography</a></li><li class="role-booklist-entry booklist-entry-for-index"><a class="role-index-ref" href="#_index">Index</a></li></ul></section><section class="role-lof" id="lof"><h1 class="role-lof-title">List of Figures</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-figure-ref" href="#secMDE__figMDD"><span class="role-label"><span class="role-number">1-1</span>. </span>From conceptualization via design to implementation</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secUML__figShopDelivery"><span class="role-label"><span class="role-number">1-2</span>. </span>The entity types Shop and Delivery.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secUML__figShopDelivery2"><span class="role-label"><span class="role-number">1-3</span>. </span>Adding properties and operations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secUML__figShopDelivery3"><span class="role-label"><span class="role-number">1-4</span>. </span>Adding a property constraint and an operation constraint.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secUML__figShopDelivery4"><span class="role-label"><span class="role-number">1-5</span>. </span>Object and event types as two different categories of entity types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secBPMN__figCPM_BPMN"><span class="role-label"><span class="role-number">1-6</span>. </span>A BPMN Process Diagram for a pizza service company</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secBPMN__figCPM_DPMN"><span class="role-label"><span class="role-number">1-7</span>. </span>A DPMN Process Diagram for a pizza service company</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secProcesses__lof__8"><span class="role-label"><span class="role-number">1-8</span>. </span>A process design model in the form of a basic DPMN Process Diagram</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secProcesses__lof__9"><span class="role-label"><span class="role-number">1-9</span>. </span>An information design model in the form of a basic OE class model</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secProcesses__figPDMwithoutRDASAs"><span class="role-label"><span class="role-number">1-10</span>. </span>A DPMN-A process model and its underlying OE class model</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secProcesses__figPDMwithRDASA"><span class="role-label"><span class="role-number">1-11</span>. </span>A DPMN-A process model with a resource-dependent activity start arrow and its underlying OE class model</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secProcesses__lof__12"><span class="role-label"><span class="role-number">1-12</span>. </span>A DPMN-A process model of a Load-Haul-Dump business process</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#OEM-Example-Workstation__figWS_CIM"><span class="role-label"><span class="role-number">2-1</span>. </span>A conceptual information model of a manufacturing workstation system</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#OEM-Example-Workstation__figWS_CPM"><span class="role-label"><span class="role-number">2-2</span>. </span>A conceptual process model of a manufacturing workstation system</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#OEM-Example-Workstation__figWS2_IDM"><span class="role-label"><span class="role-number">2-3</span>. </span>An information design model</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#OEM-Example-Workstation__figWS2_PDM"><span class="role-label"><span class="role-number">2-4</span>. </span>A process design model in the form of a DPMN Process Diagram</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM__figWorkstationCIM"><span class="role-label"><span class="role-number">3-1</span>. </span>Introducing an activity type in a conceptual information model of a single workstation system.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM__figWorkstationCPM"><span class="role-label"><span class="role-number">3-2</span>. </span>Introducing an activity type in a conceptual process model of a single workstation system.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label"><span class="role-number">3-3</span>. </span>Going from basic OEM to OEM-A class models by introducing activity types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label"><span class="role-number">3-4</span>. </span>Going from basic DPMN to DPMN-A process models by introducing Activity rectangles.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM__figWS3PDM2"><span class="role-label"><span class="role-number">3-5</span>. </span>Allocating the workstation as a resource of Processing activities</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#index-4__figActRes"><span class="role-label"><span class="role-number">3-6</span>. </span>The resources required for performing an activity include the activity's performer.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#index-4__figIndividualsAndTypes"><span class="role-label"><span class="role-number">3-7</span>. </span>Activity types may have special properties representing resource roles.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label"><span class="role-number">3-8</span>. </span>A conceptual information model of the activity type &quot;examinations&quot; with resource roles.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label"><span class="role-number">3-9</span>. </span>A conceptual process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label"><span class="role-number">3-10</span>. </span>A conceptual information model with doctors and patients as people.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label"><span class="role-number">3-11</span>. </span>Adding the activity type &quot;walks to room&quot; to the conceptual information model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM2"><span class="role-label"><span class="role-number">3-12</span>. </span>A conceptual process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM3"><span class="role-label"><span class="role-number">3-13</span>. </span>An improved process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label"><span class="role-number">3-14</span>. </span>Displaying the process owner and activity performers in a conceptual process model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secCM-2__figExclusiveResByType"><span class="role-label"><span class="role-number">3-15</span>. </span>Adding parallel participation multiplicities for rooms participating both in walks and examinations at the same time.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label"><span class="role-number">3-16</span>. </span>An information model for the simplified design with the resource counters nmrOfRooms and nmrOfDoctors.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1PDM1"><span class="role-label"><span class="role-number">3-17</span>. </span>A process design model based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">3-16</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label"><span class="role-number">3-18</span>. </span>An OEM-A class model with resource object types for modeling resource roles and pools.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1PDM2"><span class="role-label"><span class="role-number">3-19</span>. </span>A process design model based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__lof__36"><span class="role-label"><span class="role-number">3-20</span>. </span>Any resource type <i>R</i> extends the pre-defined object type <code>Resource</code></a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM3"><span class="role-label"><span class="role-number">3-21</span>. </span>A simplified version of the model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a> </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figWS3IDM3"><span class="role-label"><span class="role-number">3-22</span>. </span>An OE Class Diagram modeling a single workstation system with resource-constrained processing activities </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label"><span class="role-number">3-23</span>. </span>An information design model for decoupling the allocation of rooms and doctors.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep2PDM1"><span class="role-label"><span class="role-number">3-24</span>. </span>A process design model based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label">Figure <span class="role-number">3-23</span></span></a>.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label"><span class="role-number">3-25</span>. </span>Representing the process owner as a Pool and activity performers as Lanes in a process design model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label"><span class="role-number">3-26</span>. </span>A conceptual modeling pattern for a sequence of resource-constrained activities</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label"><span class="role-number">3-27</span>. </span>Using <em>resource-dependent activity start</em> arrows in a conceptual process model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label"><span class="role-number">3-28</span>. </span>Displaying the implicit allocate-release steps.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figWS3IDM3"><span class="role-label"><span class="role-number">3-29</span>. </span>Modeling WorkStation as a resource type</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figWS3PDM3"><span class="role-label"><span class="role-number">3-30</span>. </span>A simplified version of the workstation process model using a resource-dependent activity start arrow.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2IdmRewrite"><span class="role-label"><span class="role-number">3-31</span>. </span>A simplified version of the medical department information model with Doctor and Room as resource types</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2PdmRewrite"><span class="role-label"><span class="role-number">3-32</span>. </span>A simplified version of the medical department process model using resource-dependent activity start arrows.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#index-5__figProcObjects"><span class="role-label"><span class="role-number">4-1</span>. </span>Resource-constrained activities involving processing objects are processing activities.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-CM__figPredefinedTypes4PN_CM"><span class="role-label"><span class="role-number">4-2</span>. </span>A conceptual OEM class model defining built-in types for conceptual PN modeling</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-CM__figDmvCPM"><span class="role-label"><span class="role-number">4-3</span>. </span>A PN model using the new DPMN modeling elements of PN Node rectangles and PN Flow arrows</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-CM__figDMVCPM2"><span class="role-label"><span class="role-number">4-4</span>. </span>A DPMN-PN process diagram with an Event Scheduling arrow </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figPredefinedTypes4PN"><span class="role-label"><span class="role-number">4-5</span>. </span>An OEM class design model defining built-in types for making PN design models</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figWS3PDM-PN"><span class="role-label"><span class="role-number">4-6</span>. </span>A PN model of a workstation system using PN Node rectangles and PN Flow arrows</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figWS4PDM-PN"><span class="role-label"><span class="role-number">4-7</span>. </span>A PN model of a workstation system where parts may have to be reworked </a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secPN-DM__figDmvPDM"><span class="role-label"><span class="role-number">4-8</span>. </span>A PN model using the new DPMN modeling elements of PN Node rectangles and PN Flow arrows</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza__lof__57"><span class="role-label"><span class="role-number">5-1</span>. </span>An information design model defining object, event and activity types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza__lof__58"><span class="role-label"><span class="role-number">5-2</span>. </span>A computationally complete process design for the Make-and-Deliver-Pizza business process.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza-OESjs__lof__59"><span class="role-label"><span class="role-number">5-3</span>. </span>A design model for the <code>HaulRequest</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza-OESjs__lof__60"><span class="role-label"><span class="role-number">5-4</span>. </span>A design model for the <code>GoToLoadingSite</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza-OESjs__lof__61"><span class="role-label"><span class="role-number">5-5</span>. </span>A design model for the <code>Load</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza-OESjs__lof__62"><span class="role-label"><span class="role-number">5-6</span>. </span>A design model for the <code>Haul</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza-OESjs__lof__63"><span class="role-label"><span class="role-number">5-7</span>. </span>A design model for the <code>Dump</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Make-and-Deliver-Pizza-OESjs__lof__64"><span class="role-label"><span class="role-number">5-8</span>. </span>A design model for the <code>GoBackToLoadingSite</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ImplementationWithAnyLogic__lof__65"><span class="role-label"><span class="role-number">5-9</span>. </span>A DPMN process design model for the Load-Haul-Dump business process.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ImplementationWithAnyLogic__lof__66"><span class="role-label"><span class="role-number">5-10</span>. </span>An AnyLogic process diagram for the Load-Haul-Dump business process.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump__lof__67"><span class="role-label"><span class="role-number">5-11</span>. </span>A conceptual <abbr title="Object Event">OE</abbr> class model describing object, event and activity types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump__lof__68"><span class="role-label"><span class="role-number">5-12</span>. </span>A refined conceptual process model.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump__lof__69"><span class="role-label"><span class="role-number">5-13</span>. </span>An information design model defining object, event and activity types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump__lof__70"><span class="role-label"><span class="role-number">5-14</span>. </span>A computationally complete process design for the Load-Haul-Dump business process.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump-OESjs__lof__71"><span class="role-label"><span class="role-number">5-15</span>. </span>A design model for the <code>HaulRequest</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump-OESjs__lof__72"><span class="role-label"><span class="role-number">5-16</span>. </span>A design model for the <code>GoToLoadingSite</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump-OESjs__lof__73"><span class="role-label"><span class="role-number">5-17</span>. </span>A design model for the <code>Load</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump-OESjs__lof__74"><span class="role-label"><span class="role-number">5-18</span>. </span>A design model for the <code>Haul</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump-OESjs__lof__75"><span class="role-label"><span class="role-number">5-19</span>. </span>A design model for the <code>Dump</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#Load-Haul-Dump-OESjs__lof__76"><span class="role-label"><span class="role-number">5-20</span>. </span>A design model for the <code>GoBackToLoadingSite</code> event rule.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ImplementationWithAnyLogic-2__lof__77"><span class="role-label"><span class="role-number">5-21</span>. </span>A DPMN process design model for the Load-Haul-Dump business process.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#ImplementationWithAnyLogic-2__lof__78"><span class="role-label"><span class="role-number">5-22</span>. </span>An AnyLogic process diagram for the Load-Haul-Dump business process.</a></li></ul></section><section class="role-lot" id="lot"><h1 class="role-lot-title">List of Tables</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-table-ref" href="#secProcesses__tblDiscrEvtProcessLog"><span class="role-label"><span class="role-number">1-1</span>. </span>An example of a discrete event process log</a></li><li class="role-booklist-entry"><a class="role-table-ref" href="#secProcesses__lot__2"><span class="role-label"><span class="role-number">1-2</span>. </span>An example of a business process log</a></li><li class="role-booklist-entry"><a class="role-table-ref" href="#ES-without-Objects__tblEventRulesArrDep"><span class="role-label"><span class="role-number">2-1</span>. </span>Expressing event routines as pure functions that compute state changes and follow-up events.</a></li></ul></section></div><section class="role-chapter" id="chIntroduction"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction to Discrete Event Simulation Engineering</h1><p>The <i>Event Graph (EG)</i> diagrams of Schruben (1983) allow defining computationally complete process design models for event-based simulation, which can be viewed as the most fundamental <i>Discrete Event Simulation (DES)</i> paradigm. In these diagrams, circles represent event types, and arrows between two event type circles <i>A</i> and <i>B</i> represent <i>event scheduling</i> with a <i>future events list</i> in the sense that an occurrence of an event of type <i>A</i> in a simulation run causes the simulator to schedule a future event of type <i>B</i>. </p><section class="role-section1" id="What-is-DES"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.1</span>. </span>What Is Discrete Event Simulation?</h2><p>The term <em>Discrete Event Simulation (DES)</em> has been established as an umbrella term subsuming various kinds of computer simulation approaches, all based on the general idea of modeling entities/objects and events. In the DES literature, it is often stated that DES is based on the concept of <q>entities flowing through the system</q> (more precisely, through a <q>queueing network</q>). This is the paradigm of an entire class of simulation software in the tradition of GPSS (<a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#Gordon61">Gordon, 1961</a>) and SIMAN/Arena (<a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#Peg92">Pegden &amp; Davis, 1992</a>). However, this paradigm characterizes a special (yet important) class of DES only, it does not apply to all discrete event systems.</p><p><a href="http://www.informs-sim.org/wsc10papers/019.pdf">Pegden (2010)</a> explains that the 50 year history of DES has been shaped by three fundamental paradigms: <a href="https://www.rand.org/content/dam/rand/pubs/research_memoranda/2009/RM3310.pdf">Markowitz, Hausner and Karr (1962)</a> pioneered the <i>event worldview</i> with <i lang="en-GB">SIMSCRIPT</i>, <a href="https://dl.acm.org/doi/10.1145/1460764.1460768">Gordon (1961)</a> pioneered the <i>Processing Network worldview</i> with <i>GPSS</i>, and <a href="http://simula67.at.ifi.uio.no/Archive/artikkel1966cacm.pdf">Dahl and Nygaard (1967)</a> pioneered the <i>object worldview</i> with <i>Simula</i>. Notice that we have changed Pegden’s original name “process worldview” to “Processing Network worldview” because this paradigm is not based on a general concept of processes, but rather on a special concept of <i>processing processes</i> where entities are subject to processing steps performed at the nodes of a (queueing) network.</p><p>While the concept of an event is often limited to instantaneous events in the area of DES, the general concept of an event, as discussed in philosophy and in many fields of computer science, includes composite events and events with non-zero duration.</p><p>A <em>discrete event system</em> (or <em>discrete dynamic system</em>) consists of</p><ul><li>objects (of various types) having a state (consisting of qualities) and dispositions,</li><li>events (of various types) triggering certain dispositions of objects participating in them,</li></ul><p>such that the states of affected objects may be changed by events according to the dispositions triggered by them. It is natural to consider the concept of <em>discrete events</em>, occurring at times from a discrete set of time points.</p><p>For modeling a discrete event system as a state transition system, we have to describe its</p><ol><li><b> <i>object types</i> </b>, e.g., in the form of <em>classes</em> of an object-oriented language;</li><li><b> <i>event types</i> </b>, e.g., in the form of <em>classes</em> of an object-oriented language;</li><li><b> <i>causal regularities</i> </b> (<em>disposition types</em>) e.g., in the form of <em>event rules</em>.</li></ol><p>Any DES formalism has one or more language elements that allow specifying <em>event rules</em> representing causal regularities. These rules specify, for any event type, the <em>state changes</em> of objects and the <em>follow-up events</em> caused by the occurrence of an event of that type, thus defining the dynamics of the transition system. Unfortunately, this is often obscured by the standard definitions of DES that are repeatedly presented in simulation textbooks and tutorials.</p><p>According to Pegden (<a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#Peg10">2010</a>), a <em>simulation modeling worldview</em> provides <q>a framework for defining a system in sufficient detail that it can be executed to simulate the behavior of the system</q>. It <q>must precisely define the dynamic state transitions that occur over time</q>. Pegden explains that the 50 year history of DES has been shaped by three fundamental paradigms: Markowitz, Hausner, and Karr (<a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#MarkHK62">1962</a>) pioneered the <em>event worldview</em> with <em>SIMSCRIPT</em>, Gordon (<a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#Gordon61">1961</a>) pioneered the <em>processing network worldview</em> with <em>GPSS</em>, and Dahl and Nygaard (<a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#DahlNygaard66">1966</a>) pioneered the <em>object worldview</em> with <em>Simula</em>. Pegden characterizes these paradigms in the following way:</p><p><b><i>Event worldview</i></b>: The system is viewed as a series of instantaneous events that change the state of the system over time. The modeler defines the events in the system and models the state changes that take place when those events occur. According to Pegden, the event worldview is the most fundamental worldview since the other worldviews also use events, at least implicitly.</p><p><b><i>Processing Network worldview</i></b>: The system under investigation is described as a processing network where <q>entities flow through the system</q> (or, more precisely, work objects are routed through the network) and are subject to a series of processing steps performed at processing nodes through processing activities, possibly requiring resources and inducing queues of work objects waiting for the availability of resources (processing networks have been called <q>queueing networks</q> in Operations Research). This approach allows high-level modeling with semi-visual languages and is therefore the most widely used DES approach nowadays, in particular in manufacturing industries and service industries. Simulation platforms based on this worldview may or may not support object-oriented modeling and programming.</p><p><b><i>Object worldview</i></b>: The system is modeled by describing the objects that make up the system. The system behavior emerges from the <q>interaction</q> of these objects.</p><p>All three worldviews lack important conceptual elements. The event worldview does not consider objects with their (categorical and dispositional) properties. The processing network worldview neither considers events nor objects. And the object worldview, while it considers objects with their <em>categorical</em> properties, does not consider events. None of the three worldviews includes modeling the <em>dispositional</em> properties of objects with a full-fledged explicit concept of <em>event rules</em>.</p><p>The event worldview and the object worldview can be combined in approaches that support both objects and events as first-class citizens. This seems highly desirable because (1) objects (and classes) are a must-have in today’s state-of-the-art modeling and programming, and (2) a general concept of events is fundamental in DES, as demonstrated by the classical event worldview. We use the term <em>object-event worldview</em> for any DES approach combining OO modeling and programming with a general concept of events.</p></section><section class="role-section1" id="secMDE"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.2</span>. </span>Model-Driven Engineering</h2><p><em>Model-Driven Engineering (MDE)</em>, also called <i>model-driven development</i>, is a well-established paradigm in software engineering. Since simulation engineering can be viewed as a special case of software engineering, it is natural to apply the ideas of MDE also to simulation engineering.</p><p>In MDE, there is a distinction between three kinds of models as engineering artifacts created in the analysis, design and implementation phases of a development project:</p><ol><li><i>domain models</i> (also called <i>conceptual models</i>), which describe a real-world domain (and are independent of a computational solution),</li><li><i>design models</i>, which define platform-independent solution designs,</li><li><i>implementation models</i>, which are platform-specific.</li></ol><p>Domain models are solution-independent descriptions of a problem domain produced in the analysis phase. A domain model may include both descriptions of the domain's state structure (in conceptual <i>information models</i>) and descriptions of its processes (in conceptual <i>process models</i>). They are solution-independent, or computation-independent, in the sense that they are not concerned with making any system design choices or with other computational issues. Rather, they focus on the perspective and language of the subject matter experts for the domain under consideration.</p><p>In the design phase, first a platform-independent design model, as a general computational solution, is developed on the basis of the domain model. The same domain model can potentially be used to produce a number of (even radically) different design models. Then, by taking into consideration a number of implementation issues ranging from architectural styles, nonfunctional quality criteria to be maximized (e.g., performance, adaptability) and target technology platforms, one or more platform-specific implementation models are derived from the design model. These one-to-many relationships between conceptual models, design models and implementation models are illustrated in <a class="role-figure-ref" href="#secMDE__figMDD"><span class="role-label">Figure <span class="role-number">1-1</span></span></a>.</p><figure id="secMDE__figMDD"><figcaption><span class="role-label">Figure <span class="role-number">1-1</span>. </span>From conceptualization via design to implementation</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MDD.svg" width="500" /></div></figure><p>In general, a model does not consist of just one model diagram including all viewpoints or aspects of the system to be developed. Rather it consists of a set of models, one (or more) for each viewpoint. The two most important viewpoints, crosscutting all three modeling levels (domain conceptualization, design and implementation) are</p><ol><li><b><i>information modeling</i></b>, which is concerned with the <b><i>state structure</i> </b>of the domain, design or implementation;</li><li><b><i>process modeling</i></b>, which is concerned with the <b><i>dynamics</i> </b>of the domain, design or implementation.</li></ol><p>Examples of widely used languages for information modeling are <em>Entity Relationship (ER) Diagrams</em> and <em>UML Class Diagrams</em>. Since the latter subsume the former, we prefer using UML class diagrams for making all kinds of information models, including SQL database models.</p><p>Examples of widely used languages for process modeling are <em>(Colored) Petri Nets</em>, <em>UML Sequence Diagrams,</em> <em>UML Activity Diagrams</em> and the <em>BPMN</em>. Notice that there is more agreement on the right concepts for information modeling than for process modeling, as indicated by the much larger number of different process modeling languages. This reflects a lower degree of understanding the nature of events and processes compared to understanding objects and their relationships.</p><p>Model-driven simulation engineering is based on the same kinds of models as model-driven software engineering: going from a <em>domain model</em> via a<em>design model</em> to an <em>implementation model</em> for the simulation platform of choice (or to several implementation models if there are several target simulation platforms). The specific concerns of simulation engineering, like, e.g., the concern to capture certain parts of the overall system dynamics with the help of random variables, do not affect the applicability of MDE principles. However, they define requirements for the modeling languages to be used.</p></section><section class="role-section1" id="secUML"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.3</span>. </span>Information Modeling with UML Class Diagrams</h2><p>Conceptual information modeling is mainly concerned with describing the relevant <b><i>entity types</i></b> of a real-world domain and the relationships between them, while information design and implementation modeling are concerned with describing the <i>logical</i> (or <i>platform-independent</i>) and <i>platform-specific</i> data structures (in the form of <b><i>classes</i></b>) for designing and implementing a software system or simulation. The most important kinds of relationships between entity types to be described in an information model are <b><i>associations</i></b> and <b><i>subtype</i></b>/<i>supertype</i> relationships, which are called ‘generalizations’ in <i>UML</i>.</p><p>In UML Class Diagrams, an entity type is described with a name, and possibly with a list of <b><i>properties</i></b> and <b><i>operations</i></b> (called <i>methods</i> when implemented), in the form of a <i>class rectangle</i> with one, two or three compartments, depending on the presence of properties and operations. <b><i>Integrity constraints</i></b>, which are conditions that must be satisfied by the instances of a type, can be expressed in special ways when defining properties or they can be explicitly attached to an entity type in the form of an <i>invariant</i> box.</p><p>An <b><i>association</i></b> between two entity types is expressed as a connection line between the two class rectangles representing the entity types. The connection line is annotated with <i>multiplicity</i> expressions at both ends. A <b><i>multiplicity</i></b> expression has the form <code>m..n</code> where <i>m</i> is a non-negative natural number denoting the <i>minimum cardinality</i>, and <i>n</i> is a positive natural number (or the special symbol * standing for <i>unbounded)</i> denoting the maximum cardinality, of the sets of associated entities. Typically, a multiplicity expression states an integrity constraint. For instance, the multiplicity expression <code>1..3</code> means that there are at least 1 and at most 3 associated entities. However, the special multiplicity expression <code>0..*</code> (also expressed as <code>*</code>) means that there is no constraint since the minimum cardinality is zero and the maximum cardinality is unbounded.</p><p>For instance, the model shown in <a href="#secUML__figShopDelivery">Figure 3</a> describes the entity types <code>Shop</code> and <code>Delivery</code>, and it states that</p><ol><li>there are two classes: <code>Shop</code> and <code>Delivery</code>, representing entity types;</li><li>there is a one-to-many association between the classes <code>Shop</code> and <code>Delivery</code>, where a shop is the <code>receiver</code> of a delivery.</li></ol><figure id="secUML__figShopDelivery"><figcaption><span class="role-label">Figure <span class="role-number">1-2</span>. </span>The entity types Shop and Delivery.</figcaption><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/IntroUML1.svg" width="400" /></figure><p>Using further compartments in class rectangles, we can add properties and operations. For instance, in the model shown in <a href="#secUML__figShopDelivery2">Figure 4</a>, we have added</p><ol><li>the properties <em>name</em> and <em>stockQuantity</em> to <code>Shop</code> and <em>quantity</em> to <code>Delivery</code>,</li><li>the instance-level operation <em>onEvent</em> to <code>Delivery</code>,</li><li>the class-level operation <em>leadTime</em> to <code>Delivery</code>.</li></ol><figure id="secUML__figShopDelivery2"><figcaption><span class="role-label">Figure <span class="role-number">1-3</span>. </span>Adding properties and operations.</figcaption><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/IntroUML2.svg" width="450" /></figure><p>Notice that in <a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#_Ref493071591">Figure 4</a>, each property is declared together with a datatype as its <em>range</em>. Likewise, operations are declared with a (possibly empty) list of parameters, and with an optional return value type. When an operation (or property) declaration is underlined, this means that it is class-level instead of instance-level. For instance, the underlined operation declaration <u><code>leadTime(): Decimal</code></u> indicates that <em>leadTime</em> is a class-level operation that does not take any argument and returns a decimal number.</p><p>We may want to define various types of integrity constraints for better capturing the semantics of entity types, properties and operations. The model shown in <a href="#secUML__figShopDelivery3">Figure 5</a> contains an example of a property constraint and an example of an operation constraint. These types of constraints can be expressed within curly braces appended to a property or operation declaration. The keyword <code>id</code> in the declaration of the property <code>name</code> in the <code>Shop</code> class expresses an ID constraint stating that the property is a standard identifier, or primary key, attribute. The expression <code>Exp(0.5)</code> in the declaration of the random variable operation <code>leadTime</code> in the <code>Delivery</code> class denotes the constraint that the operation must implement the <em>exponential</em> probability distribution function with event rate 0.5.</p><figure id="secUML__figShopDelivery3"><figcaption><span class="role-label">Figure <span class="role-number">1-4</span>. </span>Adding a property constraint and an operation constraint.</figcaption><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/IntroUML3.svg" width="500" /></figure><p>UML allows defining special categories of modeling elements called <q>stereotypes</q>. For instance, for distinguishing between <b><i>object types</i></b> and <b><i>event types</i></b> as two different categories of entity types we can define corresponding stereotypes of UML classes («object type» and «event type») and use them for categorizing classes in class models, as shown in <a href="#secUML__figShopDelivery4">Figure 6</a>.</p><figure id="secUML__figShopDelivery4"><figcaption><span class="role-label">Figure <span class="role-number">1-5</span>. </span>Object and event types as two different categories of entity types.</figcaption><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/IntroUML4.svg" width="500" /></figure><p>Another example of using UML’s stereotype feature is the designation of an operation as a function that represents a <em>random variable</em> using the operation stereotype «rv» in the diagram of <a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#_Ref493015782">Figure 6</a>.</p><p>A class may be defined as <em>abstract</em> by writing its name in italics, as in the example model of <a href="file:/D:/Repos/JSimE-Articles/1/1/index.html#_Ref493094582">Figure 11</a>. An abstract class cannot have direct instances. It can only be indirectly instantiated by objects that are direct instances of a subclass.</p><p>A good overview of the most recent version of UML (UML 2.5) is provided by <a href="https://www.uml-diagrams.org/uml-25-diagrams.html">www.uml-diagrams.org/uml-25-diagrams.html</a>.</p></section><section class="role-section1" id="secBPMN"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.4</span>. </span>Process Modeling with BPMN and DPMN</h2><p>The <em>Business Process Modeling Notation (BPMN)</em> is an activity-based graphical modeling language for defining business processes following the flow-chart metaphor. In 2011, the Object Management Group has released version 2.0 of BPMN with an optional execution semantics based on Petri-Net-style token flows.</p><p>The most important elements of a BPMN process model are listed in <a href="#secBPMN__tblBPMN"></a>.</p><table border="1" id="secBPMN__tblBPMN"><tbody><tr><th>Name of element</th><th>Meaning</th><th>Visual symbol(s)</th></tr><tr><td><p>Event</p></td><td><p><q>Something that 'happens' during the course of a process</q>, affecting the process flow. <q>There are three types of Events, based on when they affect the flow</q>: a <em>Start Event</em> is drawn as a circle with a thin border line, while an <em>Intermediate Event</em> has a double border line and an <em>End Event</em> has a thick border line.</p></td><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/Events.svg" /></td></tr><tr><td><p>Activity</p></td><td><p><q>Work that is performed within a Business Process</q>. A <em>Task</em> is an atomic Activity, while a <em>Sub-Process</em> is a <em>composite</em> Activity. A Sub-Process can be either in a <em>collapsed</em> or in an <em>expanded</em> view.</p></td><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/Activity.svg" /></td></tr><tr><td><p>Gateway</p></td><td><p>A Gateway is a node for branching or merging control flows. A Gateway with an &quot;X&quot; symbol denotes an Exclusive OR-Split for conditional branching, if there are 2 or more output flows, or an Exclusive OR-Join, if there are 2 or more input flows. A Gateway with a plus symbol denotes an AND-Split for parallel branching, if there are 2 or more output flows, or an AND-Join, if there are 2 or more input flows. A Gateway can have both input and output flows. </p></td><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/Gateways.svg" /></td></tr><tr><td><p>Sequence Flow</p></td><td><p>An arrow expressing the temporal order of Events, Activities, and Gateways. A <em>Conditional Sequence Flow</em> arrow starts with a diamond and is annotated with a condition (in brackets).</p></td><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/image11.png" /> <img src="DES-DPMN-OESjs-Simio-AnyLogic_files/ConditionalSequenceFlow.svg" /></td></tr><tr><td><p>Data Object</p></td><td><p>Data Objects may be associated with Events or Activities, providing a context for reading/writing data. A unidirectional dashed arrow denotes reading, while a bidirectional dashed arrow denotes reading/writing.</p></td><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/DataObject.svg" /></td></tr></tbody></table><p>A good modeling tool, with the advantages of an online solution, is the <i>Signavio Process Editor</i>, which is free for academic use (<a href="http://www.signavio.com/bpm-academic-initiative">www.signavio.com/bpm-academic-initiative</a>).</p><p>BPMN process diagrams can be used for making</p><ol><li><b><i>conceptual process models</i> </b>, e.g., for documenting existing business processes and for designing new business processes;</li><li><b><i>process automation models</i> </b>for specific process automation platforms (that allow partially or fully automating a business process) by adding platform-specific technical details in the form of model annotations that are not visible in the diagram.</li></ol><p>The following diagram shows an example of a BPMN process model.</p><figure id="secBPMN__figCPM_BPMN"><figcaption><span class="role-label">Figure <span class="role-number">1-6</span>. </span>A BPMN Process Diagram for a pizza service company</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_CPM_BPMN.svg" width="600" /></div></figure><p>However, the BPMN process diagram language has several semantic issues and is not expressive enough for making platform-independent <i>process design models</i> that can be used for designing DES models.</p><h4>Shortcomings of BPMN</h4><p>Notice the BPMN <em>Boundary Timeout Event</em> circle attached to the <em>take order</em> activity in <a class="role-figure-ref" href="#secBPMN__figCPM_BPMN"><span class="role-label">Figure <span class="role-number">1-6</span></span></a> representing timeout events that cancel the activity. They are supposed to model the <em>reneging</em> behavior of waiting customers loosing their patience and hanging up the phone without placing an order. However, BPMN does not allow restricting such a timeout mechanism to the waiting phase of a task (planned activity), that is the time span during which the task has been enqueued, but not yet started. Rather, it applies to the entire cycle time of <em>take order</em> activities, which means that also started activities, where the order taker is already listening to the customer, may be canceled due to reneging.</p><p>While BPMN allows modeling the performers of activities with swimlanes (referring to organizational positions with corresponding resource pools), it does not support modeling other types of resource objects, such as machines or rooms. As a workaround, the model above includes two BPMN <em>Data Objects</em>, <em>ovens</em> and <em>scooters</em>, for representing resource objects. Also, BPMN does not allow specifying resource cardinality constraints (e.g., for stating that making a pizza requires two pizza makers and one oven).</p><p>The third, and most severe, issue of the BPMN model is its uniform (semantically overloaded) use of &quot;sequence flow&quot; arrows for sequencing both events and activities. While in the case of all three activities, incoming &quot;sequence flow&quot; arrows do not mean that an activity is started, but rather that a new task is enqueued (and only started when all required resources become available), in the case of the <em>lost order</em> event, the incoming &quot;sequence flow&quot; arrow means that a new event is scheduled to occur immediately.</p><p>BPMN has the following issues:</p><ol><li>A <strong>limited</strong> concept of &quot;business processes&quot; as isolated &quot;cases&quot;, which does not allow to account for any dependency between business processes (e.g., competing for resources).</li><li>Overloading/<strong>ambiguity</strong> of <em>sequence flow arrows</em>, which represent various kinds of connections, including resource-independent event flows and resource-dependent activity scheduling.</li><li><strong>Insufficient</strong> integration of the <i><strong>objects</strong></i> that participate in a process.</li><li><strong>Insufficient</strong> support of <i><strong>resource management</strong></i>. In particular, no other resources except (human) performers can be modeled, and the important concepts of resource cardinality constraints, resource pools, alternative resource types and resource allocation priorities are not supported.</li><li><strong>No</strong> support of <i><strong>processing activities</strong></i> and <em>processing networks</em>, which are generalized queueing networks where processing objects enter a system via arrival events and then &quot;flow through the system&quot;.</li><li><strong>No</strong> convincing <i><strong>formal semantics</strong></i>. BPMN's execution semantics is defined in terms of an abstract Petri-Net-style &quot;token&quot; flow (following the predominant academic paradigm), which does not match its intuitive semantics based on event flows and resource-dependent activity scheduling.</li></ol><h4>DPMN solves the issues of BPMN</h4>The <em>Discrete Event Process Modeling Notation (DPMN)</em> is a Discrete Event Simulation modeling language based on <em>Event Graphs</em> (<a href="https://dl.acm.org/citation.cfm?id=358460">Schruben 1983</a>) and BPMN. It combines the intuitive flowchart modeling style of BPMN with the rigorous semantics provided by the event scheduling arrows of Event Graphs and the event rules of the <em>Object Event Modeling and Simulation (OEM&amp;S)</em> paradigm (<a href="https://www.informs-sim.org/wsc17papers/includes/files/056.pdf">Wagner 2017a</a>, <a href="https://articles.jsime.org/1/1">Wagner 2018b</a>).<p>DPMN adapts the language of BPMN Process Diagrams for the purpose of simulation design modeling where a process model must represent a computationally complete process specification. While large parts of BPMN’s vocabulary, visual syntax and informal semantics can be preserved in DPMN, a number of modeling elements need to be modified.</p><p>The following diagram shows the DPMN process model corresponding to the BPMN model shown in <a class="role-figure-ref" href="#secBPMN__figCPM_BPMN"><span class="role-label">Figure <span class="role-number">1-6</span></span></a> above.</p><figure id="secBPMN__figCPM_DPMN"><figcaption><span class="role-label">Figure <span class="role-number">1-7</span>. </span>A DPMN Process Diagram for a pizza service company</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_CPM.svg" width="600" /></div></figure><p>DPMN adopts and adapts the syntax and semantics of BPMN in the following way:</p><ol><li>Instead of BPMN's &quot;Sequence Flow&quot; arrows, DPMN has<ol><li><strong>Event Flow</strong> arrows, or <strong>Event Scheduling</strong> arrows, like in Event Graphs, representing the causation of follow-up events in conceptual process models, corresponding to <i>event scheduling</i> in process design models. For instance, in <a class="role-figure-ref" href="#secBPMN__figCPM_DPMN"><span class="role-label">Figure <span class="role-number">1-7</span></span></a>, the arrow from the time out event at the &quot;take order&quot; task buffer to the &quot;lost orders&quot; event is an event flow arrow.</li><li><strong>Resource-Dependent Activity Scheduling</strong> (RDAS) arrows with three bars representing an input task buffer. For instance, in <a class="role-figure-ref" href="#secBPMN__figCPM_DPMN"><span class="role-label">Figure <span class="role-number">1-7</span></span></a>, &quot;order calls&quot; events and &quot;take order&quot; activities, and &quot;take order&quot; and &quot;make pizza&quot; activities, are connected via an RDAS arrow.</li></ol></li><li>A DPMN Process Diagram has an underlying UML Class Diagram defining its types (including object, event and activity types). These type definitions also include definitions of <em>resource roles</em>, <em>resource cardinality constraints</em> and <em>resource pools</em>, which provide the information needed for resource management in process executions. It's an option to exhibit resource roles and resource cardinality constraints in a DPMN process model, such as in the model of <a class="role-figure-ref" href="#secBPMN__figCPM_DPMN"><span class="role-label">Figure <span class="role-number">1-7</span></span></a>, which includes<ol><li>the two (non-performer) resources &quot;ovens&quot; and &quot;scooters&quot; assigned to the activities &quot;make pizza&quot; and &quot;deliver pizza&quot; via <strong>resource associations</strong> visually indicated by a small black square-shaped dot;</li><li><strong>resource cardinality constraints</strong> for all activities: (a) for the performer role of &quot;make pizza&quot; activities, the resource cardinality constraint &quot;exactly 2&quot; is expressed with the annotation &quot;[2]&quot; appended to the performer role name &quot;pizza makers&quot;, (b) the resource associations for assigning an oven and a scooter to &quot;make pizza&quot; and &quot;deliver pizza&quot; activities are annotated with &quot;1&quot; expressing the constraint that exactly one resource object is required for performing these activities; as a result of the resource association of the &quot;oven&quot; resource object with the &quot;make pizza&quot; activity and the attached resource cardinality constraint &quot;exactly 1&quot; in conjunction with the &quot;pizza makers [2]&quot; performer cardinality constraint, it holds that a &quot;make pizza&quot; activity requires exactly two pizza makers (as performers) and one oven.</li></ol></li></ol><p>A <em>conceptual</em> DPMN process model describes the <strong>causal regularities</strong> of a real world process, while a DPMN process <em>design</em> model defines <strong>event rules</strong> that capture <em>causal regularities</em>.</p></section><section class="role-section1" id="secOEMS"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.5</span>. </span>Object Event Modeling and Simulation</h2><p>Object Event (OE) Modeling and Simulation (M&amp;S) is a new general Discrete Event Simulation (DES) paradigm based on the two most important ontological categories: <strong>objects</strong> and <strong>events</strong>. In philosophy, objects have also been called <em>endurants</em> or <em>continuants</em>, while events have also been called <em>perdurants</em> or <em>occurrents</em>.</p><p>OEM&amp;S combines <em>Object-Oriented</em> (OO) Modeling with the <em>event scheduling</em> paradigm of <em>Event Graphs</em> (<a href="https://dl.acm.org/citation.cfm?id=358460">Schruben 1983</a>). The relevant <i>object types</i> and <i>event types</i> are described in an information model, which is the basis for making a process model. A modeling approach that follows the OEM paradigm is called an <i>OEM approach</i>. Such an approach needs to choose, or define, an information modeling language (such as <em>Entity Relationship Diagrams</em> or <em>UML Class Diagrams</em>) and a process modeling language (such as <em>UML Activity Diagrams</em> or <em>BPMN Process Diagrams</em>).</p><p>We propose an OEM approach based on <em>UML Class Diagrams</em> for conceptual information modeling and information design modeling, as well as <em>DPMN Process Diagrams</em> for conceptual process modeling and for process design modeling. </p><p>In the proposed approach, object types and event types are modeled as special categories of classes in a UML Class Diagram. <i>Random variables</i> are modeled as a special category of class-level operations constrained to comply with a specific probability distribution such that they can be implemented as static methods of a class. <i>Queues</i> are not modeled as objects, but rather as ordered association ends, which can be implemented as collection-valued reference properties. Finally, <i>event rules</i>, which include <i>event routines</i>, are modeled in DPMN process diagrams (and possibly also in pseudo-code), such that they can be implemented in the form of special <i>onEvent</i> methods of event classes.</p><p>Like Petri Nets and DEVS, OEM&amp;S has a formal semantics. But while Petri Nets and DEVS are abstract computational formalisms without an ontological foundation, OEM&amp;S is based on the ontological categories of objects, events and causal regularities.</p><p>In model-based simulation engineering, we distinguish between (1) a <em>conceptual model</em> describing a real-world problem domain, and (2) a <em>simulation design model</em> defining a certain computational solution for the purpose of a simulation study. Both conceptual models and design models consist of an <em>OE class model</em> describing/defining the system's <em>state structure</em> (in the form of <em>object types</em> and <em>event types</em>, and the <em>associations</em> between them) and a <em>DPMN process model</em> describing/defining the system's <em>dynamics</em> (in the form of <em>causal regularities</em> captured by <em>event rules</em>).</p><p>An OEM approach results in a simulation design model that has a well-defined operational semantics in terms of a transition system based on the event rules modeled in a DPMN process design diagram, as shown by Wagner (<a href="https://www.informs-sim.org/wsc17papers/includes/files/056.pdf">2017a</a>). Such a model can, in principle, be implemented with any object-oriented (OO) simulation technology. However, a straightforward implementation can only be expected from a technology that implements the OEM&amp;S paradigm, such as the <a href="https://gwagner57.github.io/oes/js/index.html">OES JavaScript (OESjs)</a> framework.</p></section><section class="role-section1" id="secProcesses"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.6</span>. </span>Discrete Event Processes, Business Processes and Processing Processes</h2><p>A <strong>discrete event process</strong> consists of a partially ordered set of events that cause a corresponding sequence of discrete state changes of affected objects. When two or more events within such a process have the same order rank, this means that they occur simultaneously. A discrete event process, also known more simply as a <em>discrete process</em>, may be an instance of a <em>discrete process type</em> defined by a <strong>discrete process model</strong>.</p><p>A <strong>business process</strong> is a discrete process that serves certain business purposes of an <em>organization</em> and involves events and activities performed by actors of the organization. Typically, a business process is an instance of a business process type defined by an organization (or organizational unit), which is the owner of the business process type, in the form of a <strong>business process model</strong>. </p><p>A <strong>business process model</strong> defines an <strong>Activity Network</strong> (AN) consisting of event and activity nodes connected by means of <strong>event flow arrows</strong> and <strong>resource-dependent activity scheduling (RDAS) arrows</strong>, such that event and activity nodes may be associated with objects representing their participants. In the case of an activity node, these participating objects include the <strong>resource objects</strong> required for performing an activity. Typically, an activity node is associated with a particular resource object representing the activity <strong>performer</strong>.</p><p>An <abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr> arrow from an activity node (or an event) to a successor activity node expresses the fact that a corresponding activity end event (or plain event) triggers the conditional scheduling of a successor activity start event, corresponding to the creation of a new task in the task queue of (the performer of) the successor activity . </p><p>An activity node of an AN typically has a queue of tasks (or planned activities) waiting for the availability of the required resources. </p><p>A <strong>processing process</strong> is a business process involving <em>arrival events</em>, <em>processing activities</em> and <em>departure events</em>. An arrival event for one or more <em>processing objects</em> happens at an <em>entry station</em>, from where they are routed to a <em>processing station</em> where <em>processing activities</em> are performed on them, before they are routed to another processing station or to an <em>exit station</em> where they leave the system via a departure event.</p><p>A <strong>processing process model</strong> defines a <strong>Processing Network</strong> (PN) consisting of <em>entry nodes</em>, <em>processing nodes</em> and <em>exit nodes</em> where each node represents a combination of a spatial object and an event type:</p><ol><li>Defining an <strong>entry node</strong> means defining both an <em>entry station</em> object (e.g., a reception area or a factory entrance) and an <em>arrival</em> event type for arriving <em>processing objects</em> (such as people or manufacturing parts).</li><li>Defining a <strong>processing node</strong> means defining both a <em>processing station</em> object (often used as a resource object, such as a workstation or a room) and a <em>processing activity</em> type.</li><li>Defining an <strong>exit node</strong> means defining both an <em>exit station</em> object and a <em>departure</em> event type.</li></ol><p>In a <abbr title="Processing Network">PN</abbr>, all processing nodes have an input buffer (or queue) filled with processing objects that wait to be processed. A <abbr title="Processing Network">PN</abbr> where all processing activities have exactly one abstract resource (a &quot;server&quot;) is also known as a <strong>Queuing Network</strong> in Operations Research (where processing nodes are called &quot;servers&quot; and processing objects are called &quot;entities&quot; or &quot;jobs&quot;).</p><p>For accommodating resource-constrained activities and Processing Networks, basic OEM and DPMN are extended in two steps. The first extension, OEM/DPMN-A, comprises four new information modeling categories (activity types, resource roles, resource pools, and parallel participation) and one new process modeling element (<abbr title="Resource-Dependent Activity Scheduling">RDAS</abbr> arrows), while the second extension, OEM/DPMN-PN, comprises a set of four pre-defined object type categories (processing objects, entry stations, processing stations, exit stations), two pre-defined event type categories (arrival events, departure events), one activity type category (processing activities), three node type categories (entry nodes, processing nodes, exit nodes) and one new process modeling element (object flow arrows).</p><section><h4>A. Discrete Event Processes and Event Graphs</h4><p>A <strong>discrete event process</strong> consists of a partially ordered set of events that cause a corresponding sequence of discrete state changes of affected objects. When two or more events within such a process have the same order rank, this means that they occur simultaneously. </p><p>As an example of a discrete event process we consider a manufacturing process with a workstation and three types of events: <i>PartArrival</i> events, <i>ProcessingStart</i> events and <i>ProcessingEnd</i> events.</p><p>The example process is described by the following list of event expressions: PartArrival@1, ProcessingStart@1.01, PartArrival@5.4, PartArrival@6.5, ProcessingEnd@8.47, ProcessingStart@8.48, ProcessingEnd@11.95, ProcessingStart@11.96, ProcessingEnd@17.48, where an expression <i>E</i>@<i>t</i> represents an event of type <i>E</i> occurring at time <i>t</i>. </p><p>How this process unfolds in time is illustrated by the following process log:</p><table border="1" id="secProcesses__tblDiscrEvtProcessLog"><caption><span class="role-label">Table <span class="role-number">1-1</span>. </span>An example of a discrete event process log</caption><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>WorkStation-1{ bufLen: 0, status: &quot;AVAILABLE&quot;}</td><td>PartArrival@1</td></tr><tr><td>1</td><td>1</td><td>WorkStation-1{ bufLen: 1, status: &quot;AVAILABLE&quot;}</td><td>ProcessingStart@1.01, PartArrival@5.4</td></tr><tr><td>2</td><td>1.01</td><td>WorkStation-1{ bufLen: 1, status: &quot;BUSY&quot;}</td><td>PartArrival@5.4, ProcessingEnd@8.47</td></tr><tr><td>3</td><td>5.4</td><td>WorkStation-1{ bufLen: 2, status: &quot;BUSY&quot;}</td><td>PartArrival@6.5, ProcessingEnd@8.47</td></tr><tr><td>4</td><td>6.5</td><td>WorkStation-1{ bufLen: 3, status: &quot;BUSY&quot;}</td><td>ProcessingEnd@8.47</td></tr><tr><td>5</td><td>8.47</td><td>WorkStation-1{ bufLen: 2, status: &quot;BUSY&quot;}</td><td>ProcessingStart@8.48</td></tr><tr><td>6</td><td>8.48</td><td>WorkStation-1{ bufLen: 2, status: &quot;BUSY&quot;}</td><td>ProcessingEnd@11.95</td></tr><tr><td>7</td><td>11.95</td><td>WorkStation-1{ bufLen: 1, status: &quot;BUSY&quot;}</td><td>ProcessingStart@11.96</td></tr><tr><td>8</td><td>11.96</td><td>WorkStation-1{ bufLen: 1, status: &quot;BUSY&quot;}</td><td>ProcessingEnd@17.48</td></tr><tr><td>9</td><td>17.48</td><td>WorkStation-1{ bufLen: 0, status: &quot;AVAILABLE&quot;}</td><td></td></tr></tbody></table><p>The events of a real-world discrete event process happen in a coherent spatio-temporal region determined by the locations of the events' participants. In a simulation model, one may abstract away from the aspect of space and model objects without locations, implying that events and processes happen in time, but not in space.</p><p>A discrete event process, also known more simply as a <em>discrete process</em>, may be an instance of a <em>discrete process type</em> defined by a <strong>discrete process model</strong>. A discrete event process pattern can be modeled in the form of a basic DPMN process diagram, which is an extended <em>Event Graph</em>. </p><p>The <strong>Event Graph</strong> modeling language proposed by Schruben (1983) defines directed graphs where the nodes are Event circles (representing typed event variables) annotated with state change statements in the form of state variable assignments, and the edges are arrows representing <em>event flows</em>. In the case of a conceptual process model, event flow arrows express the causation of follow-up events. In the case of a process simulation design model, event flow arrows express the scheduling of follow-up events according to the <em>event scheduling</em> paradigm of Discrete Event Simulation.</p><p>Basic DPMN extends the Event Graph diagram language by adding object rectangles containing declarations of typed object variables and state change statements, as well as gateway diamonds for expressing conditional and parallel branching. </p><p>The following basic DPMN diagram is an extended Event Graph defining a process pattern that is instantiated by the above discrete event process example. </p><figure id="secProcesses__lof__8"><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS1_PDM.svg" width="650" /></div><figcaption><span class="role-label">Figure <span class="role-number">1-8</span>. </span>A process design model in the form of a basic DPMN Process Diagram</figcaption></figure><p>This process model is based on the following Object Event (OE) class model:</p><figure id="secProcesses__lof__9"><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS1_IDM.svg" width="400" /></div><figcaption><span class="role-label">Figure <span class="role-number">1-9</span>. </span>An information design model in the form of a basic OE class model</figcaption></figure><p>A DPMN process design model specifies a set of chained event rules, one rule for each Event circle of the model. The above model specifies the following three event rules:</p><ol><li>On each <em>PartArrival</em> event, the <i>inputBufferLength</i> attribute of the associated <i>WorkStation</i> object is incremented and if the workstation's <i>status</i> attribute has the value AVAILABLE, then a new <i>ProcessingStart</i> event is scheduled to occur immediately.</li><li>When a <em><i>ProcessingStart</i></em> event occurs, the associated <i>WorkStation</i> object's <i>status</i> attribute is changed to BUSY and a <em><i>ProcessingEnd</i></em> event is scheduled with a delay provided by invoking the <i>processingTime</i> function defined in the <i>ProcessingStart</i> event class.</li><li>When a <em><i>ProcessingEnd</i></em> event occurs, the <i>inputBufferLength</i> attribute of the associated <i>WorkStation</i> object is decremented and if the <i>inputBufferLength</i> attribute has the value 0, the associated <i>WorkStation</i> object's <i>status</i> attribute is changed to AVAILABLE. If the <i>inputBufferLength</i> attribute has a value greater than 0, a new <em><i>ProcessingStart</i></em> event is scheduled to occur immediately.</li></ol><p>The formal (transition system) semantics of basic DPMN diagrams, based on the semantics of event rules as transition functions, has been presented in (Wagner 2017a). It can be shown that the basic DPMN diagram language is a conservative extension of the Event Graph diagram language by means of a homomorphic embedding of Event Graphs in DPMN diagrams.</p></section><section><h4>B. Business Processes and Activity Networks</h4><p>An <strong>activity</strong> is a composite event that is composed of, and temporally framed by, a pair of start and end events.</p><p>A <strong>business process</strong> of an <em>organization</em> is a discrete event process that includes <em>activities</em> performed by actors of the organization for serving certain business purposes of the organization. In addition to its <strong>performer</strong>, an activity may involve further <strong>resources</strong>, and allocating the required resources from resource pools during the course of a business process is essential for keeping it going.</p><p>As an example of a business process we consider a manufacturing process with a workstation and three types of events: <i>PartArrival</i> events, <i>Processing-Activity-Start</i> events and <i>Processing-Activity-End</i> events. </p><p>The example business process is described by the following list of event expressions: PartArrival@1, Processing-Activity-Start@1.01, PartArrival@5.4, PartArrival@6.5, Processing-Activity-End@8.47, Processing-Activity-Start@8.48, Processing-Activity-End@11.95, Processing-Activity-Start@11.96, Processing-Activity-End@17.48, where an expression <i>E</i>@<i>t</i> represents an event of type <i>E</i> occurring at time <i>t</i>.</p><p>How this process unfolds in time is illustrated by the following process log:</p><table border="1" id="secProcesses__lot__2"><caption><span class="role-label">Table <span class="role-number">1-2</span>. </span>An example of a business process log</caption><thead><tr><th>Step</th><th>Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>WorkStation-1{ status: 1} | av. workStations: ws1</td><td>PartArrival@1</td></tr><tr><td>1</td><td>1</td><td>WorkStation-1{ status: 2} | av. workStations:</td><td>Processing-Activity-Start{ ws1 }@1.01, PartArrival@18.83</td></tr><tr><td>2</td><td>1.01</td><td>WorkStation-1{ status: 2} | av. workStations:</td><td>Processing-Activity-End{ ws1 }@8.08, PartArrival@18.83</td></tr><tr><td>3</td><td>8.08</td><td>WorkStation-1{ status: 1} | av. workStations: ws1</td><td>PartArrival@18.83</td></tr><tr><td>4</td><td>18.83</td><td>WorkStation-1{ status: 2} | av. workStations:</td><td>Processing-Activity-Start{ ws1 }@18.84, PartArrival@25.61</td></tr><tr><td>5</td><td>18.84</td><td>WorkStation-1{ status: 2} | av. workStations:</td><td>Processing-Activity-End{ ws1 }@23.9, PartArrival@25.61</td></tr><tr><td>6</td><td>23.9</td><td>WorkStation-1{ status: 1} | av. workStations: ws1</td><td>PartArrival@25.61</td></tr><tr><td>7</td><td>25.61</td><td>WorkStation-1{ status: 2} | av. workStations:</td><td>Processing-Activity-Start{ ws1 }@25.62</td></tr><tr><td>8</td><td>25.62</td><td>WorkStation-1{ status: 2} | av. workStations:</td><td>Processing-Activity-End{ ws1 }@32.03</td></tr><tr><td>9</td><td>32.03</td><td>WorkStation-1{ status: 1} | av. workStations: ws1</td><td></td></tr></tbody></table><p>Notice that, as opposed to the process log shown in <a class="role-table-ref" href="#secProcesses__tblDiscrEvtProcessLog"><span class="role-label">Table <span class="role-number">1-1</span></span></a>, </p><ol><li>the workstation with ID 1 is a (performer) resource for <i>Processing</i> activities having either the status 1 (being available) or 2 (being busy), and</li><li>there is a pool of available resources (&quot;av. workStations&quot;).</li></ol><p>Typically, a business process is an instance of a business process type defined by an organization (or organizational unit), which is the owner of the business process type, in the form of a <strong>business process model</strong>. The above example business process is an instance of the following model:</p><figure id="secProcesses__figPDMwithoutRDASAs"><div style="display:flex; justify-content: space-between; "><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_PDM2b.svg" width="420" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_IDM2b.svg" width="270" /></div><figcaption><span class="role-label">Figure <span class="role-number">1-10</span>. </span>A DPMN-A process model and its underlying OE class model</figcaption></figure><p>A <strong>business process model</strong> defines an <strong>Activity Network</strong> (AN), which provides a pattern for business processes. An AN specifies a set of chained event rules with typed object, event and activity variables, based on an OE class model defining object, event and activity types. By convention, activity classes have a <i>duration</i> function that is invoked for getting the duration of newly created instances of the activity class. In a simulation design model, these functions typically define random variate sampling functions (like the service time concept in queuing theory).</p><p>Event circles and Activity rectangles may be connected via <strong>event flow arrows</strong>, as shown above in <a class="role-figure-ref" href="#secProcesses__figPDMwithoutRDASAs"><span class="role-label">Figure <span class="role-number">1-10</span></span></a>, or via <strong>resource-dependent activity scheduling arrows</strong>, as shown below in <a class="role-figure-ref" href="#secProcesses__figPDMwithRDASA"><span class="role-label">Figure <span class="role-number">1-11</span></span></a>.</p><p>The AN shown in <a class="role-figure-ref" href="#secProcesses__figPDMwithoutRDASAs"><span class="role-label">Figure <span class="role-number">1-10</span></span></a> defines the following event rules:</p><ol><li>On each <em>PartArrival</em> event, if the associated <i>WorkStation</i> object's <i>status</i> attribute has the value AVAILABLE, then it is set to BUSY and the rule variable <i>wsAllocated</i> is set to true; otherwise the <i>inputBufferLength</i> attribute of the associated <i>WorkStation</i> object is incremented. If <i>wsAllocated</i> holds, then a new <i>Processing</i> activity is scheduled to start immediately with a duration provided by invoking the <i>duration</i> function defined in the <i>Processing</i> activity class.</li><li>When a <em><i>Processing</i></em> activity ends, if the <i>inputBufferLength</i> attribute of the associated <i>WorkStation</i> object has the value 0, then the <i>WorkStation</i> object's status attribute is set to AVAILABLE; otherwise the rule variable <i>wsAllocated</i> is set to true and the <i>WorkStation</i> object's <i>inputBufferLength</i> attribute is decremented. If <i>wsAllocated</i> holds, then a new <i>Processing</i> activity is scheduled to start immediately with a duration provided by invoking the <i>duration</i> function defined in the <i>Processing</i> activity class.</li></ol><p>Since the resource management logic concerning the workstation as a resource for <i>Processing</i> activities follows a general pattern, a new modeling language element can be introduced for capturing this pattern. Using <em>resource-dependent activity start arrows</em>, we can express the process model of <a class="role-figure-ref" href="#secProcesses__figPDMwithoutRDASAs"><span class="role-label">Figure <span class="role-number">1-10</span></span></a> more simply as in the following diagram:</p><figure id="secProcesses__figPDMwithRDASA"><div style="display:flex; justify-content: space-between; "><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_PDM3.svg" width="350" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_IDM2a.svg" width="270" /></div><figcaption><span class="role-label">Figure <span class="role-number">1-11</span>. </span>A DPMN-A process model with a resource-dependent activity start arrow and its underlying OE class model</figcaption></figure><p>Notice that in this model, we have expressed that we no longer have to take care of setting the status of the workstation as a resource, nor do we have to update the queue/buffer length. This is now expressed implicitly by the semantics of the resource-dependent activity scheduling (RDAS) arrow and has to be handled in a generic way by a simulator supporting DPMN-A models.</p><p>The following diagram shows a model containing both event scheduling arrows and RDAS arrows:</p><figure id="secProcesses__lof__12"><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/PDM.svg" width="700" /></div><figcaption><span class="role-label">Figure <span class="role-number">1-12</span>. </span>A DPMN-A process model of a Load-Haul-Dump business process</figcaption></figure><p>In this model, activities are initiated (1) by an RDAS arrow when they may have to wait for the availability of required resources, or (2) by an event scheduling arrow when no other resources are required. For instance, a new <i>Load</i> activity can only be started, when a wheel loader (as a performer) is available, while a <i>Haul</i> activity can be started immediately after the completion of a <i>Load</i> activity because it's performed by the loaded truck, and no other resources are required.</p><p>The most widely used language for defining ANs is the <em>Business Process Modeling Notation (BPMN)</em>. However, in BPMN there is only one type of arrow, called &quot;Sequence Flow&quot;, which is semantically overloaded with both meanings: it can represent an event flow arrow or a resource-dependent activity start arrow.</p><p>The concept of ANs includes business system processes, where many business actors perform activities for handling many business cases in parallel. Consequently, it is more general than the common concept of a business process as a case-handling process.</p><p>Normally all activity nodes of an AN have a queue of planned activities (&quot;tasks&quot;) waiting for the availability of required resources (in particular, their performer). Only if a successor activity node does not require additional or different resources, it does not have a (resource allocation) queue and can be started right away whenever a predecessor activity has completed, as indicated by an event flow arrow. </p><p>When all activity nodes of an AN only have a single resource (the performer of the activity), and each of them has a different performer, then the AN corresponds to a <em>Queuing Network</em> in the sense of Operations Research. </p></section><section><h4>C. Processing Processes and <strong>Processing Network</strong>s</h4><p></p></section></section></section><section class="role-chapter" id="index"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">2</span>. </span>Event-Based Simulation</h1><p><em>Event-Based Simulation (ES)</em> is the most fundamental form of Discrete Event Simulation (<a href="http://www.informs-sim.org/wsc10papers/019.pdf">Pegden 2010</a>). The ES paradigm has been pioneered by <em>SIMSCRIPT</em> (<a href="https://www.rand.org/content/dam/rand/pubs/research_memoranda/2009/RM3310.pdf">Markowitz, Hausner &amp; Karr 1962</a>) and later formalized by <em>Event Graphs</em> (<a href="https://dl.acm.org/citation.cfm?id=358460">Schruben 1983</a>).</p><p>According to Pegden, in ES, the system under investigation is viewed as a series of instantaneous events that change its state over time. The modeler “defines the events in the system and models the state changes that take place when those events occur”. More precisely, the modeler defines the <i>types</i> of events that cause <i>state changes</i> and/or <i>follow-up events</i>.</p><p>Pegden also explains that in ES,</p><ol><li>a simulation creates events that are supposed to occur in the future (called <i>future events</i>),</li><li>future events are scheduled (using an <i>event scheduling</i> mechanism),</li><li>time advances to the time of the next event (<i>next-event time progression</i>),</li><li>the series of events corresponds to a sequence of state transitions of a <i>transition system</i> where the “transition logic” of each event type is specified in the form of a procedure definition (often called <i>event routine</i>).</li></ol><p>Event routines can be expressed at an abstract level, e.g., using pseudo code as in (<a href="http://www.informs-sim.org/wsc10papers/019.pdf">Pegden 2010</a>), or in a simulation or programming language. In an object-oriented approach, it is natural to define an event routine as a method of the class defining the event type.</p><p>Pegden does not make any attempt to clarify the philosophical nature of (types of) events and their “transition logic”. Philosophically, (1) all events have <i>participants</i>, which are the objects that participate in them; (2) the combination of an <em>event type</em> and its <i>event routine</i> amounts to an <b><i>event rule</i></b> of the form </p><p class="indented"><b>ON</b> <i>event</i> <b>DO</b> <i>procedure</i></p><p>Basic Object Event Simulation (OES) extends ES, or Event Graphs, by adding the modeling concepts of <em>objects</em> and <em>event rules</em>.</p><section class="role-section1" id="ES-without-Objects"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Event-Based Simulation without Objects</h2><p>When Event-Based Simulation (ES) was developed in the 1960's, pioneered by <a href="https://www.rand.org/content/dam/rand/pubs/research_memoranda/2009/RM3310.pdf">SIMSCRIPT</a>, the software engineering paradigm of Object-Oriented (OO) modeling and OO programming was not yet available. Therefore, the objects of a system have not been modeled as objects, but rather the relevant characteristics of the (objects of) the system under investigation have been modeled in the form of <em>state variables</em>.</p><section><h4>The ES Formalism</h4><p>We illustrate the formal semantics of ES with the help of an example. We model a system of one or more service desks, each of them having its own queue, as a discrete event system characterized by the following narrative:</p><ol><li>Customers arrive at a service desk at random times.</li><li>If there is no other customer in front of them, and the service desk is available, they are served immediately, otherwise they have to queue up in a waiting line.</li><li>The duration of services varies, depending on the individual case.</li><li>When a service is completed, the customer departs and the next customer is served, if there is still any customer in the queue.</li></ol><p>The base concepts of ES are:</p><ol><li><em>state variables</em> for defining the state of a system,</li><li>event types,</li><li>event expressions,</li><li>event routines,</li><li>future events lists (FEL).</li></ol><p>A <b><i>state variable</i></b> is declared with a name and a <em>range</em>, which is a datatype defining its possible values.</p><p>An <b><i>event type</i></b> is defined in the form of a class: with a name, a set of property declarations and a set of method definitions, which together define the <i>signature</i> of the event type.</p><p>An <b><i>event expression</i></b> is a term E<i>(<u>x</u>)@t</i> where</p><ol><li>E is an event type,</li><li><i>t</i> is a parameter for the occurrence time of events,</li><li><i><u>x</u></i> is a (possibly empty) list of event parameters <i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, …, <i>x<sub>n</sub></i> according to the signature of the event type E.</li></ol><p>For instance, Arrival@<i>t</i> is an event expression for describing Arrival events where the signature of the event type Arrival is empty, so there are no event parameters, and the parameter <i>t</i> denotes the arrival time (more precisely, the occurrence time of the Arrival event). An individual event of type E is a <i>ground</i> event expression, <i>e</i> = E(<i><u>v</u></i>)@<i>i</i>, where the event parameter list <i><u>x</u></i> and the occurrence time parameter <i>t</i> have been instantiated with a corresponding value list <i><u>v</u></i> and a specific time instant <i>i</i>. For instance, Arrival@1 is a ground event expression representing an individual Arrival event.</p>An <b><i>event routine</i></b> is a procedure that essentially computes state changes and follow-up events, possibly based on conditions on the current state. In practice, state changes are often directly performed by immediately updating the state variables concerned, and follow-up events are immediately scheduled by adding them to the FEL. For defining the formal semantics of ES, we assume that an event routine is a pure function that computes state changes and follow-up events, but does not apply them, as in the rules described in <a class="role-table-ref" href="#ES-without-Objects__tblEventRulesArrDep"><span class="role-label">Table <span class="role-number">2-1</span></span></a>.<table border="1" id="ES-without-Objects__tblEventRulesArrDep" style="border-spacing:0px;width:100%;"><caption><span class="role-label">Table <span class="role-number">2-1</span>. </span>Expressing event routines as pure functions that compute state changes and follow-up events.</caption><colgroup style="text-align:center;"></colgroup><colgroup></colgroup><colgroup></colgroup><thead><tr><td style="vertical-align:top;"><p><b>Event rule name</b></p></td><td style="text-align:center;"><p><b>ON (event expression)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>r<i><sub>Arr</sub></i></p></td><td><p>Arrival @ t</p></td><td><p>E’ := { Arrival @ (t + recurrence()) }<br />Δ := { INCREMENT queueLength }<br />IF queueLength = 0<br />THEN E’ := E’ ⋃ { Departure @ (t + serviceDuration()) }<br />RETURN ⟨ Δ, <i>E'</i> ⟩</p></td></tr><tr><td><p>r<i><sub>Dep</sub></i></p></td><td><p>Departure @ t</p></td><td><p>E’ := {}<br />Δ := { DECREMENT queueLength }<br />IF queueLength &gt; 1<br />THEN E’ := E’ ⋃ { Departure @ (t + serviceDuration()) }<br />RETURN ⟨ Δ, <i>E'</i> ⟩ </p></td></tr></tbody></table><p>An <b><i>event rule</i></b> associates an event expression with an <i>event routine F</i>:</p><p class="indented"><b>ON</b> E<i>(<u>x</u>)@t</i> <b>DO</b> <i>F( t, <u>x</u>)</i>,</p><p>where the event expression E<i>(<u>x</u>)@t</i> specifies the type E of events that trigger the rule, and <i>F( t, <u>x</u>)</i> is a function call expression for computing a set of <i>state changes</i> and a set of <i>follow-up events</i>, based on the event parameter values <i><u>x</u></i>, the event's occurrence time <i>t</i> and the current system state, which is accessed in the event routine <i>F</i> for testing conditions expressed in terms of state variables.</p><p>A <b><i>Future Events List (FEL)</i></b> is a set of ground event expressions partially ordered by their occurrence times, which represent future time instants either from a discrete or a continuous model of time. The partial order implies the possibility of simultaneous events, as in the example { Departure@4, Arrival@4 }.</p><section><h5>ES Models</h5><p>An <em>ES<b><i> </i></b>model</em> is a triple ⟨ SV, ET, R ⟩ where</p><ol><li>SV is a set of state variable declarations defining the structure of possible system states,</li><li>ET is a set of event type definitions,</li><li>R is a set of event rules expressed in terms of SV and ET.</li></ol><p>We show how to express the example model of a simple service desk system as an ES model. The set of state variables is a singleton:</p><p class="indented">SV = { queueLength: NonNegativeInteger}</p><p>There are two event types, both having an empty signature:</p><p class="indented">ET = { Arrival(), Departure()}</p><p>And there are two event rules:</p><p class="indented">R = { r<i><sub>Arr</sub></i>, r<i><sub>Dep</sub></i>}</p><p>which are defined as in Table 1 above.</p><p>Such a model, together with an initial state (specifying initial values for state variables and initial events), defines an ES system, which is a transition system where</p><ol><li>system states are defined by value assignments for the state variables,</li><li>transitions are provided by event occurrences triggering event rules that change the simulation state through changing the system state (by changing the values of affected state variables) and the FEL (by adding follow-up events).</li></ol><p>Whenever the transitions of an ES system involve computations based on random numbers (if the simulation model contains random variables), the transition system defined is non-deterministic.</p><p>For instance, assuming that the initial system state is <i>S</i><sub>0</sub> = {queueLength: 0}, and there is an initial event {Arrival@1}, then, as a consequence of applying r<i><sub>Arr</sub></i>, there is a system state change {queueLength := 1} and, assuming a random service time of 2 time units (as a sample from the underlying probability distribution function), a follow-up event Departure@3, which has to be scheduled along with the next Arrival event, say Arrival@3 (with a random inter-arrival time of 2), because Arrival is an exogenous event type (with a random recurrence). Consequently, the next system state is <i>S</i><sub>1</sub> = {queueLength: 1}.</p><p>We need to distinguish between the <i>system state</i>, like <i>S</i><sub>0</sub> = {queueLength: 0}, which is the state of the simulated system, and the <i>simulation state</i>, which adds the FEL to the system state, like</p><p class="indented"><b><i>S</i></b><sub>0</sub> = ⟨ {queueLength: 0}, {Arrival@1} ⟩</p><p class="indented"><b><i>S</i></b><sub>1</sub> = ⟨ {queueLength: 1}, {Arrival@2, Departure@3} ⟩</p><p>Doing one more step, the next transition is given by the next event Arrival@2 again triggering r<i><sub>Arr</sub></i>, which leads to</p><p class="indented"><b><i>S</i></b><sub>2</sub> = ⟨ {queueLength: 2}, {Departure@3, Arrival@4} ⟩</p><p>In this way, we get a succession of states <b><i>S</i></b><sub>0</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>1</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>2</sub> <span style="font-family:monospace;">→</span> … as a history of the transition system defined by the ES model.</p></section><section><h5>Event Rules as Functions</h5><p>An event rule <i>r</i> = <b>ON</b> E<i>(<u>x</u>)@t</i> <b>DO</b> <i>F( t, <u>x</u>)</i> can be considered as a 2-step function that, in the first step, maps an event <i>e</i> = E(<i><u>v</u></i>)@<i>i</i> to a parameter-free state change function <i>r<sub>e</sub></i> = <i>F( i, <u>v</u>)</i>, which maps a system state to a pair ⟨ Δ, <i>E'</i> ⟩ of system state changes Δ and follow-up events <i>E'</i>. When the parameters <i>t</i> and<i> <u>x</u></i> of <i>F( t, <u>x</u>)</i> are replaced by the values <i>i</i> and <i><u>v</u></i> provided by a ground event expression E(<i><u>v</u></i>)@<i>i</i>, we also simply write <i>F<sub>i,<u>v</u></sub></i> instead of <i>F( i, <u>v</u>)</i> for the resulting parameter-free state change function.</p><p>We say that an event rule <i>r</i> is <i>triggered</i> by an event <i>e</i> when the event’s type is the same as the rule’s triggering event type. When <i>r</i> is triggered by <i>e</i>, we can form the state change function <i>r<sub>e</sub></i> = <i>F<sub>i,<u>v</u></sub></i> and apply it to a system state <i>S</i> by mapping it to a set of system state changes Δ and a set of follow-up events <i>E'</i>:</p><p class="indented"><i>r<sub>e</sub>(S)</i> = <i>F<sub>i,<u>v</u></sub>(S)</i> = ⟨ Δ, <i>E'</i> ⟩</p><p>We can illustrate this with the help of our running example. Consider the rule r<i><sub>Arr</sub></i> defined in Table 1 above triggered by the event Arrival@1 in state <i>S</i><sub>0</sub> = {queueLength: 0}. The resulting state change function <i>F</i><sub>1</sub> defined by the corresponding event routine from Table 1 maps <i>S</i><sub>0</sub> to the set of state changes Δ = { INCREMENT queueLength} and the set of follow-up events <i>E'</i> = {Departure@3}. We show how the pair ⟨ Δ, <i>E'</i> ⟩ amounts to a transition of the simulation state in the next section.</p><p>In ES, a system state change is an update of one or more state variables. Such an update is specified in the form of an assignment where the right-hand side is an expression that may involve state variables. For instance, the state change <span style="font-family:monospace;">INCREMENT queueLength</span> is equivalent to the assignment <span style="font-family:monospace;">queueLength </span>:=<span style="font-family:monospace;"> queueLength + 1</span>.</p><p>In general, there may be situations, where we have several concurrent events, that is, there may be two or more events occurring at the same (next-event) time. Therefore, we need to explain how to apply a set of rules <i>R<sub>E</sub></i> triggered by a set of events <i>E</i>, even if both sets are singletons in many cases.</p><p>The rule set <i>R</i> of an ES model can also be considered as a 2-step function that, in the first step, maps a set of events <i>E</i> to a state change function <i>R<sub>E</sub></i>, which maps a system state to a pair ⟨ Δ, <i>E'</i> ⟩ of state changes Δ and follow-up events <i>E'</i>.</p><p>For a given set of events <i>E</i> and a rule set <i>R</i>, we can form the set of state change functions obtained from rules triggered by events from <i>E</i>:</p><p class="indented"><i>R<sub>E</sub></i> = { <i>r<sub>e</sub></i> : <i>r</i> ∈ <i>R</i> &amp; <i>e</i> ∈ <i>E</i> &amp; <i>e</i> triggers <i>r</i>}</p><p>Notice that the elements <i>C</i> of <i>R<sub>E</sub></i> are parameter-free state change functions, which can be applied as a block, in parallel, to a system state <i>S:</i></p><p class="indented"><i>R<sub>E</sub>(S)</i> = ⟨ Δ, <i>E'</i> ⟩</p><p>with</p><p class="indented">Δ = ⋃ { Δ<i><sub>C</sub></i> : <i>C</i> ∈ <i>R<sub>E</sub></i> &amp; <i>C(S)</i> = ⟨ Δ<i><sub>C</sub></i>, <i>E'<sub>C</sub></i> ⟩ }<br /><i>E'</i> = ⋃ { <i>E'<sub>C</sub></i> : <i>C</i> ∈ <i>R<sub>E</sub></i> &amp; <i>C(S)</i> = ⟨ Δ<i><sub>C</sub></i>, <i>E'<sub>C</sub></i> ⟩ }</p><p>Notice that when forming the union of all state changes brought about by applying rules from <i>R<sub>E</sub></i>, and likewise when forming the union of all follow-up events created by applying rules from <i>R<sub>E</sub></i>, the order of rule applications does not matter because they do not affect the applicability of each other, so any selection function for choosing rules from <i>R<sub>E</sub></i> and applying them sequentially will do, and they could also be applied simultaneously if such a parallel computation is supported.</p><p>However, computing a set of state changes Δ raises the question if this set is, in some sense, consistent. A simple, but too restrictive, notion of consistent state changes would require that if Δ contains two or more updates of the same state variable, all of them must be equivalent (effectively assigning the same value). A more liberal notion just requires that if Δ contains two or more updates of the same state variable, their collective application must result in the same value for it, no matter in which order they are applied.</p><p>If Δ contains inconsistent updates for a state variable, this may be a bug or a feature of the simulation model. If it is not a bug, a conflict resolution policy is needed. The simplest policy is ignoring, or discarding, all inconsistent updates. Another common conflict resolution policy is based on assigning priorities to event rules.</p><p>Consider again our running example with a system state <i>S</i> = {queueLength: 1} and the set of next events <i>N</i> = {Arrival@4, Departure@4}. Then, R<i><sub>N</sub></i> consists of the two parameter-free change functions:</p><ol><li>F<sub>1</sub>: function () {Δ := { INCREMENT queueLength}; IF queueLength = 0 THEN <br /> <i>E'</i> := { Departure @ (4 + serviceDuration())}; RETURN ⟨ Δ, <i>E'</i> ⟩ }</li><li>F<sub>2</sub>: function () {Δ := { DECREMENT queueLength}; IF queueLength &gt; 1 THEN <br /><i> E'</i> := { Departure @ (4 + serviceDuration())}; RETURN ⟨ Δ, <i>E'</i> ⟩}</li></ol><p>No matter in which order we apply F<sub>1</sub> and F<sub>2</sub>, forming the union of their state changes always results in Δ = {}, because the incrementation and decrementation of the variable <i>queueLength</i> neutralize each other, and forming the union of their follow-up events always results in <i>E'</i> = { Departure@(4+d)} where d is the random value returned by the <i>serviceDuration</i> function.</p></section><section><h5>An Event Rule Set as a Simulation State Transition Function</h5><p>We show that the event rule set R of an ES model ⟨ SV, ET, R ⟩ defines a transition function that maps a simulation state ⟨ <i>S</i>, <i>FEL</i> ⟩ to a successor state ⟨ <i>S'</i>, <i>FEL'</i> ⟩ in 3 steps:</p><ol><li>R maps the set of next events <i>N</i> extracted from the <i>FEL</i> to a set R<i><sub>N</sub></i> of state change functions of rules triggered by one of the next events from <i>N</i>.</li><li>R<i><sub>N</sub></i> maps the current system state <i>S</i> to a set of state changes Δ and a set of follow-up events <i>E'</i>.</li><li>The pair ⟨ Δ, <i>E'</i> ⟩ amounts to a transition of the current simulation state ⟨ <i>S</i>, <i>FEL</i> ⟩ by applying the updates from Δ to <i>S</i> yielding <i>S’</i> and by removing <i>N</i> from <i>FEL</i> and adding <i>E'</i>.</li></ol><p>We have already explained how to obtain R<i><sub>N</sub></i> from R and how to apply R<i><sub>N</sub></i> to <i>S</i> for getting ⟨ Δ, <i>E'</i> ⟩ in the previous subsection, so we only need to provide more explanation for the last step: processing ⟨ Δ, <i>E'</i> ⟩ for obtaining the next simulation state ⟨ <i>S'</i>, <i>FEL'</i> ⟩.</p><p>We use the symbol Upd for denoting an update operation that takes a system state <i>S</i> and a set of state changes Δ, and returns an updated system state Upd( <i>S, </i>Δ). When the system state consists of state variables, the update operation simply performs assignments. Using this operation, we can define the third step of the simulation state transition function with two sub-steps in the following way:</p><ol type="a"><li><i>S'</i> = Upd( <i>S, </i>Δ)</li><li><i>FEL' = FEL <span style="font-family:monospace;">−</span> N </i>⋃ <i>E'</i></li></ol><p>This completes our definition of how the event rule set R of an ES model works as a transition function that computes the successor state of a simulation state:</p><p class="indented">R(⟨ <i>S</i>, <i>FEL </i>⟩) = ⟨ <i>S'</i>, <i>FEL'</i> ⟩</p><p>such that for a given initial simulation state <b><i>S</i></b><sub>0</sub> = ⟨ <i>S</i><sub>0</sub>, <i>FEL</i><sub>0</sub><i> </i>⟩, we obtain a succession of states</p><p class="indented"><b><i>S</i></b><sub>0</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>1</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>2</sub> <span style="font-family:monospace;">→</span> …</p><p>by iteratively applying R:</p><p class="indented"><b><i>S</i></b><sub>i+1</sub> = R( <b><i>S</i></b><sub>i</sub>)</p><p>Consider again our running example. In simple cases we do not have more than one next event, so <i>R<sub>N</sub></i> is a singleton and we do not have to apply more than one rule at a time. For instance, when</p><p class="indented"><b><i>S</i></b><sub>1</sub> = ⟨{ queueLength: 1}, { Arrival@2, Departure@3}⟩</p><p>There is only one next event: Arrival@2, so we do not have to form a set of applicable rules, but can immediately apply the rule triggered by Arrival@2 for obtaining a set of system state changes and a set of follow-up events:</p><p class="indented">r<i><sub>Arr</sub></i><sub> </sub>( <b><i>S</i></b><sub>1</sub>) = ⟨{ queueLength := 2}, { Arrival@4}⟩</p><p>Now consider a simulation state where we have more than one next event, like the following one:</p><p class="indented"><b><i>S</i></b><sub>3</sub> = ⟨{ queueLength: 1}, { Arrival@4, Departure@4}⟩</p><p>We obtain</p><p class="indented">R( <b><i>S</i></b><sub>3</sub>) = ⟨{ queueLength: 1}, { Arrival@5, Departure@6}⟩</p><p>assuming a random inter-arrival time sample of 1 and a random service duration sample of 2.</p></section></section></section><section class="role-section1" id="OEM-Example-Workstation"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.2</span>. </span>Modeling a Manufacturing Workstation as a Queueing System</h2><p>A manufacturing workstation receives parts and stores them in its input buffer for processing them successively. </p><section><h4>Conceptual Model</h4><p>A conceptual information model of a workstation system, defining two object types and four event types, is shown in <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS_CIM"><span class="role-label">Figure <span class="role-number">2-1</span></span></a>.</p><figure id="OEM-Example-Workstation__figWS_CIM"><figcaption><span class="role-label">Figure <span class="role-number">2-1</span>. </span>A conceptual information model of a manufacturing workstation system</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS_CIM.svg" /></div></figure><p>As expressed by the associations between the four event types and the two object types, for all four types of events, there are the same two types of objects participating in them: parts and workstations, implying that each event of these four types involves a specific part and a specific workstation.</p><p>Notice that the input buffer (filled with waiting parts) is modeled as an association end with name <em>waiting parts</em> at the <em>parts</em> side of the association between <em>parts</em> and <em>workstations</em>, expressing the fact that at any point in time, a workstation has zero or more parts waiting in its input buffer for being processed.</p><p>A conceptual process model of this system, describing four <em>causal regularities</em> in the form of <em>event rules</em>, one for each type of event, is shown in <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS_CPM"><span class="role-label">Figure <span class="role-number">2-2</span></span></a> in the form of a <em>BPMN Process Diagram</em> using Event circles connected with Sequence Flow arrows expressing (conditional) causation, and Data Objects attached to Event circles.</p><figure id="OEM-Example-Workstation__figWS_CPM"><figcaption><span class="role-label">Figure <span class="role-number">2-2</span>. </span>A conceptual process model of a manufacturing workstation system</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS_CPM.svg" /></div></figure><p>The four event rules described by this model are</p><ol><li>When a part arrives, it is added to the input buffer and, if the workstation is available, there will be a processing start event for processing the newly arrived part.</li><li>When a processing start event occurs, the next part from the input buffer is being processed and a processing end event is caused to occur some time later (after the processing time has elapsed).</li><li>When a processing end event occurs, this will cause a part departure event and, if the input buffer is not empty, another processing start event involving the next part from the buffer.</li><li>When a part departure event occurs, the processed part will be removed from the workstation.</li></ol></section><section><h4>Design Model</h4><p>A simulation design model is based on a conceptual model. Depending on the purposes/goals of a simulation study, it may abstract away from certain elements of the real-world domain described by the conceptual model, and it adds computational elements representing design decisions, such as <em>random variables</em> expressed int he form of random variate sampling functions based on specific probability distributions for modeling the random variation of certain system variables.</p><p>An information design model of the single workstation system described above is shown in <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS2_IDM"><span class="role-label">Figure <span class="role-number">2-3</span></span></a>. This model defines the multi-valued <code>waitingParts</code> association end to be ordered, which means that it corresponds to a multi-valued reference property holding an ordered collection (such as an array list or a queue) as its value. </p><p>The information design model of <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS2_IDM"><span class="role-label">Figure <span class="role-number">2-3</span></span></a> defines that a <i>PartArrival</i> event must reference both a <i>Part</i> and a <i>WorkStation</i>, representing situations where specific parts arrive at specific workstations. Notice that, computationally, this model requires creating new <i>Part</i> objects (or retrieving them from an object pool) before a new <i>PartArrival</i> event is created (or scheduled), while it is more common in simulation models to create a new <i>Part</i> object only when an arrival event has occurred, which can be modeled by defining a multiplicity of 0..1 for the <i>Part</i> end of the <i>PartArrival</i>-<i>Part</i> association (with the meaning that <i>PartArrival</i> has an optional, instead of a mandatory, reference property with name <i>part</i>).</p><figure id="OEM-Example-Workstation__figWS2_IDM"><figcaption><span class="role-label">Figure <span class="role-number">2-3</span>. </span>An information design model</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS2_IDM.svg" /></div></figure><p>Notice that the model defines two class level operations (designated with the stereotype «rv») implementing random variate sampling functions: <code>PartArrival::recurrence()</code> complies with a triangular probability distribution with minimum, mode and maximum parameter values 3, 4 and 8, while <code>ProcessingStart::processingTime()</code> complies with an exponential distribution with a mean of 6.</p><p>A process design model based on the object and event types defined by the information design model of <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS2_IDM"><span class="role-label">Figure <span class="role-number">2-3</span></span></a> and derived from the conceptual process model of <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS_CPM"><span class="role-label">Figure <span class="role-number">2-2</span></span></a> is shown in <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS2_PDM"><span class="role-label">Figure <span class="role-number">2-4</span></span></a>.</p><figure id="OEM-Example-Workstation__figWS2_PDM"><figcaption><span class="role-label">Figure <span class="role-number">2-4</span>. </span>A process design model in the form of a DPMN Process Diagram</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS2_PDM.svg" /></div></figure><p>Notice that, since all events happen at the same workstation, all three event scheduling arrows are annotated with the same event property assignment <code>workStation := ws</code>, which simply propagates the object reference to the given workstation along the event scheduling chain. Such property propagation assignments (in event property assignment annotations), where a property value of a follow-up event is set to the corresponding property value of the scheduling (or triggering) event, will be omitted (as implied by event types having the same property names) for avoiding to clutter the process model diagrams.</p><p>A DPMN Process Diagram, like the one shown in <a class="role-figure-ref" href="#OEM-Example-Workstation__figWS2_PDM"><span class="role-label">Figure <span class="role-number">2-4</span></span></a>, can be split up into a set of event rule diagrams, one for each of its Event circles, as shown in the following table. This reduction of a DPMN process design model to a set of event rule design models, together with the operational semantics of event rules presented in (Wagner 2017a), provides the semantics of DPMN Process Diagrams. </p><p>Notice that an event rule design model can also be expressed textually in the form of a pseudo-code block with four parts: part 1 indicates the triggering event type and declares a rule variable representing the triggering event, part 2 declares further rule variables and initializes them, part 3 contains a state change script consisting of state change statements, and part 4 schedules follow-up events.</p><table border="1"><tbody><tr><th>Rule design model</th><th>Pseudo-code</th></tr><tr><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS2_RDM_PartArrival.svg" /></td><td><table border="1"><thead><tr><th>ON a:PartArrival</th></tr></thead><tbody><tr><td>ws : WorkStation<br />ws := a.workStation</td></tr><tr><td>ws.waitingParts.enqueue( a.part)</td></tr><tr><td>IF ws.status = AVAILABLE <br />THEN SCHEDULE ProcessingStart( workStation:=ws)</td></tr></tbody></table></td></tr><tr><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS2_RDM_ProcStart.svg" /></td><td><table border="1"><thead><tr><th>ON ps:ProcessingStart</th></tr></thead><tbody><tr><td>ws : WorkStation<br />ws := ps.workStation</td></tr><tr><td>ws.status := BUSY</td></tr><tr><td>SCHEDULE ProcessingEnd( workStation:=ws) <br />DELAYED BY ProcessingStart.processingTime()</td></tr></tbody></table></td></tr><tr><td><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS2_RDM_ProcEnd.svg" /></td><td><table border="1"><thead><tr><th>ON pe:ProcessingEnd</th></tr></thead><tbody><tr><td>ws : WorkStation<br />ws := pe.workStation</td></tr><tr><td>ws.waitingParts.dequeue()<br />IF ws.waitingParts.length = 0 <br />THEN ws.status := AVAILABLE</td></tr><tr><td>IF ws.waitingParts.length &gt; 0 <br />THEN SCHEDULE ProcessingStart( workStation:=ws)</td></tr></tbody></table></td></tr></tbody></table></section></section></section><section class="role-chapter" id="index-2"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">3</span>. </span>Activity-Based Simulation</h1><p>Activity-Based Simulation is a form of Discrete Event Simulation where the concept of (typically, resource-constrained) activities is used in addition to the basic concept of instantaneous events.</p><section class="role-section1" id="index-3"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">3.1</span>. </span>Simple Activities</h2><p>A simple activity is an activity with zero or more participants, none of which is having a special meaning (such as being a resource or a processing object).</p><section class="role-section2" id="secCM"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">3.1.1</span>. </span>Conceptual Modeling of Simple Activities</h3><p>Conceptually, an activity is a composite event that is composed of, and temporally framed by, a pair of start and end events. Consequently, whenever a model contains a pair of related start and end event types, like <i>processing start</i> and <i>processing end </i>in the model of a manufacturing workstation shown on the left-hand side of <a class="role-figure-ref" href="#secCM__figWorkstationCIM"><span class="role-label">Figure <span class="role-number">3-1</span></span></a> and <a class="role-figure-ref" href="#secCM__figWorkstationCPM"><span class="role-label">Figure <span class="role-number">3-2</span></span></a>, they can be replaced with a corresponding activity type, like <i>processing</i>, as shown on the right-hand side.</p><figure class="threecells" id="secCM__figWorkstationCIM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-1</span>. </span>Introducing an activity type in a conceptual information model of a single workstation system.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS_CIM_2.svg" style="min-width:300px" width="400" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/RightArrow.svg" width="60" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS-Activity_CIM.svg" style="min-width:300px" width="400" /></div></figure><p>It is obvious that applying this replacement pattern leads to a conceptual and visual simplification of the models concerned.</p><figure class="threecells" id="secCM__figWorkstationCPM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-2</span>. </span>Introducing an activity type in a conceptual process model of a single workstation system.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS_CPM_2.svg" width="450" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/RightArrow.svg" width="60" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS-Activity_CPM.svg" width="400" /></div></figure></section><section class="role-section2" id="secDesM"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">3.1.2</span>. </span>Design Modeling of Simple Activities</h3><p>Like in a conceptual model, also in a design model, a pair of corresponding activity start Event and end Event circles, like <code>ProcessingStart</code> and <code>ProcessingEnd</code> in the source models shown in <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">3-3</span></span></a> and <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">3-4</span></span></a>, can be replaced with a corresponding Activity rectangle, like <code>Processing</code>, as in the target models shown in these figures.</p><section><h4>Extending basic OEM information design models by adding activity types</h4><figure class="threecells" id="secDesM__figWorkstationIDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-3</span>. </span>Going from basic OEM to OEM-A class models by introducing activity types.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS2_IDM_2.svg" style="min-width:300px" width="400" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/RightArrow.svg" width="60" /><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_IDM.svg" style="min-width:300px" width="400" /></div></figure><p>In the case of an information design model, this replacement pattern implies allocating all features (attributes, associations and operations) of the classes defining the start and the end event type in the class defining the corresponding activity type, possibly with renaming some of them. In the example of <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">3-3</span></span></a>, there is only one such feature: the class-level operation <code>ProcessingStart::processingTime</code>, which is allocated to <code>Processing</code> and renamed to <code>time</code>.</p></section><section id="secDesM__secAddingActivityRectanglesToPDMs"><h4>Extending basic DPMN process design diagrams by adding Activity rectangles</h4><figure id="secDesM__figWorkstationPDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-4</span>. </span>Going from basic DPMN to DPMN-A process models by introducing Activity rectangles.</figcaption><div style="display:flex; flex-direction: column"><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS2_PDM_2.svg" width="550" /></div><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/DownArrow.svg" width="30" /></div><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_PDM.svg" width="550" /></div></div></figure><p>In the case of a process design model, the replacement pattern implies that an Event circle pair consisting of an Event circle intended to represent activity start events and an Event circle intended to represent related activity end events, with an event scheduling arrow from the start to the end Event circle annotated by a delay expression, is replaced by an Activity rectangle such that:</p><ol><li>All Data Objects attached to the end Event circle get attached to the Activity rectangle (since an activity occurs when it it is completed).</li><li>All event scheduling arrows going out from the end Event circle are turned into event scheduling arrows going out from the Activity rectangle.</li><li>All start event scheduling arrows are replaced with corresponding activity scheduling arrows having an additional creation parameter assignment for the <em>duration</em> of a scheduled activity, which is set to the delay expression defined for the end event scheduling arrow. In the example above, the duration parameter in the annotation of the two activity scheduling arrows is set to <code>Processing::time()</code> in the target diagram, which is the same as the delay <code>ProcessingStart::processingTime</code> in the source diagram.</li><li>When the start Event circle has one or more attached Data Objects or any outgoing event scheduling arrow that does not go to the end Event circle, then a start Event circle has to be included in the Activity rectangle for attaching the Data Object(s) and as the source of the outgoing event scheduling arrow(s).</li></ol><p>This <em>Activity-Start-End Rewrite Pattern</em>, which can also be applied in the inverse direction, replacing an Activity rectangle with an Event circle pair, defines the meaning of an Activity rectangle in a DPMN diagram. It allows reducing a DPMN-A diagram with Activity rectangles to a basic DPMN diagram without Activity rectangles.</p><p>Notice that, like the source model, also the target model of <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">3-4</span></span></a> specifies three event rules:</p><ol><li>On each <em>PartArrival</em> event, the arrived part is added to the workstation's input buffer and if the workstation's status is AVAILABLE, then a new <i>Processing</i> activity is scheduled to start immediately with a duration provided by invoking the <i>time</i> function defined in the <i>Processing</i> activity class.</li><li>When a <em><i>Processing</i></em> activity starts, the workstation's status is changed to BUSY.</li><li>When a <em><i>Processing</i></em> activity ends, the processed part is removed from the input buffer and, if the input buffer is not empty, a new <i>Processing</i> activity is scheduled to start immediately, otherwise (if the input buffer is empty) the workstation's status is changed to AVAILABLE.</li></ol></section><section><h4>An alternative process design model of the single workstation system</h4><p>Based on the same information design model, shown in <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">3-3</span></span></a>, we can make another process design model of the single workstation system as an alternative to the target model of <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">3-4</span></span></a>. This alternative model makes it more clear that a workstation is, in fact, an exclusive resource of its processing activity. The concepts of resources and resource-constrained activities are discussed in the following sections, and in <a class="role-section2-ref" href="#secDesM-2"><span class="role-label">Section <span class="role-number">3.2.2</span></span></a>, it is shown how to simplify the basic DPMN model of <a class="role-figure-ref" href="#secDesM__figWS3PDM2"><span class="role-label">Figure <span class="role-number">3-5</span></span></a> by using the higher-level modeling elements introduced in DPMN-A.</p><figure id="secDesM__figWS3PDM2"><figcaption><span class="role-label">Figure <span class="role-number">3-5</span>. </span>Allocating the workstation as a resource of Processing activities</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_PDM2.svg" /></div></figure></section></section></section><section class="role-section1" id="index-4"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">3.2</span>. </span>Resource-Constrained Activities</h2><p>A <strong>Resource-Constrained Activity</strong> is an activity where one or more participants play a <em>Resource Role</em> (such as <em>Performer</em>). Typically, a resource-constrained activity is a component of a business process that happens in the context of an organization or organizational unit, which is associated with the activity as its <em>Process Owner</em>. </p><p>An activity of a certain type may require certain resources for being performable. At any point in time, a resource required for performing an activity may be <em>available</em> or not. A resource is not available, for instance, when it is is <em>busy</em> or when it is <em>out of order</em>.</p><aside class="rightbox40"><h3>Summary</h3><ol><li>A Resource-Constrained Activity can only be started when the required resources are available.</li><li>Which participants of a Resource-Constrained Activity of type <i>A</i> play the role of a resource is defined in an OE Class Diagram by special properties of <i>A</i>, called <em>Resource Roles</em>.</li><li><em>Resource (Cardinality) Constraints</em> are defined in an OE Class Diagram in the form of multiplicities of Resource Roles.</li><li>The resources that are available for being allocated to a planned activity are provided by <em>Resource Pools</em> managed by Process Owners. A Resource Pool is modeled in an OE Class Diagram as a collection-valued reference property of the object type representing the Process Owner.</li><li>A <em>Resource Type</em> is defined in an OE Class Diagram as a special object type that has a resource <em>status</em> attribute and is the range of both a Resource Role and a Resource Pool property.</li><li>A <em>Resource-Dependent Activity Start</em> arrow is a high-level modeling element of DPMN Process Diagrams, merging the semantics of event scheduling arrows with the Allocate-Release modeling pattern.</li><li>OEM-A extends basic OEM by adding activities, resource roles, resource cardinality constraints, resource pools, resource types and resource-dependent activity start arrows. Notice that most of these resource modeling elements are expressed in an OE Class Diagram, and only the possible event flows are expressed in a DPMN Process Diagram (representing an OEM process model) with the help of Resource-Dependent Activity Start arrows.</li></ol></aside><p>Resources are objects of a certain type. The resource objects of an activity include its <em>performer</em>, as expressed in the diagram shown in <a class="role-figure-ref" href="#index-4__figActRes"><span class="role-label">Figure <span class="role-number">3-6</span></span></a>. While in a conceptual model, describing a real-world system, a performer is required for any activity, a simulation design model may abstract away from the performer of an activity.</p><p>For instance, a consultation activity may require a consultant and a room. Such <em>resource cardinality constraints</em> are defined at the type level. When defining the activity type <code>Consultation</code>, these resource cardinality constraints are defined in the form of two mandatory associations with the object types <code>Consultant</code> and <code>Room</code> such that both associations' ends have the multiplicity 1 (&quot;exactly one&quot;). Then, in a simulation run, a new <code>Consultation</code> activity can only be started, when both a <code>Consultant</code> object and a <code>Room</code> object are available.</p><p>For all types of resource-constrained activities, a simulator can automatically collect the following statistics:</p><ol><li><i>Throughput</i> statistics: the numbers of enqueued and dequeued planned activities, and the numbers of started and completed activities.</li><li><i>Queue length</i> statistics (average, maximum, etc.) of its queue of planned activities.</li><li><i>Cycle time</i> statistics (average, maximum, etc.), where cycle time is the sum of the waiting time and the activity duration.</li><li><i>Resource utilization</i> statistics: the percentage of time each resource object involved is busy with an activity of that type.</li></ol><p>In addition, a simulator can automatically collect the percentage of time each resource object involved is idle or out-of-order.</p><figure id="index-4__figActRes"><figcaption><span class="role-label">Figure <span class="role-number">3-6</span>. </span>The resources required for performing an activity include the activity's performer.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/ResourceConstrained-Activities.svg" /></div></figure><p>For modeling resource-constrained activities, we need to define their types. As can be seen in <a class="role-figure-ref" href="#index-4__figIndividualsAndTypes"><span class="role-label">Figure <span class="role-number">3-7</span></span></a>, a resource-constrained activity type is composed of </p><ol><li>a set of <em>properties</em> and a set of <em>operations</em>, as any entity type,</li><li>a set of <strong>resource roles</strong>, each one having the form of a reference property with a name, an object type as range, and a multiplicity that may define a <strong>resource cardinality constraint</strong> like, e.g., &quot;exactly one resource object of this type is required&quot; or &quot;at least two resource objects of this type are required&quot;.</li></ol><p>The resource roles defined for an activity type may include the performer role.</p><figure id="index-4__figIndividualsAndTypes"><figcaption><span class="role-label">Figure <span class="role-number">3-7</span>. </span>Activity types may have special properties representing resource roles.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Types-with-ResourceRoles.svg" /></div></figure><p>These considerations show that a simulation language for simulating activities needs to allow defining activity types with two kinds of properties: ordinary properties and resource roles. At least for the latter ones, it must be possible to define multiplicities for defining resource cardinality constraints. These requirements are fulfilled by OE Class Diagrams where resource roles are defined as stereotyped properties using the stereotype «resource role» or, shorter, «res».</p><p>The extension of basic OEM by adding the concepts needed for modeling resource-constrained activities (in particular, resource roles with constraints, resource pools, and resource-dependent activity start arrows) is called <em>OEM-A</em>.</p><section class="role-section2" id="secCM-2"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">3.2.1</span>. </span>Conceptual Modeling of Resource-Constrained Activities</h3>Modeling resource-constrained activities has been a major issue in the field of Discrete Event Simulation (DES) since its inception in the nineteen-sixties, while it has been neglected and is still considered an advanced topic in the field of Business Process Modeling (BPM). The concept of resource-constrained activities is at the center of both DES and BPM. But both fields have developed different, and even incompatible, concepts of business process simulation.<p>In the DES paradigm of Processing Networks, Gordon (1961) has introduced the resource management operations <em>Seize</em> and <em>Release</em> in the simulation language GPSS for allocating and de-allocating (releasing) resources. Thus, GPSS has established a standard modeling pattern for resource-constrained activities, which has become popular under the name of <em>Seize</em>-<em>Delay</em>-<em>Release</em> indicating that for simulating a resource-constrained activity, its resources are first allocated, and then, after some delay (representing the duration of the simulated activity), they are de-allocated (released).</p><section id="secCM-2__secResPools"><h4>Resource roles, process owners and resource pools</h4><p>As an illustrative example, we consider a hospital consisting of medical departments where patients arrive for getting a medical examination performed by a doctor. A medical examination, as an activity, has three participants: a patient, a medical department, and a doctor, but only one of them plays a resource role: doctors. This can be indicated in an OE Class Diagram by using the stereotype «resource role» for categorizing the association ends that represent resource roles, as shown in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>.</p><figure id="secCM-2__figResRoles"><figcaption><span class="role-label">Figure <span class="role-number">3-8</span>. </span>A conceptual information model of the activity type &quot;examinations&quot; with resource roles.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep_CIM1.svg" width="500" /></div></figure><p>Notice that both the event type <em>patient arrivals</em> and the activity type <em>examinations</em> have a (mandatory functional) reference property <em>process owner</em>. This implies that both patient arrival events and examination activities happen at a specific medical department, which is their process owner in the sense that it owns the process types composed of them. A process owner is called &quot;Participant&quot; in BPMN (in the sense of a collaboration participant) and visually rendered in the form of a container rectangle called &quot;Pool&quot;.</p><p>In <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>, the resource role of doctors corresponds to the <em>performer</em> role. In BPMN, <em>Performer</em> is considered to be a special type of resource role. According to (BPMN 2011), a performer can be &quot;a specific individual, a group, an organization role or position, or an organization&quot;.<a class="role-footnote-ref" href="#__FN1" id="__FNR1">[1]</a>In BPMN, the performer role is specialized into the <em>HumanPerformer</em> of an activity, which is, in turn, specialized into <em>PotentialOwner</em> denoting the &quot;persons who can claim and work&quot; on an activity of a given type. &quot;A potential owner becomes the actual owner [...] by explicitly claiming&quot; an activity. Allocating a human resource to an activity by leaving the choice to those humans that play a suitable resource role is characteristic for workflow management systems, while in traditional DES approaches to resource handling, as in Arena and AnyLogic, (human) resources are assigned to a task (as its performer) based on certain policies.</p><p>One of the main reasons for considering certain objects as resources is the need to collect <em>utilization statistics</em> (either in an operational information system, like a workflow management system, or in a simulation model) by recording the use of resources over time (their <em>utilization</em>) per activity type. By designating resource roles in information models, these models provide the information needed in simulations and information systems for automatically collecting utilization statistics.</p><p>In the hospital example, a medical department, as the process owner, is the organizational unit that is responsible for reacting to certain events (here: patient arrivals) and managing the performance of certain processes and activities (here: medical examinations), including the allocation of resources to these processes and activities. For being able to allocate resources to activities, a process owner needs to manage <em>resource pools</em>, normally one for each resource role of each type of activity (if pools are not shared among resource roles). A resource pool is a collection of resource objects of a certain type. For instance, the three X-ray rooms of a diagnostic imaging department form a resource pool of that department.</p><p>Resource pools can be modeled in an OE Class Diagram by means of special associations between object classes representing process owners (like <em>medical departments</em>) and resource classes (like <em>doctors</em>), where the association ends, corresponding to collection-valued properties representing resource pools, are stereotyped with «resource pool», as shown in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>. At any point in time, the resource objects of a resource pool may be <em>out of order</em> (like a defective machine or a doctor who is not on schedule), <em>busy</em> or <em>available</em>.</p><p>A process owner has special procedures for allocating available resources from resource pools to activities. For instance, in the model of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>, a medical department has the procedure &quot;allocate a doctor&quot; for allocating a doctor to a medical examination. These resource allocation procedures may use various policies, especially for allocating human resources, such as first determining the suitability of potential resources (e.g., based on expertise, experience and previous performance), then ranking them and finally selecting from the most suitable ones (at random or based on their turn). See also (Arias et al 2018).</p><p>The conceptual process model shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label">Figure <span class="role-number">3-9</span></span></a> is based on the information model above. It refers to a medical department as the <em>process owner</em>, visualized in the form of a <em>Pool</em> container rectangle, and to <i>doctor objects</i>, as well as to the event type <i>patient arrivals</i> and to the activity type <i>examinations</i>.</p><figure id="secCM-2__figMedDepCPM1"><figcaption><span class="role-label">Figure <span class="role-number">3-9</span>. </span>A conceptual process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep_CPM1.svg" /></div></figure><p>This process model describes two causal regularities in the form of the following two event rules, each stated with two bullet points: one for describing all the state changes and one for describing all the follow-up events brought about by applying the rule.</p><ol><li><p>When a new patient arrives:</p><ul><li>if a doctor is available, then she is allocated to the examination of that patient; otherwise, a new planned examination is queued up;</li><li>if a doctor has been allocated, then start an examination of the patient.</li></ul></li><li><p>When an examination is completed by a doctor:</p><ul><li>if the queue of planned examinations is empty, then the doctor is released;</li><li>otherwise, the next planned examination by that doctor is scheduled to start immediately.</li></ul></li></ol><p>These conceptual event rules describe the real-world dynamics of a medical department according to business process management decisions. Changes of the waiting line and (de-)allocations of doctors are considered to be state changes (in the, not necessarily computerized, information system) of the department, as they are expressed in Data Object rectangles, which represent state changes of affected objects caused by an event in DPMN.</p><p>Notice that the model of <a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label">Figure <span class="role-number">3-9</span></span></a> abstracts away from the fact that after allocating a doctor, patients first need to walk to the room before their examination can start. Such a simplification may be justified if the walking time can be neglected or if there is no need to maximize the productive utilization of doctors who, according to this process model, have to wait until the patient arrives at the room. Below, this model is extended for allowing to allocate rooms and doctors such that patients have to wait for doctors, and not the other way around.</p></section><section><h4>Switching roles: doctors as patients</h4><p>The same person who is a doctor at a diagnostic imaging department may be treated as a patient of that department. It's a well-known fact that in the real world people may switch roles and may play several roles at the same time, but many modeling approaches/platforms fail to admit this. For instance, the simulation language (SIMAN) of the well-known DES modeling tool Arena does not treat resources and processing objects (&quot;entities&quot;) as roles, but as strictly separate categories. This language design decision was a meta-modeling mistake, as admitted by Denis Pegden, the main creator of SIMAN/Arena, in (Drogoul et al 2018) where he says &quot;it was a conceptualization mistake to view Entities and Resources as different constructs&quot;. </p><p>In <a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label">Figure <span class="role-number">3-10</span></span></a>, the above model is extended by categorizing the classes <i>doctors</i> and <i>patients</i> as «role type» classes and adding the «kind» class <i>people</i> as a supertype of <i>doctors</i> and <i>patients</i>, we create the possibility that a person may play both roles: the role of a doctor and the role of a patient, albeit not at the same time. The object type categories «kind» and «role type» have been introduced to conceptual modeling by Guizzardi (2005).</p><figure id="secCM-2__figKindsRoles"><figcaption><span class="role-label">Figure <span class="role-number">3-10</span>. </span>A conceptual information model with doctors and patients as people.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam_CM3.svg" /></div></figure></section><section><h4>Queueing planned activities</h4><p>Whenever an activity is to be performed but cannot start due to a required resource not being available, the <em>planned activity</em> is placed in a queue as a waiting job. Thus, in the case of a medical examination of a patient, as described in the model of <a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label">Figure <span class="role-number">3-10</span></span></a>, the <em>waiting line</em> represents, in fact, a queue of planned examinations (involving patients), and not a queue of waiting patients. </p><p>This consideration points to a general issue: modeling resource-constrained activities implies modeling queues of planned activities, while there is no need to consider (physical) queues of (physical) objects. Consequently, even if a real-world system includes a physical queue (of physical objects), an OEM-A model may abstract away from its physical character and consider it as a queue of planned activities (possibly including pre-allocated resources). While a physical queue implies that there is a maximum capacity, a queue of planned activities does not imply this. For instance, when a medical department does not require patients to queue up in a waiting area for obtaining an examination, but accepts their registration for an examination by phone, the resulting queue of waiting patients is not a physical queue (but rather a queue of planned examinations) and there is no need to limit the number of waiting patients in the same way as in the case of queuing up in a waiting area with limited space.</p><p>A planned activity can only start, when all required resources have been allocated to it. Thus, a planned examination of a patient can only start, when both a room and a doctor have been allocated to it. Let's assume that when a patient <i>p</i> arrives, only a room is available, but not a doctor. In that case, the available room is allocated to the planned examination, which is then placed in a queue since it still has to wait for the availability of a doctor. Only when a doctor becomes available, e.g., via the completion of an examination of another patient or via an arrival of a doctor, the doctor can be allocated as the last resource needed to start the planned examination of patient <i>p</i>. </p><p>As a consequence of these considerations, the <em>waiting line</em> of a medical department modeled in <a class="role-figure-ref" href="#secCM-2__figKindsRoles"><span class="role-label">Figure <span class="role-number">3-10</span></span></a> as an ordered collection of patients is renamed to <em>planned walks</em> in <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a>. In addition, a property <em>planned examinations</em>, which holds an ordered collection of patient-room pairs, is added to the class <em>medical departments</em>. These model elements reflect the hospital's business process practice to maintain a list of patients waiting for the allocation of a room to walk to and a list of planned examinations, each with a patient waiting for a doctor in an examination room.</p></section><section><h4>Decoupling the allocation of multiple resources</h4><p>For being more realistic, we consider the fact that patients first need to be walked by nurses to the room allocated to their examination before the examination can start. Thus, in the model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a>, we add a second activity type, <em>walks to room</em>, involving people (typically, nurses and patients) walking to an examination room. </p><figure id="secCM-2__figMedDepCIM4"><figcaption><span class="role-label">Figure <span class="role-number">3-11</span>. </span>Adding the activity type &quot;walks to room&quot; to the conceptual information model.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam_CIM4.svg" /></div></figure> <figure id="secCM-2__figMedDepCPM2"><figcaption><span class="role-label">Figure <span class="role-number">3-12</span>. </span>A conceptual process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a>.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep_CPM2.svg" /></div></figure><p>This process model describes three causal regularities in the form of the following three event rules:</p><ol><li><p>When a new patient arrives:</p><ul><li>if a room and a nurse are available, they are allocated to the walk of that patient to that room, otherwise a new planned walk is placed in the corresponding queue;</li><li>if a room has been allocated, then the nurse starts walking the patient to the room.</li></ul></li><li><p>When a walk of a patient and nurse to a room is completed:</p><ul><li>if there is still a planned walk in the queue and a room is available, then the room is allocated and the nurse is re-allocated to the walk of the next patient to that room.<br />if a doctor is available, she is allocated to the examination of that patient, else a new planned examination of that patient is queued up;</li><li>if a doctor has been allocated, then the examination of that patient starts<br />if the nurse has been re-allocated, she starts walking the next patient to the allocated room.</li></ul></li><li><p>When an examination of a patient is completed by a doctor in a particular room:</p><ul><li>if there is still a planned examination (of another patient in another room), then re-allocate the doctor to that planned examination, else release the doctor;<br />if the waiting line is not empty, re-allocate the room to the next patient, else release the room;</li><li>if the doctor has been re-allocated to a planned examination, that examination starts;<br />if the room has been re-allocated to another patient, that patient starts walking to the room.</li></ul></li></ol><p>Notice that the process type described in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM2"><span class="role-label">Figure <span class="role-number">3-12</span></span></a> does not consider the fact that doctors have to walk to the examination room too, which could be modeled by adding a <em>doctors' walks to room</em> Activity rectangle after the patients' <em>walks to room</em> Activity rectangle.</p><p>For being able to collect informative utilization statistics, it is required to distinguish the total time a resource is allocated (its 'gross utilization') from the time it is allocated for productive activities (its 'net utilization'). Thus, only <em>examinations</em> would be classified as productive activities, while <em>walks to room</em> would rather be considered a kind of set-up activities.</p><section><h4>Re-engineering the process type by centralizing the re-allocation of resources</h4><p>In the process type described in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM2"><span class="role-label">Figure <span class="role-number">3-12</span></span></a>, the re-allocation of released resources is handled in the event rules of activity end events:</p><ul><li>when a nurse's and patient's walk to a room ends, the nurse is free to be re-allocated; so if there is another planned walk and a room is available, the nurse is re-allocated to a walk of the next patient to that room;</li><li>when an examination ends, its resources (a doctor and a room) are re-allocated, if planned activities are waiting for them.</li></ul><p>This approach requires that the same re-allocation logic is repeated in the event rules of all activity types associated with that type of resource, implying that all performers involved would have to know and execute the same re-allocation logic. It is clearly preferable to centralize this logic in a single event rule, which can be achieved by introducing <em>release resource request</em> events following activities that do not need to keep resources allocated, as shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM3"><span class="role-label">Figure <span class="role-number">3-13</span></span></a> where the re-allocation of doctors and rooms is decoupled from the examination activities and centralized (e.g., in a special resource management unit) by adding the two event types <em>room release requests</em> and <em>doctor release requests</em> modeling simultaneous events that follow examinations.</p><figure id="secCM-2__figMedDepCPM3"><figcaption><span class="role-label">Figure <span class="role-number">3-13</span>. </span>An improved process model based on the information model of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a>.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep_CPM3.svg" /></div></figure><p>This process model describes an improved business process with six event rules:</p><ol><li><p>When a new patient arrives:</p><ul><li>if a room and a nurse are available, they are allocated to the walk of that patient to that room, otherwise a new planned walk is placed in the corresponding queue;</li><li>if a room has been allocated, then the nurse starts walking the patient to the room.</li></ul></li><li><p>When a walk of a patient and nurse to a room is completed:</p><ul><li>if a doctor is available, she is allocated to the examination of that patient, else a new planned examination of that patient is queued up;</li><li>if a doctor has been allocated, then the examination of that patient starts; in addition, a nurse release request is issued.</li></ul></li><li><p>When a nurse release request has been issued:</p><ul><li>if the waiting line is not empty and a room is available, allocate the room and re-allocate the nurse to the next patient, else release the nurse;</li><li>if the nurse has been re-allocated to another patient, she starts walking that patient to the room.</li></ul></li><li><p>When an examination is completed:</p><ul><li>[no state change]</li><li>a room release request is issued (e.g., by notifying a resource management clerk or the department's information system), and, in parallel, a doctor release request is issued.</li></ul></li><li><p>When a room release request is received by a resource manager:</p><ul><li>if the waiting line is not empty and a nurse is available, allocate the nurse and re-allocate the room to the next patient, else release the room;</li><li>if the room has been re-allocated to another patient, the nurse starts walking that patient to the room.</li></ul></li><li><p>When a doctor release request is received by a resource manager:</p><ul><li>if there is still a planned examination (of another patient in another room), then re-allocate the doctor to that planned examination, else release the doctor;</li><li>if the doctor has been re-allocated to a planned examination, that examination starts.</li></ul></li></ol><p>Notice that, in the general case, instead of scheduling several simultaneous release requests, each for a single resource, when an activity completes, a single joint release request for all used resources should be scheduled, allowing to re-allocate several of the released resources jointly.</p></section><section><h4>Displaying the process owner and activity performers</h4><p>The process owner and the involved performers can be displayed in an OEM process model by using a rectangular <em>Pool</em> container for the process owner and Pool partitions called <em>Lanes</em> for the involved activity performers, as shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">3-14</span></span></a>. Notice that, as opposed to BPMN, where lanes do not have a well-defined meaning, but can be used for any sort of arranging model elements, DPMN Lanes represent organizational actors playing the resource role of <em>performer</em>.</p><figure id="secCM-2__figMedDepCPM4"><figcaption><span class="role-label">Figure <span class="role-number">3-14</span>. </span>Displaying the process owner and activity performers in a conceptual process model.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep_CPM4.svg" /></div></figure></section><section id="secCM-2__secNonExclusiveRes"><h4>Non-exclusive resources</h4><p>In OEM, a resource is exclusive by default, that is, it can be used in at most one activity at the same time, if no <em>parallel participation</em> multiplicity is specified. For instance, in all information models above (e.g., in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>), the participation associations between the resource classes <i>rooms</i> and <i>doctors</i> and the activity classes <i>walks to room</i> and <i>examinations</i> do not specify any <em>parallel participation</em> multiplicity (for the association end at the side of the activity class), but just the common (historical participation) multiplicity of &quot;*&quot; expressing that resources participate in zero or more activities over time (without an upper bound).</p><p>OEM extends UML Class Diagrams by adding the association end stereotype «parallel» for expressing <em>parallel participation</em> multiplicities.</p><p>A non-exclusive resource can be simultaneously used in more than one activity. The maximum number of activities, in which a non-exclusive resource can participate at the same time, is normally specified at the type level for all resource objects of that type using the upper bound of a parallel participation multiplicity. In general, there may be cases where it should be possible to specify this at the level of individual resource objects. For instance, larger examination rooms may accommodate more examinations than smaller ones.</p><p>A resource can be exclusive with respect to all types of activities (which is the default case) or it can be exclusive with respect to specific types of activities. For instance, in the model of <a class="role-figure-ref" href="#secCM-2__figExclusiveResByType"><span class="role-label">Figure <span class="role-number">3-15</span></span></a>, a parallel participation multiplicity of 0..1 is defined both for the participation of rooms in walks and in examinations. This means a room can participate in at most one walk and in at most one examination at the same time, which is a different business rule, allowing to walk patients to a room even if it is currently used for an examination, compared to the model of <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a>, allowing to walk patients to a room only if it is currently not being used for an examination.</p><figure id="secCM-2__figExclusiveResByType"><figcaption><span class="role-label">Figure <span class="role-number">3-15</span>. </span>Adding parallel participation multiplicities for rooms participating both in walks and examinations at the same time.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam_CIM5.svg" width="500" /></div></figure></section></section></section><section class="role-section2" id="secDesM-2"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">3.2.2</span>. </span>Resource-Constrained Activities in Simulation Design Models</h3><p>In simulation design models, resource-constrained activities can be modeled in two ways: </p><ol><li>either abstracting away from the structure of resource object types and individual resource objects, and only representing a resource object type in the form of a named resource pool with a quantity (or <em>counter</em>) attribute holding the number of available resources, or</li><li>explicitly representing resource object types and individual resource objects of that type as members of a collection representing a resource pool.</li></ol><p>While the first approach is simpler, the second approach allows modeling various kinds of non-availability of specific resources (e.g., due to failures or due to not being in the shift plan).</p><p>For any resource object type <i>Res</i>, the three operations described in the following table <a href="#secDesM-2__tblResManOps"></a> are needed.</p><table border="1" id="secDesM-2__tblResManOps"><thead><tr><th>Resource management operation</th><th>General meaning</th><th>Resource counter approach</th><th>Resource pool approach</th></tr></thead><tbody><tr><th><i>isResAvailable</i></th><td>test if a resource of type <i>Res</i> is available and return <i>true</i> or <i>false</i></td><td>test if the corresponding resource counter attribute has a value that is greater than 0</td><td>test if the number of available resource objects in the resource pool is greater than 0</td></tr><tr><th><i>allocateRes</i></th><td>allocate a resource object of type <i>Res</i></td><td>decrement resource counter attribute</td><td>select (and return) a resource object from the set of available resource objects in the resource pool (using an allocation policy) and designate it as BUSY</td></tr><tr><th><i>releaseRes</i></th><td>de-allocate a resource object of type <i>Res</i></td><td>increment resource counter attribute</td><td>take a resource object of type <i>Res</i> as argument and designate it as AVAILABLE</td></tr></tbody></table><p>In both approaches, it is natural to add these operations to the object type representing the process owner of the activities concerned, as in the models shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">3-16</span></span></a> and <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a>.</p><p>In the first approach, for each resource object type in the conceptual model, a resource counter attribute is added to the object type representing the process owner and the conceptual model's resource object types are dropped.</p><p>In the second approach, the conceptual model's resource object types are elaborated by adding an enumeration attribute <em>status</em> holding a resource status value such as AVAILABLE or BUSY. For each resource object type, a collection-valued property (such as <em>rooms</em> or <em>doctors</em>) representing a resource pool is added to the object type representing the process owner.</p><section><h4>A simple model with resource counters</h4><p>Using the conceptual information model shown in <a class="role-figure-ref" href="#secCM-2__figResRoles"><span class="role-label">Figure <span class="role-number">3-8</span></span></a> as a starting point, we first rename all classes and properties according to OO naming conventions and replace each of the two (conceptual) operations <em>allocate a room</em> and <em>allocate a doctor</em> with a triple of <i>isAvailable</i>/<i>allocate</i>/<i>release</i> operations for the two resource object classes <em>Room</em> and <em>Doctor</em> in the <em>MedicalDepartment</em> class, where we also add the counter attributes <em>nmrOfRooms</em> and <em>nmrOfDoctors</em>. Then, the two resource object classes <em>Room</em> and <em>Doctor</em> are dropped. The result of this elaboration is the information design model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">3-16</span></span></a>.</p><figure id="secDesM-2__figMedDep1IDM1"><figcaption><span class="role-label">Figure <span class="role-number">3-16</span>. </span>An information model for the simplified design with the resource counters nmrOfRooms and nmrOfDoctors.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam1_IDM1.svg" /></div></figure><p>Using the conceptual process model shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM1"><span class="role-label">Figure <span class="role-number">3-9</span></span></a> as a starting point and based on the type definitions of the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">3-16</span></span></a>, we get the following process design.</p><figure id="secDesM-2__figMedDep1PDM1"><figcaption><span class="role-label">Figure <span class="role-number">3-17</span>. </span>A process design model based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM1"><span class="role-label">Figure <span class="role-number">3-16</span></span></a>.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep1_PDM1.png" /></div></figure><p>This process model defines the following two event rules. </p><table border="1"><thead><tr><th>ON pa: PatientArrival</th></tr></thead><tbody><tr><td>md : MedicalDepartment <br />resAllocated : Boolean<br />md := pa.medicalDepartment</td></tr><tr><td>IF md.isRoomAvailable() AND md.isDoctorAvailable()<br />THEN md.allocateRoom(); md.allocateDoctor(); resAllocated := true<br />ELSE md.waitingPatients.push( pa.patient); resAllocated := false</td></tr><tr><td>IF resAllocated SCHEDULE Examination( patient:=pa.patient, medicalDepartment:=md)</td></tr></tbody></table><table border="1"><thead><tr><th>ON ex: Examination</th></tr></thead><tbody><tr><td>md : MedicalDepartment <br />anotherPatientFetched : Boolean<br />p: Patient<br />md := ex.medicalDepartment</td></tr><tr><td>IF md.waitingPatients.length = 0<br />THEN md.releaseRoom(); md.releaseDoctor(); anotherPatientFetched := false<br />ELSE p := md.waitingPatients.pop(); anotherPatientFetched := true</td></tr><tr><td>IF anotherPatientFetched SCHEDULE Examination( patient:=p, medicalDepartment:=md)</td></tr></tbody></table><p>Notice that the event scheduling arrows of <a class="role-figure-ref" href="#secDesM-2__figMedDep1PDM1"><span class="role-label">Figure <span class="role-number">3-17</span></span></a>, and also the SCHEDULE statements of the corresponding event rule tables, do not contain assignments of the duration of activities, since it is assumed that, by default, whenever an activity type has an operation <em>duration()</em>, the duration of activities of this type are assigned by invoking this operation.</p></section><section><h4>A general model with resource objects as members of resource pools</h4><p>In a more general approach, instead of using resource counter attributes, explicitly modeling resource object classes (like <em>Room</em> and <em>Doctor</em>) allows representing resource roles (stereotyped with «res») and resource pools (stereotyped with «pool») in the form of collections (like <em>md.rooms</em> and <em>md.doctors</em>) and modeling various forms of non-availability of resources (such as machines being defective or humans not being in the shift plan) with the help of corresponding resource status values (such as OUT_OF_ORDER). The result of this elaboration is the information design model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a>.</p><figure id="secDesM-2__figMedDep1IDM2"><figcaption><span class="role-label">Figure <span class="role-number">3-18</span>. </span>An OEM-A class model with resource object types for modeling resource roles and pools.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam1_IDM2.svg" /></div></figure><p>For an OEM-A class model, like the one shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a>, the following completeness constraint must hold: when an object type <i>O</i> (like <i>Doctor</i>) participates in a «res» association (a resource role association) with an activity type <i>A</i> (like <i>Examination</i>), the process owner object type of <i>A</i> (<i>MedicalDepartment</i>) must have a «pool» association with <i>O</i>.</p><figure id="secDesM-2__figMedDep1PDM2"><figcaption><span class="role-label">Figure <span class="role-number">3-19</span>. </span>A process design model based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a>.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep1_PDM2.png" /></div></figure></section><section><h4>Extending OE Class Diagrams by adding a «resource type» category</h4><p>The information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a> contains two object types, <i>Room</i> and <i>Doctor</i>, which are the range of resource role and resource pool properties (association ends stereotyped «res» and «pool»). Such object types can be categorized as «resource type» with the implied meaning that they inherit a resource status attribute from a pre-defined class <code>Resource</code>, as shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM3"><span class="role-label">Figure <span class="role-number">3-21</span></span></a>.</p><figure id="secDesM-2__lof__36"><figcaption><span class="role-label">Figure <span class="role-number">3-20</span>. </span>Any resource type <i>R</i> extends the pre-defined object type <code>Resource</code></figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/Resource-Object.svg" /></div></figure><p>The introduction of resource types to OEM class models allows simplifying models by dropping the following modeling items from OEM-A class models, making them part of the implicit semantics:</p><ol><li>the <i>status</i> attributes of object types representing resource types, which are implicitly inherited;</li><li>the pre-defined enumeration <i>ResourceStatusEL</i>;</li><li>the resource management operations <i>isAvailable</i>, <i>allocate</i> and <i>release</i>, which are implicitly inherited by any resource type; and</li><li>the planned activity queues may possibly be implicitly represented for any resource-constrained activity type in the form of ordered multi-valued reference properties of its process owner object type.</li></ol> This is shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM3"><span class="role-label">Figure <span class="role-number">3-21</span></span></a>.<figure id="secDesM-2__figMedDep1IDM3"><figcaption><span class="role-label">Figure <span class="role-number">3-21</span>. </span>A simplified version of the model of <a class="role-figure-ref" href="#secDesM-2__figMedDep1IDM2"><span class="role-label">Figure <span class="role-number">3-18</span></span></a> </figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam1-DM3.svg" /></div></figure></section><section id="secDesM-2__RevisitingManufacturingWS"><h4>Revisiting the manufacturing workstation example</h4><p>A manufacturing workstation, or a &quot;server&quot; in the terminology of Operation Research, represents a resource for the processing activities performed at/by it. This was left implicit in the OEM-A class model shown on the right-hand side of <a class="role-figure-ref" href="#secDesM__figWorkstationIDM"><span class="role-label">Figure <span class="role-number">3-3</span></span></a>. Using the new modeling elements (resource types, resource roles and resource pools), the processing activities of a workstation can be explicitly modeled as resource-constrained activities, leading to the OEM-A class model shown in <a class="role-figure-ref" href="#secDesM-2__figWS3IDM3"><span class="role-label">Figure <span class="role-number">3-22</span></span></a> and to a more high-level and more readable process model compared to the process model of <a class="role-figure-ref" href="#secDesM__figWorkstationPDM"><span class="role-label">Figure <span class="role-number">3-4</span></span></a>. </p><figure id="secDesM-2__figWS3IDM3"><figcaption><span class="role-label">Figure <span class="role-number">3-22</span>. </span>An OE Class Diagram modeling a single workstation system with resource-constrained processing activities </figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_IDM3.svg" /></div></figure></section><section><h4>Decoupling the allocation of multiple resources</h4><p>In a simplified simulation design for the extended scenario (with patients and nurses first walking to examination rooms before doctors are allocated for starting the examinations) described by the conceptual models of <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a> and <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">3-14</span></span></a>, we do not consider the walks of doctors, but only the walks of nurses and patients. For simplicity, we drop the superclass <i>people</i> and associate the activity type <i>WalkToRoom</i> with the <i>Patient</i> and Nurse classes. The result of this elaboration is the information design model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label">Figure <span class="role-number">3-23</span></span></a>.</p><figure id="secDesM-2__figMedDep2IDM2"><figcaption><span class="role-label">Figure <span class="role-number">3-23</span>. </span>An information design model for decoupling the allocation of rooms and doctors.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam2_IDM2.svg" /></div></figure><figure id="secDesM-2__figMedDep2PDM1"><figcaption><span class="role-label">Figure <span class="role-number">3-24</span>. </span>A process design model based on the information design model of <a class="role-figure-ref" href="#secDesM-2__figMedDep2IDM2"><span class="role-label">Figure <span class="role-number">3-23</span></span></a>.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep2_PDM1.png" /></div></figure><p>This process design model defines three event rules. Notice that the <i>Examination</i> event rule either re-allocates the doctor to the next planned examination and schedules it, if there is one, or it releases the doctor and re-allocates the room to the next planned walk-to-room and schedules it, if there is one.</p><p></p></section><section><h4>Centralizing the re-allocation of resources</h4><p>As shown before, in the conceptual process models of <a class="role-figure-ref" href="#secCM-2__figMedDepCPM3"><span class="role-label">Figure <span class="role-number">3-13</span></span></a> and <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">3-14</span></span></a>, the re-allocation of resources can be centralized with the help of resource release request events and the process owner and the involved performers can be displayed by using a Pool that is partitioned into Lanes for the involved activity performers, resulting in the model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label">Figure <span class="role-number">3-25</span></span></a>.</p><figure id="secDesM-2__figMedDep4PDM1"><figcaption><span class="role-label">Figure <span class="role-number">3-25</span>. </span>Representing the process owner as a Pool and activity performers as Lanes in a process design model.</figcaption><div><img src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep4_PDM1.png" /></div></figure></section></section><section class="role-section2" id="secAllocateReleasePattern"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">3.2.3</span>. </span>The Allocate-Release Modeling Pattern</h3><p>The conceptual process model shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">3-14</span></span></a> and the process design model shown in <a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label">Figure <span class="role-number">3-25</span></span></a> exhibit a general pattern for modeling a sequence of two resource-constrained activities of types <i>A</i><sub>1</sub> and <i>A</i><sub>2</sub> shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">3-26</span></span></a>. For describing this pattern, we assume that </p><ol><li>the process owner maintains queues for planned activities: <i>q</i><sub>1</sub> for for planned activities of type <i>A</i><sub>1</sub>, and <i>q</i><sub>2</sub> for planned activities of type <i>A</i><sub>2</sub>, both defined as queue-valued (i.e., ordered multi-valued) reference properties of the process owner in the underlying information model;</li><li>the underlying information model specifies the sets of resources <i>R</i><sub>1</sub> and <i>R</i><sub>2</sub> required by <i>A</i><sub>1</sub> and <i>A</i><sub>2</sub>,</li><li>the set of resources required by <i>A</i><sub>2</sub> but not by <i>A</i><sub>1</sub> is denoted by <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub>;</li><li>the set of resources required by <i>A</i><sub>1</sub> and by <i>A</i><sub>2</sub> is denoted by <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub>.</li></ol><figure id="secAllocateReleasePattern__figAllocRelPatternCPM"><figcaption><span class="role-label">Figure <span class="role-number">3-26</span>. </span>A conceptual modeling pattern for a sequence of resource-constrained activities</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/AllocRelPattern_CPM.svg" /></div></figure><p>We can describe the algorithm of the <em>Allocate-Release Modeling Pattern</em> for the case of a sequence of two resource-constrained activities in the following way:</p><ol><li>ON <i>start event</i>:<ol type="a"><li>If the resources <i>R</i><sub>1</sub> required by <i>A</i><sub>1</sub> are available, they are allocated; otherwise, a planned <i>A</i><sub>1</sub> activity is added to the queue <i>q</i><sub>1</sub>.</li><li>If the resources <i>R</i><sub>1</sub> have been allocated, a new activity of type <i>A</i><sub>1</sub> is started.</li></ol></li><li>WHEN <i>an activity of type <i>A</i><sub>1</sub></i> completes:<ol type="a"><li>The resources <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> are allocated, if they are available; otherwise, a planned <i>A</i><sub>2</sub> activity with reserved resources <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> is added to <i>q</i><sub>2</sub>.</li><li>If <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> have been allocated, a new activity of type <i>A</i><sub>2</sub> is started. In addition, an immediate release request for <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> is caused/scheduled.</li></ol></li><li>ON <i>release request</i> for <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub>:<ol type="a"><li>If <i>q</i><sub>1</sub> is not empty and the resources <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> required by both <i>A</i><sub>1</sub> and <i>A</i><sub>2</sub> are available, they are allocated and <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> are re-allocated to head( <i>q</i><sub>1</sub>); otherwise, <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> are released.</li><li>If the resources <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> have been re-allocated, a new activity of type <i>A</i><sub>1</sub> is started.</li></ol></li><li>WHEN <i>an activity of type <i>A</i><sub>2</sub></i> completes:<ol type="a"><li>There is no state change.</li><li>An immediate release request for <i>R</i><sub>2</sub> is caused/scheduled.</li></ol></li><li>ON <i>release request</i> for <i>R</i><sub>2</sub>:<ol type="a"><li>If <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> is nonempty: if <i>q</i><sub>1</sub> is not empty and the resources <i>R</i><sub>1</sub>−<i>R</i><sub>2</sub> required by <i>A</i><sub>1</sub>, but not yet allocated, are available, they are allocated and <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> are re-allocated to head(<i> q</i><sub>1</sub>); otherwise, <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> are released. If <i>q</i><sub>2</sub> is not empty, then re-allocate <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> to head(<i> q</i><sub>2</sub>); otherwise, <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> are released.</li><li>If <i>R</i><sub>1</sub>∩<i>R</i><sub>2</sub> have been re-allocated, a new activity of type <i>A</i><sub>1</sub> is started. If <i>R</i><sub>2</sub>−<i>R</i><sub>1</sub> have been re-allocated, a new activity of type <i>A</i><sub>2</sub> is started.</li></ol></li></ol><section><h4>New modeling elements for expressing the Allocate-Release Modeling Pattern</h4><p>Since the Allocate-Release Modeling Pattern defines a generic algorithm for allocating and releasing resources, its (pseudo-)code does not have to be included in a DPMN Process Diagram, but can be delegated to an OE simulator supporting the resource-dependent scheduling of resource-constrained activities according to this pattern. This approach allows introducing new DPMN modeling elements for expressing the Allocate-Release Modeling Pattern in a concise way, either leaving allocate-release steps completely implicit, as in the DPMN Process Diagram of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">3-27</span></span></a>, or explicitly expressing them, as in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">3-28</span></span></a>.</p><p>The most important new DPMN modeling element introduced are <em>resource-dependent causation (</em>resp., <em>activity start</em>) arrows pointing to resource-constrained activities, as in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">3-27</span></span></a>. These arrows are high-level modeling elements representing the implicit allocate-release logic exhibited in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">3-26</span></span></a>. Thus, the meaning of the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">3-27</span></span></a> is provided by the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">3-26</span></span></a>.</p><figure id="secAllocateReleasePattern__figAllocRelPatternPDM2"><figcaption><span class="role-label">Figure <span class="role-number">3-27</span>. </span>Using <em>resource-dependent activity start</em> arrows in a conceptual process model.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/AllocRelPattern_PDM2.svg" width="400" /></div></figure><p>It is an option to display the implicit allocate-release steps with <i>Allocate</i> and <i>Release</i> rectangles together with <em>simple control flow</em> arrows, as between the <i>start event</i> circle and the <i>Allocate R1</i> rectangle in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">3-28</span></span></a>.</p><figure id="secAllocateReleasePattern__figAllocRelPatternPDM1"><figcaption><span class="role-label">Figure <span class="role-number">3-28</span>. </span>Displaying the implicit allocate-release steps.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/AllocRelPattern_PDM1.svg" width="600" /></div></figure><p>The meaning of the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">3-28</span></span></a> is the same as that of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM2"><span class="role-label">Figure <span class="role-number">3-27</span></span></a>, which is provided by the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternCPM"><span class="role-label">Figure <span class="role-number">3-26</span></span></a>. The fact that, using <em>resource-dependent activity start</em> arrows, the allocate-release logic of resource-constrained activities does not have to be explicitly modeled and displayed in an OEM process model shows the power of founding a process model on an information model, since the entire resource management logic can be expressed in terms of resource roles, constraints and pools in an OEM information model. This is in contrast to the common approach of industrial simulation tools, such as Simio and AnyLogic, which require defining resource roles, constraints and pools as well as explicit allocate-release steps in the process model, in a similar way as shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figAllocRelPatternPDM1"><span class="role-label">Figure <span class="role-number">3-28</span></span></a>.</p><p>Using resource-dependent activity start arrows in a process model implies using their standard allocate-release logic according to which required resources that have not been allocated before are allocated immediately before an activity requiring them is started and released immediately after this activity is completed if they are not required by the next activity. Whenever another (non-standard) resource allocation logic is needed, it has to be expressed explicitly using ordinary event scheduling arrows.</p></section><section><h4>Simplifying the workstation process model</h4><p>We can now simplify the workstation model using the resource type category for <i>WorkStation</i> in the OEM class model and a resource-dependent activity start arrow from the arrival event to the processing activity in the DPMN process model. The resulting class model is shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2IdmRewrite"><span class="role-label">Figure <span class="role-number">3-31</span></span></a>.</p><figure id="secAllocateReleasePattern__figWS3IDM3"><figcaption><span class="role-label">Figure <span class="role-number">3-29</span>. </span>Modeling WorkStation as a resource type</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_IDM3.svg" /></div></figure><p>The simplification of the process model of <a class="role-figure-ref" href="#secDesM__figWS3PDM2"><span class="role-label">Figure <span class="role-number">3-5</span></span></a> results in the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figWS3PDM3"><span class="role-label">Figure <span class="role-number">3-30</span></span></a>.</p><figure id="secAllocateReleasePattern__figWS3PDM3"><figcaption><span class="role-label">Figure <span class="role-number">3-30</span>. </span>A simplified version of the workstation process model using a resource-dependent activity start arrow.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_PDM3.svg" width="270" /></div></figure></section><section><h4>Simplifying the medical department process model</h4><p>We can now simplify the medical department model using the resource type category for <i>Doctor</i>, <i>Room</i> and <i>Nurse</i> in the OEM class model and resource-dependent activity start arrows in the DPMN process model. The resulting class model is shown in <a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2IdmRewrite"><span class="role-label">Figure <span class="role-number">3-31</span></span></a>.</p><figure id="secAllocateReleasePattern__figMedDep2IdmRewrite"><figcaption><span class="role-label">Figure <span class="role-number">3-31</span>. </span>A simplified version of the medical department information model with Doctor and Room as resource types</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedExam2_IDM2.svg" /></div></figure><p>The simplification of the rather complex process model of <a class="role-figure-ref" href="#secDesM-2__figMedDep4PDM1"><span class="role-label">Figure <span class="role-number">3-25</span></span></a> by using resource-dependent activity start arrows results in the model of <a class="role-figure-ref" href="#secAllocateReleasePattern__figMedDep2PdmRewrite"><span class="role-label">Figure <span class="role-number">3-32</span></span></a>.</p><figure id="secAllocateReleasePattern__figMedDep2PdmRewrite"><figcaption><span class="role-label">Figure <span class="role-number">3-32</span>. </span>A simplified version of the medical department process model using resource-dependent activity start arrows.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/MedDep4_PDM2.svg" width="500" /></div></figure></section></section></section></section><section class="role-chapter" id="index-5"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">4</span>. </span>Processing Activities and Processing Networks</h1><p>A <em>Processing Activity</em> is a resource-constrained activity that takes one or more objects as inputs and processes them in some way (possibly transforming them). The processed objects have been called &quot;transactions&quot; in GPSS and &quot;entities&quot; in SIMAN/Arena, while they are called <em>processing objects</em> in DPMN. </p><p>Ontologically, there are one or more objects participating in an activity, as shown in <a class="role-figure-ref" href="#index-5__figProcObjects"><span class="role-label">Figure <span class="role-number">4-1</span></span></a>. Some of them represent resources, while others represent processing objects. For instance, in the information and process models of a medical department shown in <a class="role-figure-ref" href="#secCM-2__figMedDepCIM4"><span class="role-label">Figure <span class="role-number">3-11</span></span></a> and <a class="role-figure-ref" href="#secCM-2__figMedDepCPM4"><span class="role-label">Figure <span class="role-number">3-14</span></span></a>, there are two processing activity types: <em>walks to room</em> and <em>examinations</em>. In <em>walks to room</em>, since nurses are walking patients to examination rooms, nurses and rooms are resources, while patients are processing objects. In <em>examinations</em>, doctors and rooms are resources, while patients are processing objects. If patients would walk to an examination room by themselves (without the help of a nurse), patients would be the performers of walks to a room, and not processing objects, and, consequently, walks to a room would not be processing activities.</p><figure id="index-5__figProcObjects"><figcaption><span class="role-label">Figure <span class="role-number">4-1</span>. </span>Resource-constrained activities involving processing objects are processing activities.</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Processing-Activities.svg" /></div></figure><p>Processing activities typically require immobile physical resources, like rooms or workstation machines, which define the inner nodes of a <em>Processing Network (PN)</em>. A <em>Processing Object</em> enters such a network via an <em>Arrival</em> event at an <em>Entry Node</em>, is subsequently routed along a chain of <em>Processing Nodes</em> where it is subject to <em>Processing Activities</em>, and finally exits the network via a <em>Departure</em> event at an <em>Exit Node</em>. </p><aside class="rightbox40"><h2>Summary</h2><ol><li>A <em>Processing Object</em> enters a <em>Processing Network (PN)</em> via an <em>Arrival</em> event at an <em>Entry Station</em>, is subsequently routed along a chain of <em>Processing Stations</em> where it is subject to <em>Processing Activities</em>, and finally exits the PN via a <em>Departure</em> event at an <em>Exit Station</em>.</li><li>PNs have been investigated in <em>operations management</em> and the mathematical theory of queuing (Loch 1998, Williams 2016) and have been the application focus of most industrial simulation software products, historically starting with GPSS (Gordon 1961) and SIMAN/Arena (Pegden and Davis 1992).</li><li>OEM-PN allows modeling many forms of discrete <i>processing processes</i>.</li><li>PN models are <em>spatial</em> simulation models where node objects, and other resource objects, are located in space and processing objects move (or <em>flow</em>) in space.</li><li>Each node definition in a PN model defines both a spatial object (a <em>station</em>) and an event type.</li><li>An <em>Object Flow Arrow</em> connecting two nodes of a PN model represents both an object and an event flow. While events <em>flow in time</em>, processing objects <em>flow in space</em> (and time).</li></ol></aside><p>The nodes of a PN define locations in a network space, which may be based on a two- or three-dimensional Euclidean space. Consequently, OEM-PN models are spatial simulation models, while basic OEM and OEM-A allow to abstract away from space. When processing objects are routed to a follow-up processing activity, they move to the location of the next processing node. The underlying space model allows visualizing a PN simulation in a natural way with processing objects as moving objects.</p><p>Each node in a PN model represents both an object and an event type. An Entry Node represents both an entry point (e.g., a reception area or an entrance to an inventory) and an arrival event type. A Processing Node represents both a resource object (e.g., a workstation or a room) and a processing activity type. An Exit Node represents both an exit point and a departure event type. A flow arrow connecting two Processing Nodes represents both an event flow and an object flow. Thus, the node types and the flow arrows of a PN are high-level modeling concepts that are overloaded with two meanings.</p><p>A PN modeling language should have elements for modeling each of the three types of nodes. Consequently, DPMN-A has to be extended by adding new visual modeling elements for entry, processing and exit nodes, and for connecting them.</p><p>In the field of DES, PNs have often been characterized by the narrative of “entities flowing through a system”. In fact, while in basic DPMN and in DPMN-A, there is only a flow of events, in DPMN-PN this flow of events is over-laid with a flow of (processing) objects.</p><p>PNs have been investigated in <em>operations management</em> and the mathematical theory of queuing (Loch 1998, Williams 2016) and have been the application focus of most industrial simulation software products, historically starting with GPSS (Gordon 1961) and SIMAN/Arena (Pegden and Davis 1992). They allow modeling many forms of discrete <i>processing processes</i> as can be found, for instance, in the manufacturing industry and the services industry.</p><p>It is remarkable that the PN paradigm has dominated the discrete event simulation market since the 1990’s and still flourishes today, mainly in the manufacturing and services industries, often with object-oriented and “agent-based” extensions. Its dominance has led many simulation experts to view it as a synonym of DES, which is a conceptual flaw because the concept of DES, even if not precisely defined, is clearly more general than the PN paradigm.</p><p>The PN paradigm has often been called a “process-oriented” DES approach. But unlike the business process modeling language BPMN, it is not concerned with a general concept of <i>business process models</i>, but rather with the special class of <i>processing process models</i> for discrete processing systems. A processing process includes the simultaneous handling of several “cases” (processing objects) that may compete for resources or have other interdependencies, while a “business process” in Business Process Management has traditionally been considered as a case-based process that is isolated from other cases.</p><p>For PN models, a simulator can automatically collect the following statistics, in addition to the resource-constrained activities statistics described in <a class="role-section1-ref" href="#index-4"><span class="role-label">Section <span class="role-number">3.2</span></span></a>:</p><ol><li>The number of processing objects that arrived at, and departed from, the system.</li><li>The number of processing objects in process (that is, either waiting in a queue/buffer or being processed)</li><li>The average time a processing object spends in the system (also called <em>throughput time</em>).</li></ol><p>During a simulation run, it must hold that the number of processing objects that arrived at the system is equal to the sum of the number of processing objects in process and the number of processing objects that departed from the system, symbolically: </p><div style="text-align:center;"><i>arrived</i> = <i>in-process</i> + <i>departed</i></div><p> </p><section class="role-section1" id="secPN-CM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">4.1</span>. </span>Conceptual Modeling of Processing Networks</h2><p>For accommodating PN modeling, OEM-A is extended by adding pre-defined types for processing objects, entry node objects, arrival events, processing node objects, processing activities, exit objects and departure events, resulting in <em>OEM-PN</em>. These &quot;built-in&quot; types, which are described in <a class="role-figure-ref" href="#secPN-CM__figPredefinedTypes4PN_CM"><span class="role-label">Figure <span class="role-number">4-2</span></span></a>, allow making PN models based on them simply by making a process model (with DPMN) without the need of making an information/class model as its foundation, as shown in <a class="role-figure-ref" href="#secPN-CM__figDmvCPM"><span class="role-label">Figure <span class="role-number">4-3</span></span></a>.</p><figure id="secPN-CM__figPredefinedTypes4PN_CM"><figcaption><span class="role-label">Figure <span class="role-number">4-2</span>. </span>A conceptual OEM class model defining built-in types for conceptual PN modeling</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/PN-PredefinedTypes-CM.svg" width="400" /></div></figure><section><h4>An example of a conceptual PN model: Department of Motor Vehicles</h4><p>As a simple example of a PN simulation model we consider a Department of Motor Vehicles (DMV) with two consecutive service desks: a reception desk and a case handling desk. When a customer arrives at the DMV, she first has to queue up at the reception desk where data for her case is recorded. The customer then goes to the waiting area and waits for being called by the case handling desk where her case will be processed. After completing the case handling, the customer leaves the DMV via the exit.</p><p>Customer arrivals are modeled with an «entry node» element (with name “DMV entry”), the two consecutive service desks are modeled with two «processing node» elements, and the departure of customers is modeled with an «exit node» element (with name “DMV exit”).</p><p>DPMN is extended by adding the new modeling elements of <em>PN Node</em> rectangles, representing node objects, and <em>PN Object Flow</em> arrows, representing combined object-event flows. PN Node rectangles take the form of stereotyped UML object rectangles, while PN Object Flow arrows have a special arrow head consisting of a circle and three bars, as shown in <a class="role-figure-ref" href="#secPN-CM__figDmvCPM"><span class="role-label">Figure <span class="role-number">4-3</span></span></a>. </p><figure id="secPN-CM__figDmvCPM"><figcaption><span class="role-label">Figure <span class="role-number">4-3</span>. </span>A PN model using the new DPMN modeling elements of PN Node rectangles and PN Flow arrows</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/DMV_CPM.svg" width="600" /></div></figure></section><section><h4>Using both Object Flow arrows and Event Scheduling arrows</h4><p>While an Object Flow arrow between two nodes implies both a flow of the processing object to the successor node and the resource-dependent scheduling of the next processing activity, an Event Scheduling arrow from a processing node to an Event circle represents an event flow where a processing activity end event causes/schedules another event, as illustrated in the example of <a class="role-figure-ref" href="#secPN-CM__figDMVCPM2"><span class="role-label">Figure <span class="role-number">4-4</span></span></a>.</p><figure id="secPN-CM__figDMVCPM2"><figcaption><span class="role-label">Figure <span class="role-number">4-4</span>. </span>A DPMN-PN process diagram with an Event Scheduling arrow </figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/DMV_CPM2.svg" width="600" /></div></figure></section></section><section class="role-section1" id="secPN-DM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">4.2</span>. </span>Processing Network Design Models</h2><p>For accommodating PN modeling, OEM-A is extended by adding pre-defined types for processing objects, entry node objects, arrival events, processing node objects, processing activities, exit objects and departure events, resulting in <em>OEM-PN</em>. These &quot;built-in&quot; types, as described in <a class="role-figure-ref" href="#secPN-DM__figPredefinedTypes4PN"><span class="role-label">Figure <span class="role-number">4-5</span></span></a>, allow making PN models based on them simply by making a process model with DPMN without the need of making an OEM class model as its foundation, as shown in <a class="role-figure-ref" href="#secPN-DM__figWS3PDM-PN"><span class="role-label">Figure <span class="role-number">4-6</span></span></a>.</p><figure id="secPN-DM__figPredefinedTypes4PN"><figcaption><span class="role-label">Figure <span class="role-number">4-5</span>. </span>An OEM class design model defining built-in types for making PN design models</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/PN-PredefinedTypes.svg" /></div></figure><p>Notice that the range of the properties <i>arrivalRecurrence</i>, <i>successorNodes</i> and <i>duration</i> of the built-in object types <i>EntryNode</i> and <i>ProcessingNode</i> is <code>Function</code>, which means that the value of such a property for a specific node is a specific function. While the standard UML semantics does not support such an extension of the semantics of properties in the spirit of the <em>Functional Programming</em> paradigm, its implementation in a functional OO programming language like JavaScript, where objects can have instance-level functions/methods, is straightforward.</p><p>The property <i>successorNodes</i> allows to express a function that provides, for any given entry or processing node, a (possibly singleton) set of processing nodes or exit nodes. Such a function can express several cases of routing a processing object from a node to one or more successor nodes:</p><ol><li>a fixed unique successor node for modeling a series of processing nodes connected by (possibly conditional) object flow arrows, as in <a class="role-figure-ref" href="#secPN-DM__figDmvPDM"><span class="role-label">Figure <span class="role-number">4-8</span></span></a>;</li><li>a conditional unique successor node for modeling an Exclusive (XOR) Gateway leading to one of several possible successor nodes;</li><li>a variable subset of a set of potential successor nodes for modeling an Inclusive (OR) Gateway;</li><li>a fixed set of successor nodes for modeling a Parallel (AND) Gateway;</li></ol><p> In a DPMN diagram, the set of successor nodes of a node is defined by Flow Arrows, possibly in combination with Gateways.</p><section><h4>PN example 1: a single workstation</h4><p>Part arrivals are modeled with an «entry node» element (with name “partEntry”), the workstation is modeled with a «processing node» element, and the departure of parts is modeled with an «exit node» element (with name “partExit”).</p><p>DPMN is extended by adding the new modeling elements of <em>PN Node</em> rectangles, representing node objects with associated event types, and <em>PN Flow</em> arrows, representing combined object-event flows. PN Node rectangles take the form of stereotyped UML object rectangles, while PN Flow arrows have a special arrow head, as shown in <a class="role-figure-ref" href="#secPN-DM__figWS3PDM-PN"><span class="role-label">Figure <span class="role-number">4-6</span></span></a>. </p><figure id="secPN-DM__figWS3PDM-PN"><figcaption><span class="role-label">Figure <span class="role-number">4-6</span>. </span>A PN model of a workstation system using PN Node rectangles and PN Flow arrows</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS3_PDM-PN.svg" width="450" /></div></figure></section><section><h4>PN example 2: a workstation may have to rework parts</h4><p>Parts that turn out to be defective after being processed need to be reworked. This can be modeled by adding an attribute percentDefective to the object type Workstation and suitable logic to the Processing activity end event rule such that in percentDefective % of all cases a processed part cannot depart the system (i.e., is not removed from the input buffer), but is being reworked by another Processing activity.</p><figure id="secPN-DM__figWS4PDM-PN"><figcaption><span class="role-label">Figure <span class="role-number">4-7</span>. </span>A PN model of a workstation system where parts may have to be reworked </figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/WS4_PDM-PN.svg" width="550" /></div></figure></section><section><h4>PN example 3: Department of Motor Vehicles</h4><p>A Department of Motor Vehicles (DMV) has two consecutive service desks: a reception desk and a case handling desk. When a customer arrives at the DMV, she first has to queue up at the reception desk where data for her case is recorded. The customer then goes to the waiting area and waits for being called by the case handling desk where her case will be processed. After completing the case handling, the customer leaves the DMV via the exit.</p><p>Customer arrivals are modeled with an «entry node» element (with name “dmvEntry”), the two consecutive service desks are modeled with two «processing node» elements, and the departure of customers is modeled with an «exit node» element (with name “dmvExit”).</p><figure id="secPN-DM__figDmvPDM"><figcaption><span class="role-label">Figure <span class="role-number">4-8</span>. </span>A PN model using the new DPMN modeling elements of PN Node rectangles and PN Flow arrows</figcaption><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/DMV_PDM.svg" width="600" /></div></figure></section></section><section class="role-section1" id="SimioConceptsAndTerminology"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">4.3</span>. </span>Simio Concepts and Terminology</h2><p></p></section><section class="role-section1" id="AnyLogicConceptsAndTerminology"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">4.4</span>. </span>AnyLogic Concepts and Terminology</h2><p></p></section></section><section class="role-chapter" id="index-6"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">5</span>. </span>Case Studies</h1><p></p><section class="role-section1" id="Make-and-Deliver-Pizza"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">5.1</span>. </span>Make and Deliver Pizza</h2><figure style="float:right"><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizza-Delivery.svg" width="150" /></div><small>Image by <a href="https://www.flaticon.com/authors/monkik">monkik</a></small></figure><p>A pizza service company takes phone orders for making and delivering pizzas, with the help of order takers, pizza makers, ovens and a crew of pizza delivery scooter drivers. From time to time the order takers cannot cope with the number of incoming calls, and then customers grow impatient and hang up the phone without placing an order.</p><p>For getting a quick impression, you can <a href="https://gwagner57.github.io/oes/js/Core2/Load-Haul-Dump-1/">run this model</a> from the OES GitHub website, or inspect its <a href="https://github.com/gwagner57/oes/tree/master/docs/js/Core2/Load-Haul-Dump-1">OESjs code</a>. </p><p>Since there is a high number of lost orders due to long waiting times in the first model, assigning different responsibilities to organizational roles for allowing a more flexible use of human resources is considered in a variant of the first model.</p><blockquote class="role-note"><p>Our <em>Make-and-Deliver-Pizza</em> modeling problem is based on the chapter &quot;Example Model 3: Pizzeria operation&quot; in the book <a href="https://www.anylogic.com/resources/books/the-art-of-process-centric-modeling-with-anylogic/">The Art of Process-Centric Modeling with AnyLogic</a> by Arash Mahdavi.</p></blockquote><details><summary>Conceptual Model</summary><p>A pizza service company has resource pools for order takers, pizza makers, pizza ovens, delivery staff and scooters. While <em>take order</em> activities are performed by an <em>order taker</em>, <em>make pizza</em> activities require both an <em>oven</em> and a <em>pizza maker</em>. Finally, <i><em>deliver</em> pizza</i> activities require a delivery staff member and a scooter.</p><details><summary>Conceptual Information Model</summary><p>The potentially relevant object types are:</p><ol><li>pizza service company,</li><li>customers,</li><li>orders,</li><li>pizzas,</li><li>order takers,</li><li>pizza makers,</li><li>pizza ovens</li><li>delivery scooter drivers,</li><li>scooters.</li></ol><p>Potentially relevant types of events and activities are:</p><ol><li>pizza ordering calls coming in from customers,</li><li>order taking (an activity performed by order takers),</li><li>customers hanging up the phone when having to wait for too long,</li><li>pizza making (performed by pizza makers using ovens),</li><li>pizza delivery (performed by delivery staff using scooters).</li></ol><p>Object, event and activity types, together with their participation associations, can be visually described in a conceptual information model in the form of a special kind of UML class diagram, called Object Event (<abbr title="Object Event">OE</abbr>) class diagram, as shown below.</p><figure><img alt="conceptual information model describing object, event and activity types" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_CIMa.svg" width="500" /></figure><p>The association end annotations «rr» and «rp» denote <em>resource roles</em> and <em>resource pools</em>. For instance, the activity type <i>make pizza</i> has two resource roles, <i>pizza maker</i>s and <i>oven</i>. A pizza service company has resource pools for order takers, pizza makers, ovens, delivery scooter drivers and scooters. </p><p>Resource roles have resource cardinality constraints. For instance, a <i>make pizza</i> activity requires 2 pizza makers and 1 oven.</p><p>A conceptual <abbr title="Object Event">OE</abbr> class diagram like the one above, describes resource roles (like <i>oven</i>), resource role types (like <i>ovens</i>) and resource cardinality constraints (like &quot;exactly 1&quot;) for all types of activities. </p><p>An organization defines <em>organizational positions</em>, which are filled by human resources. Each organizational position is characterized by a set of human resource roles to be played by position holders. In the Pizza Service organization, there are three positions: order takers, pizza makers and delivery scooter drivers.</p><blockquote class="role-attention"><p>Strictly speaking, <i>order phone calls</i> are immediate (zero duration) events while a <i>take order</i> activity is an event with a non-zero duration. For simplicity, though, we'll often say &quot;events&quot; instead of &quot;immediate events&quot; or &quot;objects, events and activities&quot; instead of &quot;objects, immediate events and activities&quot;.</p></blockquote></details><details><summary>Conceptual Process Model</summary><p>The following BPMN diagram shows a conceptual process model of the Make-and-Deliver-Pizza business process, with three swimlanes for the three performers of the process:</p><figure><img alt="A conceptual process model in the form of a BPMN diagram" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_CPM_BPMN-2.svg" width="600" /></figure><p>Notice the BPMN Boundary Timeout Event circle attached to the <i>take order</i> activity representing timeout events that cancel the activity. They are supposed to model the <em>reneging</em> behavior of waiting customers loosing their patience and hanging up the phone without placing an order. However, BPMN does not allow restricting such a timeout mechanism to the waiting phase of a planned activity, that is the time span during which the planned activity has been enqueued, but not yet started. Rather, it applies to the entire cycle time of <i>take order</i> activities, which means that also started activities, where the order taker is already listening to the customer, may be canceled due to reneging.</p><p>While BPMN allows modeling the performers of activities with swimlanes, it does not support modeling other types of resource objects. As a workaround, we have included the resource objects <i>oven</i>s and <i>scooter</i>s in the form of BPMN Data Objects.</p><p>The third, and most severe, issue of the BPMN model is its uniform (semantically overloaded) use of &quot;sequence flow&quot; arrows for sequencing events and activities. While in the case of all three activities, incoming &quot;sequence flow&quot; arrows do not mean that an activity is started, but rather that a new planned activity is enqueued (and only started when all required resources become available), in the case of the event <i>lost order</i>, the incoming &quot;sequence flow&quot; arrow means that a new event is scheduled to occur immediately.</p><p>These three issues of BPMN have been solved in DPMN, where <em>resource-dependent activity start arrows</em> are distinguished from <em>event scheduling arrows</em>, as shown in the following DPMN process diagram:</p><figure><img alt="A conceptual process model in the form of a DPMN diagram" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_CPM-2.svg" width="550" /></figure><p>Notice how the timeout event circle (with a clock icon) is attached to the three bars of the resource-dependent activity start arrow representing the queue of planned order taking activities waiting for the availability of an order taker. This implies that the timeout applies to the waiting phase, and not to the order taking activity.</p><p>A conceptual <abbr title="Discrete Event Process Modeling Notation">DPMN</abbr> process diagram does normally not include any element representing a resource pool. Yet, it may display the performer roles of activity types, like <i>order taker</i> and <i>pizza maker </i> in the diagram above. It is assumed that for any organizational position described in the underlying <abbr title="Object Event">OE</abbr> class model, the organization under consideration has a corresponding resource pool.</p></details></details><details><summary>Simulation Design</summary><p>In our simulation design, we make the following simplifications. We consider only one particular pizza service company, which does not have to be modeled as an explicit object. Also, we abstract away from individual customers, orders and pizzas. And we merge the resource roles <i>delivery scooter driver</i> and <i>scooter</i>, keeping only <i>scooter</i>s as resources of <i>deliver pizza</i> activities.</p><p>We consider a scenario with two order takers, ten pizza makers, five ovens and 20 scooters.</p><details open="open"><summary>Information Design Model</summary><p>An information design model, in the form of an <abbr title="Object Event">OE</abbr> class diagram as shown below, is derived from a conceptual information model by </p><ol><li>Abstracting away from items that are not design-relevant.</li><li>Adding properties,functions and methods to object, event and activity classes. In particular, a <i>status</i> attribute is added to all resource object types, such as <i>OrderTaker</i> and <i>Oven</i>, and a class-level <i>duration</i> function is added to all activity classes.</li></ol><figure id="Make-and-Deliver-Pizza__lof__57"><figcaption><span class="role-label">Figure <span class="role-number">5-1</span>. </span>An information design model defining object, event and activity types.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_IDMa.svg" width="600" /></figure><p>Notice how functions representing random variables, like the <code>duration</code> function of all activity types, are marked with the keyword (or UML 'stereotype') «rv» standing for &quot;random variable&quot;. These random variable functions sample from a probability distribution function (PDF), which is symbolically indicated with expressions like <i>Tri(30,50,40)</i> standing for the <em>triangular</em> PDF with lower and upper bounds 30 and 50, and a median of 40. </p><p>The activity type <i>TakeOrder</i> is associated with the object type <i>OrderTaker</i> via the implicit resource role <i>orderTaker</i> (with a resource cardinality constraint of &quot;exactly 1&quot;), indicated with the association end stereotype «rr» standing for &quot;resource role&quot;. A resource role assigns resource objects to activities. </p><p>Likewise, <i>MakePizza</i> is associated with <i>PizzaMaker</i> and <i>Oven</i> as its resource roles, where the implicit <i>pizzaMakers</i> resource role has a resource cardinality constraint of &quot;exactly 2&quot; and the <i>oven</i> resource role has a resource cardinality constraint of &quot;exactly 1&quot;.</p><p>An <abbr title="Object Event">OE</abbr> class design diagram like the one above, defines resource roles (like <i>pizzaMakers</i>), resource role types (like <i>PizzaMaker</i>) and resource cardinality constraints (like &quot;exactly 2&quot;) for all types of activities. Normally, in an <abbr title="Object Event">OE</abbr> simulation there is a one-to-one correspondence between resource role types and resource pools. By convention, a resource pool has the same name as the corresponding resource role type, yet pluralized and starting with a lowercase character. For instance, the name of the resource pool for <i>PizzaMaker</i> is <i>pizzaMakers</i>.</p><p>Notice that <i>OrderCall</i> events are exogenous, having a recurrence function defined case-wise for each of the five hours per day operation of the pizza service company (in the attached invariant box).</p>For implementing the waiting timeout event defined in the process model, the activity type <i>TakeOrder</i> has a class-level <i>waitingTimeout</i> function implementing a random variable with PDF <i>U(3,6)</i>.</details><details open="open"><summary>Process Design Model</summary><p>A process design model, in the form of a DPMN process diagram as shown below, is derived from a conceptual process model by abstracting away from items that are not design-relevant and possibly adding certain computational details. In the case of the Make-and-Deliver-Pizza business process, we can drop the lost orders event since its purpose, obtaining a statistics of lost orders, can be implicitly achieved by the waiting timeout event attached to the queue of planned <i>TakeOrder</i> activities.</p><figure id="Make-and-Deliver-Pizza__lof__58"><figcaption><span class="role-label">Figure <span class="role-number">5-2</span>. </span>A computationally complete process design for the Make-and-Deliver-Pizza business process.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_PDM.svg" width="550" /></figure><p>A <abbr title="Discrete Event Process Modeling Notation">DPMN</abbr> process design diagram does not include any element representing a resource pool. Yet, it may display the performer roles of activity types, like <i>OrderTaker</i> and <i>PizzaMaker</i> in the diagram above. It is assumed that for any organizational position described in the underlying <abbr title="Object Event">OE</abbr> class model, the organization under consideration has a corresponding resource pool. By default , each resource role of an activity type is associated with a resource pool having the same (yet pluralized) name, such that its resources are instances of a corresponding resource role type, which is an organizational position in the case of human resources. </p><p>For instance, for the <i>MakePizza</i> activity a pool <i>ovens</i> is assigned to its resource role <i>oven</i> by default. The members of the pool <i>ovens</i> are instances of the (resource) object type <i>Oven</i>. Likewise, a pool <i>pizzaMakers</i> is assigned to the <i>MakePizza</i> resource role <i>pizzaMaker</i>. The members of this pool are instances of the organizational position <i>PizzaMaker</i>. These default pool assignments are normally not shown in a DPMN diagram, but an <abbr title="Object Event">OE</abbr> simulator takes care of them.</p></details></details><details><summary>Model Variant: Orders May Also Be Taken by Pizza Makers</summary><p>For decreasing the number of lost orders due to long waiting times, it is advisable to charge pizza makers with taking orders whenever no order taker is available. In resource management terminology, the organizational position <i>pizza maker</i> is redefined by adding the resource role <i>order taker</i> to its portfolio of organizational roles. </p><p>In a conceptual <abbr title="Object Event">OE</abbr> class diagram, this can be expressed by adding a subtyping arrow from <i>pizza makers</i> to <i>order takers</i> categorized as an <em><b>alternative resource subtyping</b></em> arrow with the stereotype «ar», as shown in the following diagram:</p><figure><img alt="conceptual information model describing object, event and activity types" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria_CIM1b.svg" width="500" /></figure><p>The <abbr title="Object Event">OE</abbr> class design diagram is extended in the same way, by adding an <em>alternative resource subtyping</em> arrow from <i>PizzaMaker</i> to <i>OrderTaker</i>.</p><p>The DPMN process design model is not affected by this change.</p></details><section class="role-section2" id="Make-and-Deliver-Pizza-OESjs"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.1.1</span>. </span>Implementation with OESjs</h3><p>The JavaScript-based simulator OESjs-Core2 implements the <em>Object Event Simulation (OES)</em> paradigm, and, consequently, allows a straight-forward coding of <abbr title="Object Event">OE</abbr> class models and <abbr title="Discrete Event Process Modeling Notation">DPMN</abbr> process models.</p><details><summary>Implementing the Information Design Model</summary><p>For implementing the <abbr title="Object Event">OE</abbr> class design model with OESjs-Core2, we have to code all object types, event types and activity types specified in the model in the form of JavaScript classes. We start with the object type <i>OrderTaker</i> shown in the following diagram:</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria-OrderTaker_IDM.svg" width="200" /></figure><p>The <code>OrderTaker</code> object class can be coded in the following way:</p><pre>class <b>OrderTaker</b> extends oBJECT {
  constructor({ id, name, status}) {
    super( id, name);
    this.status = status;
  }
}</pre><p>All object classes inherit an <code>id</code> attribute and a <code>name</code> attribute from the pre-defined <abbr title="Object Event Simulation">OES</abbr> foundation class <code>oBJECT</code>. Since order takers are resource objects, we need to define a <code>status</code> property for them. </p><p>The other object classes (<i>PizzaMaker</i>, <i>Oven</i> and <i>Scooter</i>) are coded in the same way.</p><p>We next show how to code the event type <i>OrderCall</i> depicted in the following diagram:</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria-OrderCall_IDM.svg" width="250" /></figure><p>The <code>OrderCall</code> event class is coded in the following way:</p><pre>class <b>OrderCall</b> extends eVENT {
  constructor({ occTime, delay}) {
    super({occTime, delay});
  }
  <b>createNextEvent</b>() {
    return new OrderCall({delay: OrderCall.recurrence()});
  }
  static <b>recurrence</b>() {
    var hour = Math.floor(sim.time / 60);
    return rand.exponential( OrderCall.arrivalRates[hour]);
  }
}
// arrival rates per minute (for a daily operation for 5 hours)
OrderCall.<b>arrivalRates</b> = [1/6, 1/0.66, 1/1.5, 1/6, 1/12];</pre><p>All event classes inherit an <code>occTime</code> attribute and a <code>delay</code> attribute from the pre-defined <abbr title="Object Event Simulation">OES</abbr> foundation class <code>eVENT</code>. Any event in <abbr title="Object Event Simulation">OES</abbr> can be created either with a value for the attribute <code>occTime</code> (standing for <em>occurrence time</em>) or with a value for the attribute <code>delay</code>. In the latter case, the event's occurrence time is automatically derived by adding the value of <code>delay</code> to the current simulation time. </p><p>Finally, we show how to code the activity type <i>TakeOrder</i> depicted in the following diagram:</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Pizzeria-TakeOrder_IDM.svg" width="400" /></figure><p>The <i>TakeOrder</i> activity class is coded in the following way:</p><pre>class <b>TakeOrder</b> extends aCTIVITY {
  constructor({id, startTime, duration}={}) {
    super({id, startTime, duration});
  }
  static <b>duration</b>() {
    return rand.uniform( 1, 4);
  }
  static <b>waitingTimeout</b>() {
    return rand.uniformInt( 3, 6);
  }
}
TakeOrder.<b>resourceRoles</b> = {
  &quot;orderTaker&quot;: {range: OrderTaker}
}</pre><p>All activity classes inherit the attributes <code>id</code>, <code>startTime</code> and <code>duration</code> from the pre-defined <abbr title="Object Event Simulation">OES</abbr> foundation class <code>aCTIVITY</code>. When an activity is created as a JS object during a simulation run, the value of its <code>duration</code> property is obtained by invoking the <code>duration()</code> function defined as a class-level (&quot;static&quot;) function for its activity class. These activity duration functions typically implement a random variable by invoking a random variate sampling function, such as <code>rand.triangular(30,50,40)</code>, which samples from the triangular probability distribution function (with min/max=30/50 and mode=40).</p><p>Notice how the resource role association between <i>TakeOrder</i> and <i>OrderTaker</i>, which defines the resource reference property <i>TakeOrder::orderTaker</i>, is coded by a corresponding entry in the map-valued class-level property <code>resourceRoles</code>.</p></details><details><summary>Implementing the Process Design Model</summary><p><b>T.B.D. The following material has been copied from the Load-Haul-Dump model</b></p><p>A DPMN process design model can be decomposed into a set of event rule design models, one for each type of event specified in the design model. Starting with the <code>HaulRequest</code> event rule design model, we show how the event rules specified by each of these event rule design models can be coded in the form of an <code>onEvent</code> method.</p><figure id="Make-and-Deliver-Pizza-OESjs__lof__59"><figcaption><span class="role-label">Figure <span class="role-number">5-3</span>. </span>A design model for the <code>HaulRequest</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-HaulRequest_RDM.svg" width="400" /></figure><p>In the following <code>HaulRequest</code> event rule method <code>onEvent</code>, all available trucks are allocated to the current haul request, and, after computing the number of loads, for each of the allocated trucks a new <code>GoToLoadingSite</code> activity is started:</p><pre>class <b>HaulRequest</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    const followupEvents=[],
          allocatedTrucks = sim.resourcePools[&quot;trucks&quot;].<b>allocateAll</b>();
    // assign model variable
    sim.model.v.<b>nmrOfLoads</b> = Math.ceil( this.quantity / Truck.capacity);
    for (const t of allocatedTrucks) {
      const goActy = <b>new GoToLoadingSite</b>();
      // assign truck as required resource
      goActy.truck = t;
      // start GoToLoadingSite activity
      followupEvents.push( <b>new aCTIVITYsTART</b>({plannedActivity: goActy}));
    }
    return followupEvents;
  }
}</pre><p>Since activities are composite events, we also have event rules for them. The following <i>GoToLoadingSite</i> event rule is triggered whenever a <i>GoToLoadingSite</i> activity is completed, since the completion of an activity counts as its occurrence event.</p><figure id="Make-and-Deliver-Pizza-OESjs__lof__60"><figcaption><span class="role-label">Figure <span class="role-number">5-4</span>. </span>A design model for the <code>GoToLoadingSite</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-GoToLoadingSite_RDM.svg" width="300" /></figure><p>This rule states that whenever a <i>GoToLoadingSite</i> activity ends (or is completed), then a new planned <i>Load</i> activity is enqueued, if no wheel loader is available, or, otherwise, a new <i>Load</i> activity is started. In OESjs, it is coded in the following declarative way: </p><pre>GoToLoadingSite.<b>successorActivity</b> = &quot;Load&quot;</pre><p>Such a successor activity assignment allows the simulator to check if the required resources are available and then start the successor activity, or, otherwise, enqueue a new planned successor activity.</p><figure id="Make-and-Deliver-Pizza-OESjs__lof__61"><figcaption><span class="role-label">Figure <span class="role-number">5-5</span>. </span>A design model for the <code>Load</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Load_RDM.svg" width="300" /></figure><p>This rule states that whenever a <i>Load</i> activity ends, the model variable <i>nmrOfLoads</i> is decremented by 1, and a <i>Haul</i> activity is immediately started (as a successor activity). Since the <i>Haul</i> activity doesn't require any additional resources, there is no need to enqueue a planned activity and wait for the availability of resources. In OESjs, this rule is coded in the following way:</p><pre>class <b>Load</b> extends aCTIVITY {
  ...
  <b>onActivityEnd</b>() {
    const followupEvents = [];
    // decrement nmrOfLoads counter
    sim.model.v.nmrOfLoads--;
    return followupEvents;
  }
  ...
}
Load.<b>successorActivity</b> = &quot;Haul&quot;;</pre><p>Notice that the state change expressed in the <i>modelVariables</i> object rectangle, the decrementation of <i>nmrOfLoads</i>, is taken care of in the <code>onActivityEnd</code> method of the <code>Load</code> activity class. Instead of explicitly scheduling the start of the succeeding <code>Haul</code> activity in that method, we simply define <code>Haul</code> to be the successor activity of <code>Load</code>.</p><figure id="Make-and-Deliver-Pizza-OESjs__lof__62"><figcaption><span class="role-label">Figure <span class="role-number">5-6</span>. </span>A design model for the <code>Haul</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Haul_RDM.svg" width="300" /></figure><p>The <i>Haul</i> event rule states that whenever a <i>Haul</i> activity ends, it is immediately succeeded by a <i>Dump</i> activity. It is coded in the following way:</p><pre>Haul.<b>successorActivity</b> = &quot;Dump&quot;;</pre><figure id="Make-and-Deliver-Pizza-OESjs__lof__63"><figcaption><span class="role-label">Figure <span class="role-number">5-7</span>. </span>A design model for the <code>Dump</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Dump_RDM.svg" width="400" /></figure><p>The <i>Dump</i> event rule states that when a <i>Dump</i> activity ends and the model variable <i>nmrOfLoads</i> has the value 0, it is immediately succeeded by a <i>GoHome</i> activity, otherwise it is immediately succeeded by a <i>GoBackToLoadingSite</i> activity. The rule is coded by defining the successor activity as a function returning either &quot;GoBackToLoadingSite&quot; or &quot;GoHome&quot; in the following way:</p><pre>Dump.<b>successorActivity</b> = function () {
  return sim.model.v.nmrOfLoads === 0 ? &quot;GoHome&quot;:&quot;GoBackToLoadingSite&quot;;
}</pre><figure id="Make-and-Deliver-Pizza-OESjs__lof__64"><figcaption><span class="role-label">Figure <span class="role-number">5-8</span>. </span>A design model for the <code>GoBackToLoadingSite</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-GoBackToLoadingSite_RDM.svg" width="400" /></figure><p>The <i>GoBackToLoadingSite</i> event rule states that when a <i>GoBackToLoadingSite</i> activity ends and the model variable <i>nmrOfLoads</i> still has a value greater than 0, a new planned <i>Load</i> activity is enqueued; otherwise a <i>GoHome</i> activity is immediately started. The rule is coded by defining the successor activity of <i>GoBackToLoadingSite</i> as a function returning either &quot;Load&quot; or &quot;GoHome&quot; in the following way:</p><pre>GoBackToLoadingSite.<b>successorActivity</b> = function () {
  return sim.model.v.nmrOfLoads &gt; 0 ? &quot;Load&quot;:&quot;GoHome&quot;;
}</pre></details></section><section class="role-section2" id="ImplementationWithAnyLogic"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.1.2</span>. </span>Implementation with AnyLogic</h3><p><b>T.B.D. The following material has been copied from the Load-Haul-Dump model</b></p><p>Since AnyLogic does not support Activity-Based Discrete Event Simulation, but only <a href="https://sim4edu.com/explain/what-is-process-oriented-simulation.html">Processing Network (PN)</a> simulations with &quot;entities flowing through the system&quot;, it does not allow a straight-forward coding of the Load-Haul-Dump process design model (and its underlying class model). Rather, we have to figure out what we could use as &quot;entities&quot; for being able to make a PN model.</p><p>One option is to use the five trucks of the haul service company as the entities (called &quot;agents&quot; in AnyLogic), which arrive at a truck <em>entry node</em> and &quot;flow&quot; through the <em>processing nodes</em> Load, Haul and Dump before they leave the system via a truck <em>exit node</em>. Although this approach is quite artificial, imposing the PN paradigm on the given problem, it allows us using AnyLogic.</p><p>Notice that AnyLogic, like many other simulation tools, has adopted the <em>Seize-Delay-Release</em> pattern for modeling resource-constrained activities introduced by the simulation language GPSS in 1961. This means that activities are essentially modeled as <i>Delay</i> elements.</p><details open="open"><summary>Implementing the Information Design Model with AnyLogic</summary><p>From the information design model, we can only take the following items into consideration:</p><ol><li>All model variables are implemented as AnyLogic variables (defined in <i>Main</i>).</li><li>The <i>duration</i> functions defined in activity types are implemented as the <i>Delay times</i> of corresponding AnyLogic <i>Delay</i> or <i>Service</i> elements.</li><li>The <em>resource roles</em> defined for activity types are implemented either as <i>Seize</i> elements or as <i>Seize</i> information items within <i>Service</i> elements (if they had not to be transformed into entities, like the trucks of the Load-Haul-Dump model).</li></ol><p>For instance, the activity type <i>Load</i> with its resource roles <i>wheelLoader</i> and <i>truck</i> is implemented as a <i>Service</i> element with</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Load_IDM.svg" width="500" /></figure><ol><li>its <i>duration</i> function, sampling the U(10,20) distribution, entered as &quot;uniform(10,20)&quot; in the <i>Delay time</i> field of the <i>Load</i> Service element.</li><li>its resource role <i>wheelLoader</i> entered in the from of a resource pool <i>wheelLoaders</i> in the <i>Resource pool</i> field of the <i>Load</i> Service element, and its resource cardinality constraint of exactly one entered as &quot;1&quot; in the field <i>number of units</i>.</li></ol></details><details><summary>Implementing the Process Design Model with AnyLogic</summary><figure id="ImplementationWithAnyLogic__lof__65"><figcaption><span class="role-label">Figure <span class="role-number">5-9</span>. </span>A DPMN process design model for the Load-Haul-Dump business process.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump_PDM.svg" width="700" /></figure><p>While the DPMN process starts with the event <i>HaulRequest</i>, the AnyLogic process starts with the entry node <i>truckEntry</i> (a &quot;source&quot; element) having the field <i>&quot;Arrivals defined by&quot;</i> set to &quot;Calls of inject() function&quot;, which means that, for creating 5 trucks arriving at <i>truckEntry</i>, the inject function needs to be invoked in the <i>&quot;On startup&quot;</i> procedure of <i>Main</i> in the following way: <code>truckEntry.inject(5)</code>.</p><p>For simplicity, the <i>GoToLoadingSite</i> activity of the DPMN model is discarded.</p><figure id="ImplementationWithAnyLogic__lof__66"><figcaption><span class="role-label">Figure <span class="role-number">5-10</span>. </span>An AnyLogic process diagram for the Load-Haul-Dump business process.</figcaption><img alt="???" height="245" src="DES-DPMN-OESjs-Simio-AnyLogic_files/AnyLogic-Load-Haul-Dump-Screenshot.png" width="712" /></figure><p>As explained above, the activity type <i>Load</i> is implemented as a <i>Service</i> element with a <i>&quot;Delay time&quot;</i> of &quot;uniform(10,20)&quot; and the field <i>&quot;Resource pool&quot;</i> set to &quot;wheelLoaders&quot; with <i>&quot;number of units&quot;</i> set to 1.</p><p>All other activity types are implemented as <i>Delay</i> elements (with a <i>&quot;Delay time&quot;</i> provided by their <i>duration</i> function defined in the class model).</p><p>The two decision diamonds of the DPMN model are implemented with corresponding <i>&quot;SelectOutput&quot;</i> elements called &quot;test_if_job_done_1&quot; and &quot;test_if_job_done_2&quot;.</p><blockquote class="role-attention"><p>Unfortunately, PN modeling tools, like AnyLogic, do not support the general concept of activities (and Activity Networks), but only the special concept of <em>processing activities</em>. A processing activity has a <em>processing object</em> (&quot;entity&quot;) as a mandatory participant, in addition to resource objects. While in a PN model, processing nodes do have a location and a <em>processing capacity</em> (the number of processing objects that can be processed in parallel), the nodes of an Activity Network (like the Make-and-Deliver-Pizza model), representing pure activities, in general do neither have a processing capacity nor a location.</p><p>For instance, in the AnyLogic Load-Haul-Dump model above, trucks are processing objects and the processing activity <i>Load</i> is performed at the processing node <i>Load</i> by a wheel loader that is processing a truck. Consequently, the <i>Load</i>, <i>Haul</i>, <i>Dump</i> and <i>GoBack</i> elements in the AnyLogic process diagram do not represent activities, but rather processing nodes. </p></blockquote></details></section><section class="role-section2" id="ImplementationWithSimio"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.1.3</span>. </span>Implementation with Simio</h3><p></p></section></section><section class="role-section1" id="Load-Haul-Dump"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">5.2</span>. </span>The Load-Haul-Dump Model</h2><figure style="float:right"><div><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/Load-Truck-Scenario.svg" width="600" /></div><small>Image by <a href="https://pixabay.com/users/clker-free-vector-images-3736/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=306852" id="Load-Haul-Dump__a2">Clker-Free-Vector-Images</a></small></figure><p>A haul service company accepts requests for hauling large quantities of earth from a loading site to a dump site, using dump trucks and wheel loaders.</p><p>You can <a href="https://gwagner57.github.io/oes/js/Core2/Load-Haul-Dump-1/">run this model</a> from the OES GitHub website, or inspect its <a href="https://github.com/gwagner57/oes/tree/master/docs/js/Core2/Load-Haul-Dump-1">OESjs code</a>.</p><blockquote class="role-note"><p>Our <em>Load-Haul-Dump</em> modeling problem is based on the chapter &quot;Example Model 2: Earthmoving operation&quot; in the book <a href="https://www.anylogic.com/resources/books/the-art-of-process-centric-modeling-with-anylogic/">The Art of Process-Centric Modeling with AnyLogic</a> by Arash Mahdavi.</p></blockquote><details><summary>Conceptual Model</summary><p>A haul service company has resource pools for dump trucks and wheel loaders. While the activities <em>go (back) to loading site</em>, <em>haul</em>, <em>dump</em> and <em>go home</em> just require a <em>truck</em> (or a <em>wheel loader</em>) as a resource, <em>load</em> activities require both a <em>truck</em> and a <em>wheel loader</em>.</p><details><summary>Conceptual Information Model</summary><p>The potentially relevant object types are:</p><ol><li>haul service company,</li><li>wheel loaders,</li><li>dump trucks.</li></ol><p>Potentially relevant types of events and activities are:</p><ol><li>haul requests coming in from customers,</li><li>going to the loading site (an activity performed by trucks and by wheel loaders),</li><li>loading (performed by wheel loaders using trucks as resources),</li><li>hauling (performed by trucks),</li><li>dumping (performed by trucks),</li><li>going back to loading site (performed by trucks),</li><li>going home when the job is done (performed by trucks and by wheel loaders).</li></ol><p>Both object types and event types, together with their participation associations, can be visually described in a conceptual information model in the form of a special kind of UML class diagram, called Object Event (<abbr title="Object Event">OE</abbr>) class diagram, as shown below.</p><figure id="Load-Haul-Dump__lof__67"><figcaption><span class="role-label">Figure <span class="role-number">5-11</span>. </span>A conceptual <abbr title="Object Event">OE</abbr> class model describing object, event and activity types.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump_CIM.svg" width="500" /></figure><p>Notice that the association end annotations «rr» and «rp» denote <em>resource roles</em> and <em>resource pools</em>. A haul service company has resource pools for trucks and wheel loaders. The activity types <em>haul</em>, <em>dump</em> and <em>go back to loading site</em> have a resource role <em>truck</em> for assigning a truck to any activity of one of those types. The activity types <em>go to loading site</em> and <em>go home</em> have either a a resource role <em>truck</em> or a resource role <em>wheel loader</em>, as indicated by the <em>alternative association</em> constraint expressed with a dashed line annotated with <em>{xor}</em>. The activity type <em>load</em> has both resource role <em>truck</em> and a resource role <em>wheel loaders</em> for assigning at least one and at most two wheel loaders to any <em>load</em> activity (as indicated by the multiplicity &quot;1..2&quot; at the «rr» association end at the class <em>wheel loaders</em>).</p></details><details><summary>Conceptual Process Model</summary><p>The involved types of events and activities can be related with each other via <em>resource-dependent activity start arrows</em> and <em>event scheduling arrows</em>, as shown in the following DPMN process diagram:</p><figure><img alt="A DPMN diagram showing a conceptual process model" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump_CPMa.svg" width="600" /></figure><p>Notice that there are three types of arrows in this DPMN diagram:</p><ol><li><strong><em>Event Scheduling</em></strong> arrows, like the one between <em>load</em> and <em>haul</em>, have the meaning that the succeeding activity is started as soon as the preceding activity has been completed (there is no need for enqueuing a planned activity, since all resources required by the succeeding activity are provided by the preceding activity). Event Scheduling arrows are not part of BPMN, rather they have been proposed by Schruben (1983) for <a href="https://dl.acm.org/citation.cfm?id=358460" rel="nofollow noopener" target="_blank">Event Graphs</a>.</li><li>A <strong><em>Multiple Events Scheduling</em></strong> arrow, like the one between <em>requests</em> and <em>go to loading site</em>, means that one instance of the preceding event type triggers multiple instances of the succeeding event type. In our example model, this means that one <em>request</em> event is followed by multiple <em>go to loading site</em> activities, one for each truck and each wheel loader assigned to the job.</li><li>A <strong><em>Resource-Dependent Activity Start</em></strong> arrow, like the one between <em>go to loading site</em> and <em>load</em> activities, means that as soon as an activity of the preceding activity type has been completed, a new planned activity is added to the queue of planned activities of the succeeding type (and started as soon as all required resources are available).</li></ol><p>The model shows that when a haul request comes in, the haul service company deploys multiple trucks and wheel loaders to the loading site, each of them performing a <em>go to loading site</em> activity, as indicated by the double arrow between the <i>haul requests</i> event circle and the <em>go to loading site</em> activity rectangle. Each of these activities leads to enqueuing a new planned <em>load</em> activity, as indicated by the <em>resource-dependent activity start arrow</em> from the <em>go to loading site</em> activity shape to the <em>load</em> activity shape. Such an enqueued (planned) activity is going to be dequeued and started as soon as the required resources become available. This means that as soon as a wheel loader is available, the next <em>load</em> activity is going to be started. When a <em>load</em> activity is completed, a <em>haul</em> activity and then a <em>dump</em> activity are going to start immediately, as indicated by the <em>event scheduling arrows</em> between them.</p><p>A more complete model prevents trucks to go back to the loading site and perform a load activity even when the job has been completed during the go back activity (resulting in haul and dump activities with an empty truck). For avoiding this uneconomic behavior, a second decision if the job has been done needs to be taken after the go back activity. In addition, the model has to describe that wheel loaders also go home when their job has been done. This is shown in the following refined model:</p><figure id="Load-Haul-Dump__lof__68"><figcaption><span class="role-label">Figure <span class="role-number">5-12</span>. </span>A refined conceptual process model.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump_CPMb.svg" width="650" /></figure></details></details><details><summary>Simulation Design</summary><p>In our simulation design, we consider only one particular haul service company, which does not have to be modeled as an explicit object. Also, we abstract away from the fact that also wheel loaders have to go to, and return from, the loading site by assuming that they are already at the site when the dump trucks arrive.</p><details><summary>Information Design Model</summary> <p>In the information design model, we need to define a <i>status</i> attribute for all resource object types, such as <i>Truck</i> and <i>WheelLoader</i>, and a duration function, typically representing a random variable, for each activity type:</p><figure id="Load-Haul-Dump__lof__69"><figcaption><span class="role-label">Figure <span class="role-number">5-13</span>. </span>An information design model defining object, event and activity types.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump_IDM.svg" width="600" /></figure><p>Notice how functions representing random variables, like the <code>duration</code> function of all activity types, are marked with the keyword (or UML 'stereotype') «rv» standing for &quot;random variable&quot;. These random variable functions sample from a probability distribution function (PDF), which is symbolically indicated with expressions like Tri(30,50,40) standing for the triangular PDF with lower and upper bounds 30 and 50, and a median of 40. </p><p>Each activity type is associated with <i>Truck</i> or <i>WheelLoader</i> as their resource role(s), indicated with the association end stereotype «rr» standing for &quot;resource role&quot;.</p></details><details open="open"><summary>Process Design Model</summary><p>A process design model, in the form of a DPMN process diagram as shown below, is derived from a conceptual process model by</p><ol><li>Abstracting away from items that are not design-relevant.</li><li>Defining event variables, if needed.</li><li>Defining object variables in the form of Data Object boxes for specifying state changes of objects affected by events.</li><li>Formalizing decision conditions on the basis of event and object variables.</li></ol><figure id="Load-Haul-Dump__lof__70"><figcaption><span class="role-label">Figure <span class="role-number">5-14</span>. </span>A computationally complete process design for the Load-Haul-Dump business process.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump_PDM-2.svg" width="650" /></figure></details></details><section class="role-section2" id="Load-Haul-Dump-OESjs"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.2.1</span>. </span>Implementation with OESjs</h3><p>The JavaScript-based simulator OESjs implements the Object Event Simulation paradigm, and, consequently, allows a straight-forward coding of <abbr title="Object Event">OE</abbr> class models and DPMN process models.</p><details><summary>Implementing the Information Design Model</summary><p>For implementing the <abbr title="Object Event">OE</abbr> class design model with OESjs, we have to code all object types, event types and activity types specified in the model in the form of JavaScript classes.</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Truck_IDM.svg" width="300" /></figure><p>The <code>Truck</code> object class can be coded with OESjs-Core2 in the following way:</p><pre>class <b>Truck</b> extends oBJECT {
  constructor({ id, name, <b>status</b>}) {
    super( id, name);  // invoke the oBJECT constructor
    <b>this.status</b> = status;
  }
}
// a class-level attribute
Truck.<b>capacity</b> = 15;  // m3</pre><p>All object classes inherit an <code>id</code> attribute and a <code>name</code> attribute from the pre-defined OES foundation class <code>oBJECT</code>. Since trucks are resource objects, we need to define a <code>status</code> property for them. We also define a class-level attribute <code>capacity</code> for modeling their load capacity, assuming that all trucks have the same capacity.</p><p>The <i>WheelLoader</i> object class is coded in the same way as <i>Truck</i>.</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-HaulRequest_IDM.svg" width="180" /></figure><p>The <code>HaulRequest</code> event class can be coded in the following way:</p><pre>class <b>HaulRequest</b> extends eVENT {
  constructor({ occTime, delay, <b>quantity</b>}) {
    super({occTime, delay});
    <b>this.quantity</b> = quantity;
  }
  onEvent() {
    ...
  }
}</pre><p>All event classes inherit an <code>occTime</code> attribute and a <code>delay</code> attribute from the pre-defined OES foundation class <code>eVENT</code>. Any event in OES can be created either with a value for the attribute <code>occTime</code> (standing for <em>occurrence time</em>) or with a value for the attribute <code>delay</code>. In the latter case, the event's occurrence time is automatically derived by adding the value of <code>delay</code> to the current simulation time. In addition, the <i>HaulRequest</i> event class has a property <code>quantity</code> for specifying the quantity to be hauled.</p><p>The <code>onEvent</code> method of the <i>HaulRequest</i> event class is not part of the information design model. Rather, it is implementing an event rule specified in the process design model. Consequently, it will be discussed below.</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-GoToLoadingSite_IDM.svg" width="400" /></figure><p>The <i>GoToLoadingSite</i> activity class can be coded in the following way:</p><pre>class <b>GoToLoadingSite</b> extends aCTIVITY {
  constructor({id, startTime, duration}={}) {
    super({id, startTime, duration});
  }
  static <b>duration</b>() {return rand.triangular( 30, 50, 40);}
}
GoToLoadingSite.<b>resourceRoles</b> = {
  &quot;truck&quot;: {range: Truck}
}</pre><p>All activity classes inherit the attributes <code>id</code>, <code>startTime</code> and <code>duration</code> from the pre-defined OES foundation class <code>aCTIVITY</code>. When an activity is created as a JS object during a simulation run, the value of its <code>duration</code> property is obtained by invoking the <code>duration()</code> function defined as a class-level (&quot;static&quot;) function for its activity class. These activity duration functions typically implement a random variable by invoking a random variate sampling function, such as <code>rand.triangular(30,50,40)</code>, which samples from the triangular probability distribution function (with min/max=30/50 and mode=40).</p><p>Notice how the resource role association between <i>GoToLoadingSite</i> and <i>Truck</i>, which defines the resource reference property <i>GoToLoadingSite::truck</i>, is coded by a corresponding entry in the map-valued class-level property <code>resourceRoles</code>.</p></details><details><summary>Implementing the Process Design Model</summary><p>A DPMN process design model can be decomposed into a set of event rule design models, one for each type of event specified in the design model. Starting with the <code>HaulRequest</code> event rule design model, we show how the event rules specified by each of these event rule design models can be coded in the form of an <code>onEvent</code> method.</p><figure id="Load-Haul-Dump-OESjs__lof__71"><figcaption><span class="role-label">Figure <span class="role-number">5-15</span>. </span>A design model for the <code>HaulRequest</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-HaulRequest_RDM.svg" width="300" /></figure><p>In the following <code>HaulRequest</code> event rule method <code>onEvent</code>, all available trucks are allocated to the current haul request, and, after computing the number of loads, for each of the allocated trucks a new <code>GoToLoadingSite</code> activity is started:</p><pre>class <b>HaulRequest</b> extends eVENT {
  ...
  <b>onEvent</b>() {
    const followupEvents=[],
          allocatedTrucks = sim.resourcePools[&quot;trucks&quot;].<b>allocateAll</b>();
    // assign model variable
    sim.model.v.<b>nmrOfLoads</b> = Math.ceil( this.quantity / Truck.capacity);
    for (const t of allocatedTrucks) {
      const goActy = <b>new GoToLoadingSite</b>();
      // assign truck as required resource
      goActy.truck = t;
      // start GoToLoadingSite activity
      followupEvents.push( <b>new aCTIVITYsTART</b>({plannedActivity: goActy}));
    }
    return followupEvents;
  }
}</pre><p>Since activities are composite events, we also have event rules for them. The following <i>GoToLoadingSite</i> event rule is triggered whenever a <i>GoToLoadingSite</i> activity is completed, since the completion of an activity counts as its occurrence event.</p><figure id="Load-Haul-Dump-OESjs__lof__72"><figcaption><span class="role-label">Figure <span class="role-number">5-16</span>. </span>A design model for the <code>GoToLoadingSite</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-GoToLoadingSite_RDM.svg" width="300" /></figure><p>This rule states that whenever a <i>GoToLoadingSite</i> activity ends (or is completed), then a new planned <i>Load</i> activity is enqueued, if no wheel loader is available, or, otherwise, a new <i>Load</i> activity is started. In OESjs, it is coded in the following declarative way: </p><pre>GoToLoadingSite.<b>successorActivity</b> = &quot;Load&quot;</pre><p>Such a successor activity assignment allows the simulator to check if the required resources are available and then start the successor activity, or, otherwise, enqueue a new planned successor activity.</p><figure id="Load-Haul-Dump-OESjs__lof__73"><figcaption><span class="role-label">Figure <span class="role-number">5-17</span>. </span>A design model for the <code>Load</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Load_RDM.svg" width="250" /></figure><p>This rule states that whenever a <i>Load</i> activity ends, the model variable <i>nmrOfLoads</i> is decremented by 1, and a <i>Haul</i> activity is immediately started (as a successor activity). Since the <i>Haul</i> activity doesn't require any additional resources, there is no need to enqueue a planned activity and wait for the availability of resources. In OESjs, this rule is coded in the following way:</p><pre>class <b>Load</b> extends aCTIVITY {
  ...
  <b>onActivityEnd</b>() {
    const followupEvents = [];
    // decrement nmrOfLoads counter
    sim.model.v.nmrOfLoads--;
    return followupEvents;
  }
  ...
}
Load.<b>successorActivity</b> = &quot;Haul&quot;;</pre><p>Notice that the state change expressed in the <i>modelVariables</i> object rectangle, the decrementation of <i>nmrOfLoads</i>, is taken care of in the <code>onActivityEnd</code> method of the <code>Load</code> activity class. Instead of explicitly scheduling the start of the succeeding <code>Haul</code> activity in that method, we simply define <code>Haul</code> to be the successor activity of <code>Load</code>.</p><figure id="Load-Haul-Dump-OESjs__lof__74"><figcaption><span class="role-label">Figure <span class="role-number">5-18</span>. </span>A design model for the <code>Haul</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Haul_RDM.svg" width="250" /></figure><p>The <i>Haul</i> event rule states that whenever a <i>Haul</i> activity ends, it is immediately succeeded by a <i>Dump</i> activity. It is coded in the following way:</p><pre>Haul.<b>successorActivity</b> = &quot;Dump&quot;;</pre><figure id="Load-Haul-Dump-OESjs__lof__75"><figcaption><span class="role-label">Figure <span class="role-number">5-19</span>. </span>A design model for the <code>Dump</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Dump_RDM.svg" width="350" /></figure><p>The <i>Dump</i> event rule states that when a <i>Dump</i> activity ends and the model variable <i>nmrOfLoads</i> has the value 0, it is immediately succeeded by a <i>GoHome</i> activity, otherwise it is immediately succeeded by a <i>GoBackToLoadingSite</i> activity. The rule is coded by defining the successor activity as a function returning either &quot;GoBackToLoadingSite&quot; or &quot;GoHome&quot; in the following way:</p><pre>Dump.<b>successorActivity</b> = function () {
  return sim.model.v.nmrOfLoads === 0 ? &quot;GoHome&quot;:&quot;GoBackToLoadingSite&quot;;
}</pre><figure id="Load-Haul-Dump-OESjs__lof__76"><figcaption><span class="role-label">Figure <span class="role-number">5-20</span>. </span>A design model for the <code>GoBackToLoadingSite</code> event rule.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-GoBackToLoadingSite_RDM.svg" width="350" /></figure><p>The <i>GoBackToLoadingSite</i> event rule states that when a <i>GoBackToLoadingSite</i> activity ends and the model variable <i>nmrOfLoads</i> still has a value greater than 0, a new planned <i>Load</i> activity is enqueued; otherwise a <i>GoHome</i> activity is immediately started. The rule is coded by defining the successor activity of <i>GoBackToLoadingSite</i> as a function returning either &quot;Load&quot; or &quot;GoHome&quot; in the following way:</p><pre>GoBackToLoadingSite.<b>successorActivity</b> = function () {
  return sim.model.v.nmrOfLoads &gt; 0 ? &quot;Load&quot;:&quot;GoHome&quot;;
}</pre></details></section><section class="role-section2" id="ImplementationWithAnyLogic-2"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.2.2</span>. </span>Implementation with AnyLogic</h3><p>Since AnyLogic does not support Activity-Based Discrete Event Simulation, but only <a href="https://sim4edu.com/explain/what-is-process-oriented-simulation.html">Processing Network (PN)</a> simulations with &quot;entities flowing through the system&quot;, it does not allow a straight-forward coding of the Load-Haul-Dump process design model (and its underlying class model). Rather, we have to figure out what we could use as &quot;entities&quot; for being able to make a PN model.</p><p>One option is to use the five trucks of the haul service company as the entities (called &quot;agents&quot; in AnyLogic), which arrive at a truck <em>entry node</em> and &quot;flow&quot; through the <em>processing nodes</em> Load, Haul and Dump before they leave the system via a truck <em>exit node</em>. Although this approach is quite artificial, imposing the PN paradigm on the given problem, it allows us using AnyLogic.</p><p>Notice that AnyLogic, like many other simulation tools, has adopted the <em>Seize-Delay-Release</em> pattern for modeling resource-constrained activities introduced by the simulation language GPSS in 1961. This means that activities are essentially modeled as <i>Delay</i> elements.</p><details open="open"><summary>Implementing the Information Design Model with AnyLogic</summary><p>From the information design model, we can only take the following items into consideration:</p><ol><li>All model variables are implemented as AnyLogic variables (defined in <i>Main</i>).</li><li>The <i>duration</i> functions defined in activity types are implemented as the <i>Delay times</i> of corresponding AnyLogic <i>Delay</i> or <i>Service</i> elements.</li><li>The <em>resource roles</em> defined for activity types are implemented either as <i>Seize</i> elements or as <i>Seize</i> information items within <i>Service</i> elements (if they had not to be transformed into entities, like the trucks of the Load-Haul-Dump model).</li></ol><p>For instance, the activity type <i>Load</i> with its resource roles <i>wheelLoader</i> and <i>truck</i> is implemented as a <i>Service</i> element with</p><figure class="right"><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump-Load_IDM.svg" width="500" /></figure><ol><li>its <i>duration</i> function, sampling the U(10,20) distribution, entered as &quot;uniform(10,20)&quot; in the <i>Delay time</i> field of the <i>Load</i> Service element.</li><li>its resource role <i>wheelLoader</i> entered in the from of a resource pool <i>wheelLoaders</i> in the <i>Resource pool</i> field of the <i>Load</i> Service element, and its resource cardinality constraint of exactly one entered as &quot;1&quot; in the field <i>number of units</i>.</li></ol></details><details open="open"><summary>Implementing the Process Design Model with AnyLogic</summary><figure id="ImplementationWithAnyLogic-2__lof__77"><figcaption><span class="role-label">Figure <span class="role-number">5-21</span>. </span>A DPMN process design model for the Load-Haul-Dump business process.</figcaption><img alt="???" src="DES-DPMN-OESjs-Simio-AnyLogic_files/LoadHaulDump_PDM.svg" width="700" /></figure><p>While the DPMN process starts with the event <i>HaulRequest</i>, the AnyLogic process starts with the entry node <i>truckEntry</i> (a &quot;source&quot; element) having the field <i>&quot;Arrivals defined by&quot;</i> set to &quot;Calls of inject() function&quot;, which means that, for creating 5 trucks arriving at <i>truckEntry</i>, the inject function needs to be invoked in the <i>&quot;On startup&quot;</i> procedure of <i>Main</i> in the following way: <code>truckEntry.inject(5)</code>.</p><p>For simplicity, the <i>GoToLoadingSite</i> activity of the DPMN model is discarded.</p><figure id="ImplementationWithAnyLogic-2__lof__78"><figcaption><span class="role-label">Figure <span class="role-number">5-22</span>. </span>An AnyLogic process diagram for the Load-Haul-Dump business process.</figcaption><img alt="???" height="245" src="DES-DPMN-OESjs-Simio-AnyLogic_files/AnyLogic-Load-Haul-Dump-Screenshot.png" width="712" /></figure><p>As explained above, the activity type <i>Load</i> is implemented as a <i>Service</i> element with a <i>&quot;Delay time&quot;</i> of &quot;uniform(10,20)&quot; and the field <i>&quot;Resource pool&quot;</i> set to &quot;wheelLoaders&quot; with <i>&quot;number of units&quot;</i> set to 1.</p><p>All other activity types are implemented as <i>Delay</i> elements (with a <i>&quot;Delay time&quot;</i> provided by their <i>duration</i> function defined in the class model).</p><p>The two decision diamonds of the DPMN model are implemented with corresponding <i>&quot;SelectOutput&quot;</i> elements called &quot;test_if_job_done_1&quot; and &quot;test_if_job_done_2&quot;.</p><blockquote class="role-attention"><p>Unfortunately, PN modeling tools, like AnyLogic, do not support the general concept of activities (and Activity Networks), but only the special concept of <em>processing activities</em>. A processing activity has a <em>processing object</em> (&quot;entity&quot;) as a mandatory participant, in addition to resource objects. While in a PN model, processing nodes do have a location and a <em>processing capacity</em> (the number of processing objects that can be processed in parallel), the nodes of an Activity Network (like the Load-Haul-Dump model), representing pure activities, in general do neither have a processing capacity nor a location.</p><p>For instance, in the AnyLogic Load-Haul-Dump model above, trucks are processing objects and the processing activity <i>Load</i> is performed at the processing node <i>Load</i> by a wheel loader that is processing a truck. Consequently, the <i>Load</i>, <i>Haul</i>, <i>Dump</i> and <i>GoBack</i> elements in the AnyLogic process diagram do not represent activities, but rather processing nodes. </p></blockquote></details></section><section class="role-section2" id="ImplementationWithSimio-2"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.2.3</span>. </span>Implementation with Simio</h3><p></p></section></section><section class="role-section1" id="index-7"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">5.3</span>. </span>Diagnostic Clinic</h2><p>.</p><section class="role-section2" id="ImplementationWithSimio-3"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.3.1</span>. </span>Implementation with Simio</h3><p></p></section><section class="role-section2" id="ImplementationWithAnyLogic-3"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">5.3.2</span>. </span>Implementation with AnyLogic</h3><p></p></section></section></section><div class="role-backmatter" id="backmatter"><section class="role-section1" id="Bibliography"><h2 class="role-section1-title">Bibliography</h2><ul><li>Schruben, L.W. 1983. Simulation Modeling with Event Graphs. <i>Communications of the ACM</i> 26, pp. 957-963.</li><li>Standridge, C.R. 2013. <i>Beyond Lean: Simulation in Practice</i>, Second Edition, Open Access book, available from <a href="https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books">https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books</a>.</li><li>Wagner, G. 2017a. An Abstract State Machine Semantics for Discrete Event Simulation. In <i>Proceedings of the 2017 Winter Simulation Conference</i>. Piscataway, NJ: IEEE. Available from <a href="https://www.informs-sim.org/wsc17papers/includes/files/056.pdf">https://www.informs-sim.org/wsc17papers/includes/files/056.pdf</a>.</li><li>Wagner, G. 2017b. Sim4edu.com – Web-Based Simulation for Education. <i>Proceedings of the 2017 Winter Simulation Conference</i>. Piscataway, NJ: IEEE.</li><li>Wagner, G. 2018a. Discrete Event Process Modeling Notation (DPMN). Language Reference. Available from <a href="https://sim4edu.com/reading/DPMN">https://sim4edu.com/reading/DPMN</a>.</li><li>Wagner, G. 2018b. Information and Process Modeling for Simulation – Part I: Objects and Events. Journal of Simulation Engineering, vol. 1, 2018. Available from <a href="https://articles.jsime.org/1/1">https://articles.jsime.org/1/1</a>.</li></ul></section><section class="role-index" id="_index"><h1 class="role-index-title">Index</h1></section></div></section><div class="role-footnotes"><hr class="role-footnote-separator" /><div class="role-footnote" id="__FN1"><a class="role-footnote-number" href="#__FNR1">[1]</a> See Section 10.2.2 in the BPMN 2.0 specification. This enumeration should be extended by adding artificial agents, such as robots, embedded systems and software systems.</div></div></body></html>