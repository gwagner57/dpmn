<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8" /><title>Object Event Modeling and Simulation (OEM&amp;S) of Manufacturing Systems</title><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="ManufacturingDevTutorial_files/ebook.css" rel="stylesheet" type="text/css" /><meta content="This article shows how to create, and run, a discrete event simulation model with the JavaScript-based simulation framework OESjs available on Sim4edu.com, which implements the Object Event Simulation (OES) paradigm, representing a general Discrete Event Simulation approach based on object-oriented modeling and event scheduling. In OES, a model normally defines various types of objects and events, but OES also supports models without explicit events, using fixed-increment time progression corresponding to implicit time events ('ticks')." name="description" /><style>
div.role-book-title-div {
  text-align: center;
}
h1.role-book-title {
  margin: 4em 0;
  padding-bottom: 0;
  border-bottom-style: none;
}
span.button {
  outline: 1px solid;
  background: aliceblue;
}
}</style></head><body><section class="role-book" id="ManufacturingDevTutorial"><div class="role-book-title-div"><h1 class="role-book-title">Object Event Modeling and Simulation of Manufacturing Systems</h1><div class="role-content" id="ManufacturingDevTutorial-content-1"><div id="ManufacturingDevTutorial-content-1__subtitle">An introductory tutorial about modeling and simulation of manufacturing systems using the modeling languages <em>UML</em> and <em>DPMN</em> as well as the simulation platforms <em>OESjs</em> and <em>AnyLogic</em>.</div><div id="ManufacturingDevTutorial-content-1__authors">Gerd Wagner <a href="mailto:G.Wagner@b-tu.de">G.Wagner@b-tu.de</a></div><p>This tutorial article, which extends a tutorial paper presented at the Summer Simulation Conference 2019, is based on material from the tutorial <em><a href="https://articles.jsime.org/1/1">Information and Process Modeling for Simulation – Part I: Objects and Events</a></em> by Gerd Wagner and the Open Access book <em><a href="https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books">Beyond Lean: Simulation in Practice</a></em> by Charles R. Standridge.</p><p>Copyright © 2019 G. Wagner (<a href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC</a>)</p><p>Published 2019-07-22</p><h2>Abstract</h2><p>This tutorial shows how to use UML Class Diagrams and Event-Graph-based <em>DPMN Process Diagrams</em> for <em>Object Event Modeling</em> at all three levels of model-driven simulation engineering: for making conceptual simulation models, for making platform-independent simulation design models, and for making platform-specific, executable simulation models. UML Class Diagrams allow defining the types of objects, events and activities, thus creating a foundation for DPMN Process Diagrams. The proposed modeling approach is presented by showing how to model simple types of manufacturing systems: single workstations, workstations in a series, and job shops.</p><p>This tutorial is also available in the following formats: <a href="ManufacturingDevTutorial_files/ManufacturingDevTutorial.pdf">PDF</a></p></div></div><div class="role-frontmatter" id="frontmatter"><section class="role-toc" id="toc"><h1 class="role-toc-title">Table of Contents</h1><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-lof"><a class="role-lof-ref" href="#lof">List of Figures</a></li><li class="role-booklist-entry booklist-entry-for-lot"><a class="role-lot-ref" href="#lot">List of Tables</a></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#chIntroduction"><span class="role-label"><span class="role-number">1</span>. </span>Introduction</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secMDE"><span class="role-label"><span class="role-number">1.1</span>. </span>Model-Driven Engineering</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secUML"><span class="role-label"><span class="role-number">1.2</span>. </span>Information Modeling with UML Class Diagrams</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secBPMN"><span class="role-label"><span class="role-number">1.3</span>. </span>Process Modeling with BPMN and DPMN</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#chSingleWS"><span class="role-label"><span class="role-number">2</span>. </span>Single Workstation Systems</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secSingleWsCM"><span class="role-label"><span class="role-number">2.1</span>. </span>Conceptual Model 1: Based on Objects and Events</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secSingleWsActivityCM"><span class="role-label"><span class="role-number">2.2</span>. </span>Conceptual Model 2: Based on Objects, Events and Activities</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secSingleWsDesM"><span class="role-label"><span class="role-number">2.3</span>. </span>Making Design Models</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#subsecDesModel0"><span class="role-label"><span class="role-number">2.3.1</span>. </span>Design Model 1.1: Abstracting away from individual parts and processing start events</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#subsecDesModel1"><span class="role-label"><span class="role-number">2.3.2</span>. </span>Design Model 1.2: Abstracting away from individual parts, only</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#subsecDesModel2"><span class="role-label"><span class="role-number">2.3.3</span>. </span>Design Model 1.3: Considering individual parts and their Mean Time in System</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#subsecDesModel3"><span class="role-label"><span class="role-number">2.3.4</span>. </span>Design Model 2.1: Using a Processing activity</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secSingleWsDetractors"><span class="role-label"><span class="role-number">2.4</span>. </span>Modeling Detractors to Workstation Performance</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#subsecDesModel4"><span class="role-label"><span class="role-number">2.4.1</span>. </span>Design Model 2.2: Considering machine breakdowns</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#subsecDesModel5"><span class="role-label"><span class="role-number">2.4.2</span>. </span>Design Model 2.3: Considering defective parts</a></li><li class="role-booklist-entry booklist-entry-for-section2"><a class="role-section2-ref" href="#subsecDesModel6"><span class="role-label"><span class="role-number">2.4.3</span>. </span>Design Model 2.4: Considering workstation setup</a></li></ul></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#chWsSeries"><span class="role-label"><span class="role-number">3</span>. </span>Serial Manufacturing Systems</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secWsSeriesOf2"><span class="role-label"><span class="role-number">3.1</span>. </span>Design Model 3.1: A Series of Two Workstations</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secWsSeriesGeneric"><span class="role-label"><span class="role-number">3.2</span>. </span>Design Model 3.2: A Generic Model of Workstations in a Series without Blocking</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secWsSeriesWithBlockingGeneric"><span class="role-label"><span class="role-number">3.3</span>. </span>Design Model 3.3: A Generic Model of Workstations in a Series with Blocking</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-chapter"><a class="role-chapter-ref" href="#chJobShops"><span class="role-label"><span class="role-number">4</span>. </span>Job Shops</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secJobShopOf2"><span class="role-label"><span class="role-number">4.1</span>. </span>Design Model 4.1: A Job Shop Consisting of Two Workstations</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-appendix"><a class="role-appendix-ref" href="#appOESjs"><span class="role-label"><span class="role-number">A</span>. </span>Simulation with OESjs</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel1"><span class="role-label"><span class="role-number">A.1</span>. </span>Implementing Design Model 1.1</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel2"><span class="role-label"><span class="role-number">A.2</span>. </span>Implementing Design Model 1.2</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel3"><span class="role-label"><span class="role-number">A.3</span>. </span>Implementing Design Model 1.3</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel4"><span class="role-label"><span class="role-number">A.4</span>. </span>Implementing Design Model 2.1</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel5"><span class="role-label"><span class="role-number">A.5</span>. </span>Implementing Design Model 2.2</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel6"><span class="role-label"><span class="role-number">A.6</span>. </span>Implementing Design Model 2.3</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel7"><span class="role-label"><span class="role-number">A.7</span>. </span>Implementing Design Model 2.4</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel8"><span class="role-label"><span class="role-number">A.8</span>. </span>Implementing Design Model 8</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel9"><span class="role-label"><span class="role-number">A.9</span>. </span>Implementing Design Model 9</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-appendix"><a class="role-appendix-ref" href="#appAnyLogic"><span class="role-label"><span class="role-number">B</span>. </span>Simulation with AnyLogic</a><ul class="role-booklist-entries"><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel1-2"><span class="role-label"><span class="role-number">B.1</span>. </span>Implementing Design Model 1.1</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel2-2"><span class="role-label"><span class="role-number">B.2</span>. </span>Implementing Design Model 1.2</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel3-2"><span class="role-label"><span class="role-number">B.3</span>. </span>Implementing Design Model 1.3</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel4-2"><span class="role-label"><span class="role-number">B.4</span>. </span>Implementing Design Model 2.1</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel5-2"><span class="role-label"><span class="role-number">B.5</span>. </span>Implementing Design Model 2.2</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel6-2"><span class="role-label"><span class="role-number">B.6</span>. </span>Implementing Design Model 2.3</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel7-2"><span class="role-label"><span class="role-number">B.7</span>. </span>Implementing Design Model 2.4</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel8-2"><span class="role-label"><span class="role-number">B.8</span>. </span>Implementing Design Model 8</a></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#secModel9-2"><span class="role-label"><span class="role-number">B.9</span>. </span>Implementing Design Model 9</a></li></ul></li><li class="role-booklist-entry booklist-entry-for-section1"><a class="role-section1-ref" href="#Bibliography">Bibliography</a></li><li class="role-booklist-entry booklist-entry-for-index"><a class="role-index-ref" href="#_index">Index</a></li></ul></section><section class="role-lof" id="lof"><h1 class="role-lof-title">List of Figures</h1><ul class="role-booklist-entries"><li class="role-booklist-entry"><a class="role-figure-ref" href="#secMDE__figMDD"><span class="role-label"><span class="role-number">1-1</span>. </span>From conceptualization via design to implementation</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#chSingleWS__figWorkStationSVG"><span class="role-label"><span class="role-number">2-1</span>. </span>A workstation with an input buffer for waiting parts.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCIM"><span class="role-label"><span class="role-number">2-2</span>. </span>A conceptual information model of a single workstation system.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCPM"><span class="role-label"><span class="role-number">2-3</span>. </span>A conceptual process model of a single workstation system.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secSingleWsActivityCM__figWorkstationActivityCIM"><span class="role-label"><span class="role-number">2-4</span>. </span>A conceptual information model of object, event and activity types.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secSingleWsActivityCM__figWorkstationActivityCPM"><span class="role-label"><span class="role-number">2-5</span>. </span>A conceptual process model based on events and activities.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel0__figWS0IDM"><span class="role-label"><span class="role-number">2-6</span>. </span>Information design model 1.1 does neither consider individual parts nor processing start events.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel0__figWS0PDM"><span class="role-label"><span class="role-number">2-7</span>. </span>Process design model 1.1 based on the information design model 1.1 shown above.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel1__figWorkstationIDM1"><span class="role-label"><span class="role-number">2-8</span>. </span>An information design model that does not consider individual parts.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel1__figWS1PDM"><span class="role-label"><span class="role-number">2-9</span>. </span>A process design model based on the previous class diagram.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel2__figWorkstationIDM2"><span class="role-label"><span class="role-number">2-10</span>. </span>An information design model with a <i>waitingParts</i> input buffer.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel2__figWS2PDM"><span class="role-label"><span class="role-number">2-11</span>. </span>A process design model with a <i>waitingParts</i> input buffer.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel3__figWS3IDM"><span class="role-label"><span class="role-number">2-12</span>. </span>An information design model with a <i>Processing</i> activity type.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#subsecDesModel3__figWS3PDM"><span class="role-label"><span class="role-number">2-13</span>. </span>A process design model with a <i>Processing</i> activity.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secWsSeriesOf2__figWsSeriesOf2IDM"><span class="role-label"><span class="role-number">3-1</span>. </span>An information design model for a series of two workstations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secWsSeriesOf2__figWsSeriesOf2PDM"><span class="role-label"><span class="role-number">3-2</span>. </span>An attempt of a process design model for a series of two workstations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secWsSeriesGeneric__figWsSeriesIDM"><span class="role-label"><span class="role-number">3-3</span>. </span>A generic information design model for any series of workstations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secWsSeriesGeneric__figWsSeriesPDM"><span class="role-label"><span class="role-number">3-4</span>. </span>A generic process design model for any series of workstations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secWsSeriesWithBlockingGeneric__figWsSeriesWithBlockingIDM"><span class="role-label"><span class="role-number">3-5</span>. </span>A generic information design model for a series of workstations with blocking.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secWsSeriesWithBlockingGeneric__figWsSeriesWithBlockingPDM"><span class="role-label"><span class="role-number">3-6</span>. </span>A generic process design model for a series of workstations with blocking.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secJobShopOf2__figJobShopOf2IDM"><span class="role-label"><span class="role-number">4-1</span>. </span>An information design model for a job shop with two workstations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secJobShopOf2__figJobShopOf2PDM"><span class="role-label"><span class="role-number">4-2</span>. </span>A process design model for a job shop with two workstations.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secModel1__figWS0IDM_1"><span class="role-label"><span class="role-number">A-1</span>. </span>Information design model 1.1.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secModel1__figWS0PDM_1"><span class="role-label"><span class="role-number">A-2</span>. </span>Process design model 1.1.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secModel1-2__figWS0IDM_2"><span class="role-label"><span class="role-number">B-1</span>. </span>Information design model 1.1.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secModel1-2__figWS0PDM_2"><span class="role-label"><span class="role-number">B-2</span>. </span>Process design model 1.1.</a></li><li class="role-booklist-entry"><a class="role-figure-ref" href="#secModel1-2__figDesM1_AnyLogic"><span class="role-label"><span class="role-number">B-3</span>. </span>The Main Agent window showing the first AnyLogic implementation of design model 1.1.</a></li></ul></section><section class="role-lot" id="lot"><h1 class="role-lot-title">List of Tables</h1></section></div><section class="role-chapter" id="chIntroduction"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">1</span>. </span>Introduction</h1><p>Due to their expressiveness and wide adoption as modeling standards, the <i>Class Diagrams</i> of the <i>Unified Modeling Language (UML)</i> and the <i>Process Diagrams</i> of the <i>Business Process Modeling Notation (BPMN)</i> are the most appropriate choices as information and process modeling languages for a model-based simulation engineering approach. However, since they have not been designed for this purpose, we may have to restrict, modify and extend them in a suitable way.</p><p>The <i>Event Graph (EG)</i> diagrams of Schruben (1983) allow defining computationally complete process design models for event-based simulation, which can be viewed as the most fundamental <i>Discrete Event Simulation (DES)</i> paradigm. In these diagrams, circles represent event types, and arrows between two event type circles <i>A</i> and <i>B</i> represent <i>event scheduling</i> with a <i>future events list</i> in the sense that an occurrence of an event of type <i>A</i> in a simulation run causes the simulator to schedule a future event of type <i>B</i>. Wagner (2018a+b) has extended Event Graphs by adding elements from BPMN, resulting in the <i>Discrete Event Process Modeling Notation (DPMN)</i>.</p><p>Wagner (2018b) has proposed <i>Object Event Modeling and Simulation (OEM&amp;S)</i> as a new model-based paradigm for DES combining Object-Oriented (OO) Modeling with the event scheduling paradigm of Event Graphs. In the OEM paradigm, the relevant <i>object types</i> and <i>event types</i> are described in an information model, which is the basis for making a process model. A modeling approach that follows the OEM paradigm is called an <i>OEM approach</i>. Such an approach needs to choose, or define, an information modeling language and a process modeling language.</p><p>We propose an OEM approach based on UML Class Diagrams for conceptual information modeling and information design modeling, as well as BPMN Process Diagrams for conceptual process modeling and DPMN Process Diagrams for process design modeling. In the proposed approach, object types and event types are modeled as special categories of classes in a UML Class Diagram. <i>Random variables</i> are modeled as a special category of class-level operations constrained to comply with a specific probability distribution such that they can be implemented as static methods of a class. <i>Queues</i> are not modeled as objects, but rather as ordered association ends, which can be implemented as collection-valued reference properties. Finally, <i>event rules</i>, which include <i>event routines</i>, are modeled both as BPMN/DPMN process diagrams and in pseudo-code such that they can be implemented in the form of special <i>onEvent</i> methods of event classes.</p><p>An OEM approach results in a simulation design model that has a well-defined operational semantics, as shown in (Wagner, 2017a). Such a model can, in principle, be implemented with any object-oriented (OO) simulation technology. However, a straightforward implementation can only be expected from a technology that implements the OEM&amp;S paradigm, such as the <i>OES JavaScript (OESjs)</i> framework presented in (Wagner, 2017b).</p><p>The examples discussed in this tutorial, and their descriptions, are adopted from the excellent Open Access book <i><a href="https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books">Beyond Lean: Simulation in Practice</a></i> by Standridge (2013).</p><section class="role-section1" id="secMDE"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.1</span>. </span>Model-Driven Engineering</h2><p><em>Model-Driven Engineering (MDE)</em>, also called <i>model-driven development</i>, is a well-established paradigm in software engineering. Since simulation engineering can be viewed as a special case of software engineering, it is natural to apply the ideas of MDE also to simulation engineering.</p><p>In MDE, there is a distinction between three kinds of models as engineering artifacts created in the analysis, design and implementation phases of a development project:</p><ol><li><i>domain models</i> (also called <i>conceptual models</i>), which are solution-independent,</li><li><i>design models</i>, which represent platform-independent solution designs,</li><li><i>implementation models</i>, which are platform-specific.</li></ol><p>Domain models are solution-independent descriptions of a problem domain produced in the analysis phase. A domain model may include both descriptions of the domain's state structure (in conceptual <i>information models</i>) and descriptions of its processes (in conceptual <i>process models</i>). They are solution-independent, or computation-independent, in the sense that they are not concerned with making any system design choices or with other computational issues. Rather, they focus on the perspective and language of the subject matter experts for the domain under consideration.</p><p>In the design phase, first a platform-independent design model, as a general computational solution, is developed on the basis of the domain model. The same domain model can potentially be used to produce a number of (even radically) different design models. Then, by taking into consideration a number of implementation issues ranging from architectural styles, nonfunctional quality criteria to be maximized (e.g., performance, adaptability) and target technology platforms, one or more platform-specific implementation models are derived from the design model. These one-to-many relationships between conceptual models, design models and implementation models are illustrated in <a class="role-figure-ref" href="#secMDE__figMDD"><span class="role-label">Figure <span class="role-number">1-1</span></span></a>.</p><figure id="secMDE__figMDD"><figcaption><span class="role-label">Figure <span class="role-number">1-1</span>. </span>From conceptualization via design to implementation</figcaption><div><img alt="???" src="ManufacturingDevTutorial_files/MDD.svg" width="500" /></div></figure><p>A model does not consist of just one model diagram including all viewpoints or aspects of the system to be developed. Rather it consists of a set of models, one (or more) for each viewpoint. The two most important viewpoints, crosscutting all three modeling levels: domain, design and implementation, are</p><ol><li><b><i>information modeling</i></b>, which is concerned with the <b><i>state structure</i> </b>of the domain, design or implementation;</li><li><b><i>process modeling</i></b>, which is concerned with the <b><i>dynamics</i> </b>of the domain, design or implementation.</li></ol><p></p></section><section class="role-section1" id="secUML"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.2</span>. </span>Information Modeling with UML Class Diagrams</h2><p>Conceptual information modeling is mainly concerned with describing the relevant <b><i>entity types</i></b> of a real-world domain and the relationships between them, while information design and implementation modeling are concerned with describing the <i>logical</i> (or <i>platform-independent</i>) and <i>platform-specific</i> data structures (in the form of <b><i>classes</i></b>) for designing and implementing a software system or simulation. The most important kinds of relationships between entity types to be described in an information model are <b><i>associations</i></b> and <b><i>subtype</i></b>/<i>supertype</i> relationships, which are called ‘generalizations’ in <i>UML</i>.</p><p>In UML Class Diagrams, an entity type is described with a name, and possibly with a list of <b><i>properties</i></b> and <b><i>operations</i></b> (called <i>methods</i> when implemented), in the form of a <i>class rectangle</i> with one, two or three compartments, depending on the presence of properties and operations. <b><i>Integrity constraints</i></b>, which are conditions that must be satisfied by the instances of a type, can be expressed in special ways when defining properties or they can be explicitly attached to an entity type in the form of an <i>invariant</i> box.</p><p>An <b><i>association</i></b> between two entity types is expressed as a connection line between the two class rectangles representing the entity types. The connection line is annotated with <i>multiplicity</i> expressions at both ends. A <b><i>multiplicity</i></b> expression has the form m..n where <i>m</i> is a non-negative natural number denoting the <i>minimum cardinality</i>, and <i>n</i> is a positive natural number (or the special symbol * standing for <i>unbounded)</i> denoting the maximum cardinality, of the sets of associated entities. Typically, a multiplicity expression states an integrity constraint. For instance, the multiplicity expression 1..3 means that there are at least 1 and at most 3 associated entities. However, the special multiplicity expression <code>0..*</code> (also expressed as <code>*</code>) means that there is no constraint since the minimum cardinality is zero and the maximum cardinality is unbounded.</p><p>A good overview of the most recent version of UML (UML 2.5) is provided by <a href="https://www.uml-diagrams.org/uml-25-diagrams.html">www.uml-diagrams.org/uml-25-diagrams.html</a>.</p></section><section class="role-section1" id="secBPMN"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">1.3</span>. </span>Process Modeling with BPMN and DPMN</h2><p>The <em>Business Process Modeling Notation (BPMN)</em> is an activity-based graphical modeling language for defining business processes following the flow-chart metaphor. In 2011, the Object Management Group has released version 2.0 of BPMN with an optional execution semantics based on Petri-net-style token flows.</p><p>The most important elements of a BPMN process model are listed in <a href="#secBPMN__tblBPMN"></a>.</p><table border="1" id="secBPMN__tblBPMN"><tbody><tr><th>Name of element</th><th>Meaning</th><th>Visual symbol(s)</th></tr><tr><td><p>Event</p></td><td><p><q>Something that 'happens' during the course of a process</q>, affecting the process flow. <q>There are three types of Events, based on when they affect the flow</q>: a <em>Start Event</em> is drawn as a circle with a thin border line, while an <em>Intermediate Event</em> has a double border line and an <em>End Event</em> has a thick border line.</p></td><td><img src="ManufacturingDevTutorial_files/Events.svg" /></td></tr><tr><td><p>Activity</p></td><td><p><q>Work that is performed within a Business Process</q>. A <em>Task</em> is an atomic Activity, while a <em>Sub-Process</em> is a <em>composite</em> Activity. A Sub-Process can be either in a <em>collapsed</em> or in an <em>expanded</em> view.</p></td><td><img src="ManufacturingDevTutorial_files/Activity.svg" /></td></tr><tr><td><p>Gateway</p></td><td><p>A Gateway is a node for branching or merging control flows. A Gateway with an &quot;X&quot; symbol denotes an Exclusive OR-Split for conditional branching, if there are 2 or more output flows, or an Exclusive OR-Join, if there are 2 or more input flows. A Gateway with a plus symbol denotes an AND-Split for parallel branching, if there are 2 or more output flows, or an AND-Join, if there are 2 or more input flows. A Gateway can have both input and output flows. </p></td><td><img src="ManufacturingDevTutorial_files/Gateways.svg" /></td></tr><tr><td><p>Sequence Flow</p></td><td><p>An arrow expressing the temporal order of Events, Activities, and Gateways. A <em>Conditional Sequence Flow</em> arrow starts with a diamond and is annotated with a condition (in brackets).</p></td><td><img src="ManufacturingDevTutorial_files/image11.png" /> <img src="ManufacturingDevTutorial_files/ConditionalSequenceFlow.svg" /></td></tr><tr><td><p>Data Object</p></td><td><p>Data Objects may be associated with Events or Activities, providing a context for reading/writing data. A unidirectional dashed arrow denotes reading, while a bidirectional dashed arrow denotes reading/writing.</p></td><td><img src="ManufacturingDevTutorial_files/DataObject.svg" /></td></tr></tbody></table><p>A good modeling tool, with the advantages of an online solution, is the <i>Signavio Process Editor</i>, which is free for academic use (<a href="http://www.signavio.com/bpm-academic-initiative">www.signavio.com/bpm-academic-initiative</a>).</p><p>BPMN process diagrams can be used for making</p><ol><li><b><i>conceptual process models</i> </b>, e.g., for documenting existing business processes and for designing new business processes;</li><li><b><i>process automation models</i> </b>for specific process automation platforms (that allow partially or fully automating a business process) by adding platform-specific technical details in the form of model annotations that are not visible in the diagram.</li></ol><p>However, the BPMN process diagram language has several semantic issues and is not expressive enough for making platform-independent computational <i>process design models</i> that can be used both for designing DES models and as a general basis for deriving platform-specific process automation models.</p><p>DPMN adapts the language of BPMN Process Diagrams for the purpose of simulation design modeling where a process model must represent a computationally complete process specification. While large parts of BPMN’s vocabulary, visual syntax and informal semantics can be preserved in DPMN, a number of modeling elements need to be modified.</p><p>DPMN is a BPMN-based diagram language for making (computational) process design models for discrete event simulation. It combines the intuitive flowchart modeling style of BPMN with the semantics provided by the <em>event scheduling</em> arrows of <em>Event Graphs</em> (Schruben 1983) and the rigorous <em>event-rule</em>-based semantics of the <i>Object Event Modeling and Simulation</i> paradigm (Wagner 2017a+2018b).</p><p>DPMN adopts and adapts the syntax and semantics of BPMN in the following way:</p><ol><li>A DPMN diagram has an underlying UML class diagram defining its (object and event) types.</li><li>DPMN Sequence Flow arrows pointing to an event circle denote <i>event scheduling</i>. They must be annotated by event attribute assignments for creating/scheduling a new event.</li><li>DPMN has three special forms of Text Annotation: <ol><li>Text Annotations attached to Event circles for declaring event rule variables,</li><li>Text Annotations attached to Sequence Flow arrows pointing to Event circles for the occurrence time or delay of the events to be scheduled,</li><li>Text Annotations attached to Sequence Flow arrows pointing to Event circles for event attribute assignments.</li></ol></li><li>DPMN has an extended form of Data Object visually rendered as rectangles with two compartments: <ol><li>a first compartment showing an object variable name and an object type name separated by a colon, together with a binding of the object variable to a specific object;</li><li>a second compartment containing a block of state change statements (such as attribute value assignments).</li></ol></li><li>DPMN has an extended form of Activity rectangles, which may include an Event circle for exposing the activity's start event (type).</li></ol></section></section><section class="role-chapter" id="chSingleWS"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">2</span>. </span>Single Workstation Systems</h1><p>We consider a workstation (shown in <a class="role-figure-ref" href="#chSingleWS__figWorkStationSVG"><span class="role-label">Figure <span class="role-number">2-1</span></span></a>) that operates 168 hours per month. Customer demand per month is 1680 parts or 10 parts per hour, resulting in a <i>takt time</i> of 6 minutes. The workstation's processing time varies between 3 and 8 minutes with a mode of 4 minutes. Inbound arrival of parts cannot be controlled, and is, consequently, subject to great variations.</p><figure id="chSingleWS__figWorkStationSVG"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-1</span>. </span>A workstation with an input buffer for waiting parts.</figcaption><img alt="workstation with input buffer" src="ManufacturingDevTutorial_files/Machinery-with-input-buffer.svg" width="400" /></figure><section class="role-section1" id="secSingleWsCM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Conceptual Model 1: Based on Objects and Events</h2><p>Single workstation systems contain two types of objects: workstations and parts to be processed. They can be described with the help of four types of instantaneous events:</p><ol><li>Part arrivals: a part arrives at a workstation</li><li>Processing starts: the processing of a part at a workstation starts</li><li>Processing ends: the processing of a part at a workstation ends</li><li>Part departures: a part departs from a workstation</li></ol><p>These two object types and four event types can be included in a UML class diagram expressing a <i>conceptual information model</i>, as shown in <a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCIM"><span class="role-label">Figure <span class="role-number">2-2</span></span></a>.</p><figure id="secSingleWsCM__figWorkstationCIM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-2</span>. </span>A conceptual information model of a single workstation system.</figcaption><img src="ManufacturingDevTutorial_files/WS_CIM.svg" width="400" /></figure><p>Notice that the association between the object types <i>workstations</i> and <i>parts</i> defines an input buffer <i>waiting parts</i> for workstations. The associations between event types and object types define the participation of objects in events. For instance, both a part and a workstation participate in a part arrival event.</p><p>The conceptual process model shown in <a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCPM"><span class="role-label">Figure <span class="role-number">2-3</span></span></a> is based on the object and event types defined in the UML Class Diagram of <a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCIM"><span class="role-label">Figure <span class="role-number">2-2</span></span></a>.</p><figure id="secSingleWsCM__figWorkstationCPM" style="text-align:center;"><figcaption><span class="role-label">Figure <span class="role-number">2-3</span>. </span>A conceptual process model of a single workstation system.</figcaption><img src="ManufacturingDevTutorial_files/WS_CPM.svg" /></figure></section><section class="role-section1" id="secSingleWsActivityCM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.2</span>. </span>Conceptual Model 2: Based on Objects, Events and Activities</h2><p>Conceptually, an activity is a composite event that is temporally framed by a pair of start and end events. Consequently, whenever a model contains a pair of related start and end event types, like <i>processing start</i> and <i>processing end </i>in the models of <a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCIM"><span class="role-label">Figure <span class="role-number">2-2</span></span></a> and <a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCPM"><span class="role-label">Figure <span class="role-number">2-3</span></span></a>, they can be replaced with a corresponding activity type, like <i>processing</i>, as shown in <a class="role-figure-ref" href="#secSingleWsActivityCM__figWorkstationActivityCIM"><span class="role-label">Figure <span class="role-number">2-4</span></span></a> and <a class="role-figure-ref" href="#secSingleWsActivityCM__figWorkstationActivityCPM"><span class="role-label">Figure <span class="role-number">2-5</span></span></a>.</p><figure id="secSingleWsActivityCM__figWorkstationActivityCIM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-4</span>. </span>A conceptual information model of object, event and activity types.</figcaption><img src="ManufacturingDevTutorial_files/WS-Activity_CIM.svg" width="400" /></figure><figure id="secSingleWsActivityCM__figWorkstationActivityCPM" style="text-align:center;"><figcaption><span class="role-label">Figure <span class="role-number">2-5</span>. </span>A conceptual process model based on events and activities.</figcaption><img src="ManufacturingDevTutorial_files/WS-Activity_CPM.svg" /></figure></section><section class="role-section1" id="secSingleWsDesM"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.3</span>. </span>Making Design Models</h2><p>As a simulation design choice, we may define the workstation's processing time to be triangularly distributed with a mode of 4 minutes, a minimum of 3 minutes and a maximum of 8 minutes. Notice that the triangular distribution is typically used when no data is available except (estimates of) the minimum, maximum and mean (or mode). The fact that inbound arrival of parts is not well controlled can be modeled by assuming the practical worst case represented by an exponential distribution with a mean equal to the takt time of 6 minutes.</p><p>Not all object types and event types described in the conceptual model of <a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCIM"><span class="role-label">Figure <span class="role-number">2-2</span></span></a> need to be included in a simulation design model. For simplification, we may drop either the part departure or the processing end event types since events of these two types can be considered to temporally coincide and, thus, one of them may be merged into the other one. </p><p>Further simplification options are (a) abstracting away from individual parts and the (composition of the) input buffer, and (b) dropping processing start events, which is possible because any processing start event immediately follows either a part arrival or a processing end event. </p><p>In our first design model, developed in <a class="role-section2-ref" href="#subsecDesModel0"><span class="role-label">Section <span class="role-number">2.3.1</span></span></a>, we adopt both simplifications, resulting in a minimal model. In our second design model, developed in <a class="role-section2-ref" href="#subsecDesModel1"><span class="role-label">Section <span class="role-number">2.3.2</span></span></a>, we keep the processing start events, but still abstract away from individual parts, only considering the length of the input buffer. Both models allow computing buffer length statistics, but not the mean time a part spends in the system. For being able to compute this statistics, we may choose to model individual parts and the composition of the input buffer (typically, as a first-in-first-out buffer), as we do in our third design model discussed in <a class="role-section2-ref" href="#subsecDesModel2"><span class="role-label">Section <span class="role-number">2.3.3</span></span></a>.</p><section class="role-section2" id="subsecDesModel0"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.3.1</span>. </span>Design Model 1.1: Abstracting away from individual parts and processing start events</h3>For making a simulation design model for the single workstation system described in the conceptual model presented in <a class="role-section1-ref" href="#secSingleWsCM"><span class="role-label">Section <span class="role-number">2.1</span></span></a>, a possible simplification, and simulation design choice, is to abstract away from individual parts and the composition of the input buffer, and instead only consider the length of the input buffer.<p>There are two situations when processing can be started: either when the input buffer is empty and a new part arrives, or when the input buffer is not empty and processing ends. Therefore, any processing start event immediately follows either a part arrival or a processing end event, and we may abstract away from processing start events and drop the corresponding event type from the design model.</p><p>These two simplifications result in the simulation design model shown in <a class="role-figure-ref" href="#subsecDesModel0__figWS0IDM"><span class="role-label">Figure <span class="role-number">2-6</span></span></a> and <a class="role-figure-ref" href="#subsecDesModel0__figWS0PDM"><span class="role-label">Figure <span class="role-number">2-7</span></span></a>.</p><figure id="subsecDesModel0__figWS0IDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-6</span>. </span>Information design model 1.1 does neither consider individual parts nor processing start events.</figcaption><img src="ManufacturingDevTutorial_files/WS0_IDM.svg" width="350" /></figure><p>A simulation information design model must distinguish between <i>exogenous</i> and <i>caused</i> (or <i>endogenous</i>) event types. For any exogenous event type, the recurrence of events of that type must be specified, typically in the form of a random variable, but in some cases it may be a constant (like 'on each Monday'). The recurrence defines the elapsed time between two consecutive events of the given type (their inter-occurrence time). It can be specified within the event class concerned in the form of a special method with the predefined name <i>recurrence</i>.</p><p>Notice that the underlining of the random variate functions <i>recurrence()</i> and <i>processingTime()</i> in the class diagram of <a class="role-figure-ref" href="#subsecDesModel0__figWS0IDM"><span class="role-label">Figure <span class="role-number">2-6</span></span></a> means that they are defined as class-level (“static”) operations, which are invoked by using the class name as a prefix, like in <code>PartArrival.recurrence()</code>.</p><figure id="subsecDesModel0__figWS0PDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-7</span>. </span>Process design model 1.1 based on the information design model 1.1 shown above.</figcaption><img src="ManufacturingDevTutorial_files/WS0_PDM.svg" width="500" /></figure><p>Each Event circle in a DPMN Process Diagram defines an <strong>event rule</strong> consisting of the Data Objects and the outgoing event scheduling arrows attached to it. Each attached Data Object defines an object variable that is bound to a specific object reference passed to the rule invocation via the triggering event expression. It allows accessing the property values of the referenced object both for querying and changing the object state. The second compartment of a DPMN Data Object contains one or more <em>state change statements</em>. All state change statements specified in attached Data Objects are executed first, before any follow-up event is scheduled according to the attached (possibly conditional) event scheduling arrows.</p><p>Process design model 1.1, shown in <a class="role-figure-ref" href="#subsecDesModel0__figWS0PDM"><span class="role-label">Figure <span class="role-number">2-7</span></span></a>, defines two event rules:</p><ol><li>On each <em>part arrival</em>, the input buffer length is incremented by 1 and, if it's equal to 1, a new <em>PartDeparture</em> event is scheduled to occur with a delay provided by invoking the <i>processingTime</i> function defined in the <i>WorkStation</i> object class.</li><li>On each <em>part departure</em> (or <em>processing end</em>), the input buffer length is decremented by 1 and, if the input buffer length is still greater than 0, a new <i>PartDeparture</i> event is scheduled to occur with a delay provided by invoking the function <code>WorkStation.processingTime()</code>.</li></ol><p>The following window allows running an implementation of design model 1.1.</p> <div class="iframe-container"> <iframe id="subsecDesModel0__iframe1"></iframe> </div> <p>The dynamics of a simulation model can be illustrated with the help of a simulation log that shows the sequence of simulation steps of a particular run. Such a log can be created either manually (with paper and pencil), as often taught in simulation courses, or with a simulation tool. The following log has been created by running an OESjs implementation of design model 1.1 (presented in <a class="role-section1-ref" href="#secModel1"><span class="role-label">Section <span class="role-number">A.1</span></span></a>) with a workstation that has initially 3 parts in its input buffer and two initial events: an arrival event and a departure event.</p><table border="1" id="subsecDesModel0__simLogTbl" style="overflow-x: auto;"><thead><tr><th colspan="4">Simulation Log</th></tr><tr><th colspan="2">Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody id="subsecDesModel0__simLog"><tr><td>20</td><td>87.88</td><td>workStation1{ bLen: 0}</td><td>Arr@88.74</td></tr><tr><td>19</td><td>83.72</td><td>workStation1{ bLen: 1}</td><td>Dep@87.88, Arr@88.74</td></tr><tr><td>18</td><td>77.62</td><td>workStation1{ bLen: 0}</td><td>Arr@83.72</td></tr><tr><td>17</td><td>71.21</td><td>workStation1{ bLen: 1}</td><td>Dep@77.62, Arr@83.72</td></tr><tr><td>16</td><td>65.97</td><td>workStation1{ bLen: 0}</td><td>Arr@71.21</td></tr><tr><td>15</td><td>61.51</td><td>workStation1{ bLen: 1}</td><td>Dep@65.97, Arr@71.21</td></tr><tr><td>14</td><td>60.28</td><td>workStation1{ bLen: 2}</td><td>Dep@61.51, Arr@71.21</td></tr><tr><td>13</td><td>56.87</td><td>workStation1{ bLen: 1}</td><td>Arr@60.28, Dep@61.51</td></tr><tr><td>12</td><td>52.04</td><td>workStation1{ bLen: 0}</td><td>Arr@56.87</td></tr><tr><td>11</td><td>47.86</td><td>workStation1{ bLen: 1}</td><td>Dep@52.04, Arr@56.87</td></tr><tr><td>10</td><td>47.02</td><td>workStation1{ bLen: 2}</td><td>Dep@47.86, Arr@56.87</td></tr><tr><td>9</td><td>41.03</td><td>workStation1{ bLen: 1}</td><td>Arr@47.02, Dep@47.86</td></tr><tr><td>8</td><td>40.08</td><td>workStation1{ bLen: 0}</td><td>Arr@41.03</td></tr><tr><td>7</td><td>33.78</td><td>workStation1{ bLen: 1}</td><td>Dep@40.08, Arr@41.03</td></tr><tr><td>6</td><td>24.93</td><td>workStation1{ bLen: 0}</td><td>Arr@33.78</td></tr><tr><td>5</td><td>18.92</td><td>workStation1{ bLen: 1}</td><td>Dep@24.93, Arr@33.78</td></tr><tr><td>4</td><td>12.79</td><td>workStation1{ bLen: 2}</td><td>Dep@18.92, Arr@33.78</td></tr><tr><td>3</td><td>6.69</td><td>workStation1{ bLen: 3}</td><td>Dep@12.79, Arr@33.78</td></tr><tr><td>2</td><td>6.25</td><td>workStation1{ bLen: 4}</td><td>Dep@6.69, Arr@33.78</td></tr><tr><td>1</td><td>1</td><td>workStation1{ bLen: 3}</td><td>Arr@6.25, Dep@6.69</td></tr><tr><td>0</td><td>0</td><td>workStation1{ bLen: 3}</td><td>Arr@1, Dep@1</td></tr></tbody></table> <blockquote class="role-attention"><p>A process model has to provide for the proper processing of simultaneous (or parallel) events. Special attention is required in cases of parallel events for which different processing orders yield different results.</p><p>In the case of model 1.1, there may be situations with parallel arrival and departure events. Such situations are more likely when the granularity of simulation time is low, as in models with discrete time. For instance, using a discrete time model, there may be event pairs like {PartArrival@3, PartDeparture@3} in the Future Events List. However, this does not create any problem for model 1.1, since both possible parallel event processing orders yield the same successor simulation state, as shown below.</p></blockquote><p>A particular processing order for a set of parallel events is called a <em>parallel event serialization (PES)</em>. A process model is <em>PES-independent</em> if for any set of parallel events scheduled during a simulation run, i.e., added to the <em>Future Events List (FEL)</em>, their processing order doesn't matter, that is, different serializations do not create different successor simulation states. This is a desirable property for a process model. If a process model is not PES-independent, one may have to define processing order priorities for event types in order to achieve the intended effects of a set of parallel events.</p><p>The process model defined by <a class="role-figure-ref" href="#subsecDesModel0__figWS0PDM"><span class="role-label">Figure <span class="role-number">2-7</span></span></a> is PES-independent. This can be proven by considering a simulation state with a set of current events to be processed by the simulator and then show that all possible serializations yield the same successor simulation state. Let's consider the simulation state SS = ⟨{inputBufferLength:1}, {A@3, D@3}⟩ at simulation time 3, where S={inputBufferLength:1} represents the system state and FEL = {A@3, D@3} represents the Future Events List. There are two possible serializations of the parallel events in FEL: ⟨A@3, D@3⟩ and ⟨D@3, A@3⟩. For the first of them we obtain the following sequence of rule applications: </p><ol><li>SS' = r<sub>1</sub>(SS) = ⟨{inputBufferLength:2}, {D@3, A@6}⟩, assuming that invoking <i>PartArrival.recurrence()</i> returns 3 as the delay for the next arrival event.</li><li>SS'' = r<sub>2</sub>(SS') = ⟨{inputBufferLength:1}, {A@6, D@5}⟩, assuming that invoking <i>WorkStation.processingTime()</i> returns 2 as the delay for the next departure event.</li></ol><p>The second serialization yields</p><ol><li>SS' = r<sub>2</sub>(SS) = ⟨{inputBufferLength:0}, {A@3, D@5}⟩, assuming that invoking <i>WorkStation.processingTime()</i> returns 2 as the delay for the next departure event .</li><li>SS'' = r<sub>1</sub>(SS') = ⟨{inputBufferLength:1}, {D@5, A@6}⟩, assuming that invoking <i>PartArrival.recurrence()</i> returns 3 as the delay for the next arrival event.</li></ol><p>For both serializations, the resulting simulation state SS'' is the same.</p></section><section class="role-section2" id="subsecDesModel1"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.3.2</span>. </span>Design Model 1.2: Abstracting away from individual parts, only</h3><p>Our second design choice is to keep the pair of processing start and end event types, while still abstracting away from individual parts and the composition of the input buffer, and instead only considering the length of the input buffer. This choice results in the design model 1.2 shown in <a class="role-figure-ref" href="#subsecDesModel1__figWorkstationIDM1"><span class="role-label">Figure <span class="role-number">2-8</span></span></a> and <a class="role-figure-ref" href="#subsecDesModel1__figWS1PDM"><span class="role-label">Figure <span class="role-number">2-9</span></span></a>.</p><figure id="subsecDesModel1__figWorkstationIDM1"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-8</span>. </span>An information design model that does not consider individual parts.</figcaption><img src="ManufacturingDevTutorial_files/WS1_IDM.svg" width="360" /></figure><figure id="subsecDesModel1__figWS1PDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-9</span>. </span>A process design model based on the previous class diagram.</figcaption><img src="ManufacturingDevTutorial_files/WS1_PDM.svg" width="600" /></figure><p>The process design model of <a class="role-figure-ref" href="#subsecDesModel1__figWS1PDM"><span class="role-label">Figure <span class="role-number">2-9</span></span></a> defines three event rules:</p><ol><li>On each <em>part arrival</em>, the input buffer length is incremented by 1 and if the workstation's status is AVAILABLE, then a new <i>ProcessingStart</i> event is scheduled to occur immediately.</li><li>On each <em>processing start</em>, the workstation's status is changed to BUSY and a new <i>ProcessingEnd</i> event is scheduled to occur with a delay provided by invoking the <i>processingTime</i> function defined in the <i>ProcessingStart</i> event class.</li><li>On each <em>processing end</em>, the input buffer length is decremented by 1 and, if the input buffer length is still greater than 0, a new <i>ProcessingStart</i> event is scheduled to occur immediately, otherwise (if the input buffer is empty) the workstation's status is changed to AVAILABLE.</li></ol><p>The following simulation log has been created by running an OESjs implementation of design model 1.2 with an initially busy workstation having 3 parts in its input buffer and two initial events: an arrival event and a processing start event, presented in <a class="role-section1-ref" href="#secModel2"><span class="role-label">Section <span class="role-number">A.2</span></span></a>. The workstation attribute <em>status</em> has the possible values 1 for &quot;available&quot; and 2 for &quot;busy&quot;. </p><table border="1" id="subsecDesModel1__simLogTbl" style="overflow-x: auto;"><thead><tr><th colspan="4">Simulation Log</th></tr><tr><th colspan="2">Time</th><th>System State</th><th>Future Events</th></tr></thead><tbody id="subsecDesModel1__simLog"><tr><td>21</td><td>47.49</td><td>workStation1{ bLen: 1, status: 2}</td><td>Start@47.5, Arr@49.97</td></tr><tr><td>20</td><td>44.99</td><td>workStation1{ bLen: 2, status: 2}</td><td>End@47.49, Arr@49.97</td></tr><tr><td>19</td><td>42.44</td><td>workStation1{ bLen: 1, status: 2}</td><td>Arr@44.99, End@47.49</td></tr><tr><td>18</td><td>42.43</td><td>workStation1{ bLen: 1, status: 2}</td><td>Start@42.44, Arr@44.99</td></tr><tr><td>17</td><td>38.25</td><td>workStation1{ bLen: 2, status: 2}</td><td>End@42.43, Arr@44.99</td></tr><tr><td>16</td><td>38.24</td><td>workStation1{ bLen: 2, status: 2}</td><td>Start@38.25, Arr@44.99</td></tr><tr><td>15</td><td>35.14</td><td>workStation1{ bLen: 3, status: 2}</td><td>End@38.24, Arr@44.99</td></tr><tr><td>14</td><td>34.72</td><td>workStation1{ bLen: 2, status: 2}</td><td>Arr@35.14, End@38.24</td></tr><tr><td>13</td><td>33.79</td><td>workStation1{ bLen: 1, status: 2}</td><td>Arr@34.72, End@38.24</td></tr><tr><td>12</td><td>33.78</td><td>workStation1{ bLen: 1, status: 1}</td><td>Start@33.79, Arr@34.72</td></tr><tr><td>11</td><td>29.22</td><td>workStation1{ bLen: 0, status: 1}</td><td>Arr@33.78</td></tr><tr><td>10</td><td>24.97</td><td>workStation1{ bLen: 1, status: 2}</td><td>End@29.22, Arr@33.78</td></tr><tr><td>9</td><td>24.96</td><td>workStation1{ bLen: 1, status: 2}</td><td>Start@24.97, Arr@33.78</td></tr><tr><td>8</td><td>18.95</td><td>workStation1{ bLen: 2, status: 2}</td><td>End@24.96, Arr@33.78</td></tr><tr><td>7</td><td>18.94</td><td>workStation1{ bLen: 2, status: 2}</td><td>Start@18.95, Arr@33.78</td></tr><tr><td>6</td><td>12.81</td><td>workStation1{ bLen: 3, status: 2}</td><td>End@18.94, Arr@33.78</td></tr><tr><td>5</td><td>12.8</td><td>workStation1{ bLen: 3, status: 2}</td><td>Start@12.81, Arr@33.78</td></tr><tr><td>4</td><td>6.7</td><td>workStation1{ bLen: 4, status: 2}</td><td>End@12.8, Arr@33.78</td></tr><tr><td>3</td><td>6.69</td><td>workStation1{ bLen: 4, status: 2}</td><td>Start@6.7, Arr@33.78</td></tr><tr><td>2</td><td>6.25</td><td>workStation1{ bLen: 5, status: 2}</td><td>End@6.69, Arr@33.78</td></tr><tr><td>1</td><td>1</td><td>workStation1{ bLen: 4, status: 2}</td><td>Arr@6.25, End@6.69</td></tr><tr><td>0</td><td>0</td><td>workStation1{ bLen: 3, status: 2}</td><td>Arr@1, Start@1</td></tr></tbody></table><blockquote class="role-attention"><p>In this model, part arrivals and processing end events may occur simultaneously, such that the model must make sure that not both of these events schedule a new processing start event. Indeed, their event rules make sure that in any case only one of them can schedule a new processing start event, and both possible event processing orders yield the same successor simulation state. We can show that the process model defined by <a class="role-figure-ref" href="#subsecDesModel1__figWS1PDM"><span class="role-label">Figure <span class="role-number">2-9</span></span></a> is PES-independent in a similar way as in <a class="role-section2-ref" href="#subsecDesModel0"><span class="role-label">Section <span class="role-number">2.3.1</span></span></a>.</p></blockquote></section><section class="role-section2" id="subsecDesModel2"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.3.3</span>. </span>Design Model 1.3: Considering individual parts and their Mean Time in System</h3><p>For being able to compute the <i>Mean Time in System</i> (also called <i>Manufacturing Lead Time</i>) of parts, we need to record the arrival time of a part. A simple solution is to record the arrival time of a part as the value of an attribute <i>arrivalTime</i> defined in an object class <i>Part</i>, as in the model of <a class="role-figure-ref" href="#subsecDesModel2__figWorkstationIDM2"><span class="role-label">Figure <span class="role-number">2-10</span></span></a>.</p><figure id="subsecDesModel2__figWorkstationIDM2"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-10</span>. </span>An information design model with a <i>waitingParts</i> input buffer.</figcaption><img src="ManufacturingDevTutorial_files/WS2_IDM.svg" width="450" /></figure><p>In this model, we have explicitly modeled the input buffer of a workstation in the form of an ordered multi-valued reference property <i>waitingParts</i>, the values of which are ordered collections (e.g., array lists) of <i>Part</i> objects. For changing the content of such a collection (representing a buffer), we can use the operations <i>push</i>, which adds an item as the last item to the collection, and <i>pop</i>, which removes and returns the first item. Notice that, unlike in the conceptual information model of <a class="role-figure-ref" href="#secSingleWsCM__figWorkstationCIM"><span class="role-label">Figure <span class="role-number">2-2</span></span></a>, there are no associations between <i>ProcessingStart</i>/<i>ProcessingEnd</i> and <i>Part</i>. For simplicity, they have been dropped, since the information, which part participates in an event of one of these two types is available via the participating workstation's <i>waitingParts</i> buffer.</p><figure id="subsecDesModel2__figWS2PDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-11</span>. </span>A process design model with a <i>waitingParts</i> input buffer.</figcaption><img src="ManufacturingDevTutorial_files/WS2_PDM.svg" width="600" /></figure><p>In the process design model shown in <a class="role-figure-ref" href="#subsecDesModel2__figWS2PDM"><span class="role-label">Figure <span class="role-number">2-11</span></span></a>, instead of incrementing/decrementing a queue length variable, we now have to change the state of the input buffer <i>ws.waitingParts</i> by pushing a new part to it on arrival of a new part, and by popping its first element when its processing ends. Thus, the state change language consists of the two operations <em>push</em> and <em>pop</em> that operate on the ordered collection <i>ws.waitingParts</i>, the length of which can be retrieved with the expression <i>ws.waitingParts.length</i>.</p></section><section class="role-section2" id="subsecDesModel3"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.3.4</span>. </span>Design Model 2.1: Using a Processing activity</h3><p>As discussed in <a class="role-section1-ref" href="#secSingleWsActivityCM"><span class="role-label">Section <span class="role-number">2.2</span></span></a>, the pair of start and end event types <i>ProcessingStart</i> and <i>ProcessingEnd</i> in the models of <a class="role-figure-ref" href="#secSingleWsActivityCM__figWorkstationActivityCIM"><span class="role-label">Figure <span class="role-number">2-4</span></span></a> and <a class="role-figure-ref" href="#secSingleWsActivityCM__figWorkstationActivityCPM"><span class="role-label">Figure <span class="role-number">2-5</span></span></a> can be replaced with an equivalent activity type <i>Processing</i> as shown in the models of <a class="role-figure-ref" href="#subsecDesModel3__figWS3IDM"><span class="role-label">Figure <span class="role-number">2-12</span></span></a> and <a class="role-figure-ref" href="#subsecDesModel3__figWS3PDM"><span class="role-label">Figure <span class="role-number">2-13</span></span></a>. Applying this replacement pattern leads to a conceptual and visual simplification of the models concerned.</p><figure id="subsecDesModel3__figWS3IDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-12</span>. </span>An information design model with a <i>Processing</i> activity type.</figcaption><img src="ManufacturingDevTutorial_files/WS3_IDM.svg" width="450" /></figure><p>Notice that we have refactored the function <i>ProcessingStart.processingTime()</i> to the shorter name <i>Processing.time()</i>.</p><p>In the process design model of <a class="role-figure-ref" href="#subsecDesModel3__figWS3PDM"><span class="role-label">Figure <span class="role-number">2-13</span></span></a>, we use the BPMN notation for text annotations for showing the setting of the <i>duration</i> attribute of a <i>Processing</i> activity.</p><figure id="subsecDesModel3__figWS3PDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">2-13</span>. </span>A process design model with a <i>Processing</i> activity.</figcaption><img src="ManufacturingDevTutorial_files/WS3_PDM.svg" width="600" /></figure><p>Event scheduling arrows targeting an Activity rectangle refer to its (possibly explicit) Start Event circle. For being able to specify an event rule for an activity's start event, we need to include an Event circle that represents it in the left part of an Activity rectangle, as in <a class="role-figure-ref" href="#subsecDesModel3__figWS3PDM"><span class="role-label">Figure <span class="role-number">2-13</span></span></a> where the event rule for the start event of a <em>Processing</em> activity takes care that the status of the associated workstation is set to BUSY.</p><p>Since the occurrence time of an activity is its completion time, the state changes specified in a Data Object attached to an Activity rectangle are applied when the activity's end event occurs. Likewise, any event scheduling arrow that goes out of an Activity rectangle represents an event scheduling pattern triggered by the end event of the activity concerned. </p><p>In general, since an Activity rectangle represents two implicit events, it can come with two event rules: one for its (possibly explicit) start event and another one for its (implicit) end event, as in <a class="role-figure-ref" href="#subsecDesModel3__figWS3PDM"><span class="role-label">Figure <span class="role-number">2-13</span></span></a>. The start event rule is defined by the Data Objects and event scheduling arrows attached to the included start Event circle, if there is one. The end event rule is defined by the Data Objects and event scheduling arrows attached to the Activity rectangle.</p></section></section><section class="role-section1" id="secSingleWsDetractors"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.4</span>. </span>Modeling Detractors to Workstation Performance</h2><p>There are three possible detractors to the performance of a workstation: (1) breakdowns, (2) defective parts, and (3) workstation setup for different types of parts, which implies batch processing. These issues are briefly discussed in the following sections.</p><section><h3>Breakdowns</h3><p>Machines periodically break down (e.g., on average once per week) and then have to be repaired before they can resume their normal operation. This can be modeled by adding an exogenous <i>Breakdown</i> event type with an exponentially distributed recurrence and an event rule that changes the workstation state from AVAILABLE or BUSY to BROKEN and schedules a <i>RepairEnd</i> event with a delay equal to the repair time, which may be modeled as uniformly distributed between 30 minutes and 2 hours.</p></section><section><h3>Defective parts</h3><p>Parts that turn out to be defective after being processed need to be reworked. This can be modeled by adding an attribute <i>percentDefective</i> to the object type <i>Workstation</i> and suitable logic to the <i>Processing</i> activity end event rule such that in <i>percentDefective</i> % of all cases a processed part cannot depart the system (i.e., is not removed from the input buffer), but is being reworked by another <i>Processing</i> activity.</p></section><section><h3>Workstation setup</h3><p>As they arrive, parts are gathered into a group called a <i>batch</i> until the number of parts in the group equals the predetermined batch size. The newly formed batch enters the input buffer of the machine to wait for processing. Processing the batch means first performing a setup operation on the machine and then processing all items in the batch. This can be modeled by (1) adding the attributes <i>batchSize</i> and <i>setupTime</i> to the object type <i>Workstation</i> and (2) modifying the condition for scheduling a <i>Processing</i> activity start event such that it only starts, with a delay of <i>setupTime</i>, when the workstation's input buffer has been filled up to the required batch size. </p></section><section class="role-section2" id="subsecDesModel4"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.4.1</span>. </span>Design Model 2.2: Considering machine breakdowns</h3><p>T.B.D</p></section><section class="role-section2" id="subsecDesModel5"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.4.2</span>. </span>Design Model 2.3: Considering defective parts</h3><p>T.B.D</p></section><section class="role-section2" id="subsecDesModel6"><h3 class="role-section2-title"><span class="role-label"><span class="role-number">2.4.3</span>. </span>Design Model 2.4: Considering workstation setup</h3><p>T.B.D</p></section></section></section><section class="role-chapter" id="chWsSeries"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">3</span>. </span>Serial Manufacturing Systems</h1><p>In many cases, multiple workstations are required to perform all operations necessary to produce a finished product. When this can be accomplished by processing all items in the same sequence, a set of single workstations organized into a serial line is appropriate, possibly with a material handling device moving items between the workstations.</p><p>The simplest case of a serial manufacturing system is a series of two workstations, which is considered in .</p><p>A serial manufacturing system of length <i>n</i> can be modeled either with <i>n</i> workstation types such that each type of non-terminal workstation <i>WS</i> has another workstation type <i>WS’</i> as the type of successor workstations of workstations of type <i>WS</i>, or in a generic way such that the model does not depend on <i>n</i>. A generic model, abstracting away from the possibility of blocking created by full input buffers, is presented in .</p><section class="role-section1" id="secWsSeriesOf2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">3.1</span>. </span>Design Model 3.1: A Series of Two Workstations</h2><p>The simplest case of a serial manufacturing system is a series of two workstations, such as one for component placement followed by another one for solder reflow, as described in the (incomplete) information model of <a class="role-figure-ref" href="#secWsSeriesOf2__figWsSeriesOf2IDM"><span class="role-label">Figure <span class="role-number">3-1</span></span></a> and in the (incomplete) process model of <a class="role-figure-ref" href="#secWsSeriesOf2__figWsSeriesOf2PDM"><span class="role-label">Figure <span class="role-number">3-2</span></span></a>.</p><figure id="secWsSeriesOf2__figWsSeriesOf2IDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-1</span>. </span>An information design model for a series of two workstations.</figcaption><img src="ManufacturingDevTutorial_files/WsSeriesOf2_IDM.svg" width="600" /></figure><p>According to this information design model, each workstation (type) is associated with its own type of activity (<em>ComponentPlacement</em> and <em>SolderReflow</em>), and a solder reflow workstation is defined to be the <em>successor</em> of a component placement workstation.</p><figure id="secWsSeriesOf2__figWsSeriesOf2PDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-2</span>. </span>An attempt of a process design model for a series of two workstations.</figcaption><img src="ManufacturingDevTutorial_files/WsSeriesOf2_PDM.svg" width="700" /></figure><p>Notice how a part is removed from the input buffer of the first workstation and forwarded to the second workstation with the state change statement </p><blockquote>ws.successor.waitingParts.push( ws.waitingParts.pop())</blockquote><p>in the Data Object attached to the <em>ComponentPlacement</em> activity.</p><p>The models of <a class="role-figure-ref" href="#secWsSeriesOf2__figWsSeriesOf2PDM"><span class="role-label">Figure <span class="role-number">3-2</span></span></a> and <a class="role-figure-ref" href="#secWsSeriesOf2__figWsSeriesOf2PDM"><span class="role-label">Figure <span class="role-number">3-2</span></span></a> are incomplete since they do not model the fact if a workstation is available or busy, which is needed for synchronizing </p></section><section class="role-section1" id="secWsSeriesGeneric"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">3.2</span>. </span>Design Model 3.2: A Generic Model of Workstations in a Series without Blocking</h2><p>In the generic models presented in <a class="role-figure-ref" href="#secWsSeriesGeneric__figWsSeriesIDM"><span class="role-label">Figure <span class="role-number">3-3</span></span></a> and in <a class="role-figure-ref" href="#secWsSeriesGeneric__figWsSeriesPDM"><span class="role-label">Figure <span class="role-number">3-4</span></span></a>, we assume that the input buffers of workstations have an unlimited capacity such that an arrived or processed part can always be added to the input buffer of the successor workstation. A more realistic model, where input buffers have a limited capacity and a workstation can be blocked by a full input buffer of its successor, is presented in </p><p>Notice that for controlling a series of workstations, the status information whether a workstation is <em>busy</em> or <em>available</em> is needed. These two status values are defined as enumeration literals in an enumeration <em>WorkstationStatusEL</em>, which is defined as the range of the enumeration attribute <em>status</em>.</p><figure id="secWsSeriesGeneric__figWsSeriesIDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-3</span>. </span>A generic information design model for any series of workstations.</figcaption><img src="ManufacturingDevTutorial_files/WsSeriesNoBlocking_IDM.svg" width="500" /></figure><p>The information design model shown in <a class="role-figure-ref" href="#secWsSeriesGeneric__figWsSeriesIDM"><span class="role-label">Figure <span class="role-number">3-3</span></span></a> allows connecting any number of workstations in a series with the help of a one-to-one <i>successor</i> association defining an optional <i>successor</i> property for workstations.</p><p>In the process design model of <a class="role-figure-ref" href="#secWsSeriesGeneric__figWsSeriesPDM"><span class="role-label">Figure <span class="role-number">3-4</span></span></a>, the Event circle within the Activity rectangle denotes the Activity's start event. It allows expressing an on-activity-start event rule for setting the affected workstation's <em>status</em> attribute to BUSY.</p><figure id="secWsSeriesGeneric__figWsSeriesPDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-4</span>. </span>A generic process design model for any series of workstations.</figcaption><img src="ManufacturingDevTutorial_files/WsSeriesNoBlocking_PDM.svg" width="600" /></figure><p>The state change script of the <code>ws:WorkStation</code> Data Object attached to the <em>Processing</em> activity (end event) consists of the following three statements:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">part := waitingParts.pop()
IF successor THEN successor.waitingParts.push( part)
IF waitingParts.length = 0 THEN status := AVAILABLE</pre></td></tr></tbody></table><p>The first state change statement removes the next part to be processed from the input buffer and stores it in the variable <code>part</code>. The second one checks if the workstation has a successor workstation and then adds the part to its input buffer. The third one sets the <code>status</code> attribute to AVAILABLE, if the workstation's input buffer is empty.</p></section><section class="role-section1" id="secWsSeriesWithBlockingGeneric"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">3.3</span>. </span>Design Model 3.3: A Generic Model of Workstations in a Series with Blocking</h2><p>Whenever the input buffer of the succeding workstation is full, the preceding station cannot forward the processed part and begin processing another one. In this case, the workstation is blocked, which can be modeled by assigning it a status of BLOCKED and by adding suitable logic to the <i>Processing</i> activity end event rule such that a blocked preceding workstation will be ‘unblocked’ when a workstation's input buffer is decreased from maximum length.</p>The possibility of blocking is accommodated by adding an enumeration literal BLOCKED to the enumeration <em>WorkstationStatusEL</em>, as shown in <a class="role-figure-ref" href="#secWsSeriesWithBlockingGeneric__figWsSeriesWithBlockingIDM"><span class="role-label">Figure <span class="role-number">3-5</span></span></a>.<figure id="secWsSeriesWithBlockingGeneric__figWsSeriesWithBlockingIDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-5</span>. </span>A generic information design model for a series of workstations with blocking.</figcaption><img src="ManufacturingDevTutorial_files/WsSeries_IDM.svg" width="500" /></figure><p>The information design model now allows a successor workstation to access its predecessor workstation via a one-to-one <i>predecessor-successor</i> association and the implied <em>predecessor</em> property. This is needed because a successor workstation has to unblock its predecessor workstation when its input buffer is no longer full.</p><p>In the process design model of <a class="role-figure-ref" href="#secWsSeriesWithBlockingGeneric__figWsSeriesWithBlockingPDM"><span class="role-label">Figure <span class="role-number">3-6</span></span></a>, the Event circle within the Activity rectangle denotes the Activity's start event. It allows expressing an on-activity-start event rule.</p><figure id="secWsSeriesWithBlockingGeneric__figWsSeriesWithBlockingPDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">3-6</span>. </span>A generic process design model for a series of workstations with blocking.</figcaption><img src="ManufacturingDevTutorial_files/WsSeries_PDM.svg" width="700" /></figure><p>The state change script of the <code>ws:WorkStation</code> Data Object attached to the <em>Processing</em> activity (end event) consists of the following statements:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">part := waitingParts.pop()
IF successor THEN { 
  successor.waitingParts.push( part)
  IF successor.waitingParts.length = successor.bufferCapacity THEN status := BLOCKED
}
IF waitingParts.length = 0 AND status = BUSY THEN status := AVAILABLE
ELSE IF waitingParts.length = bufferCapacity-1 THEN predecessor.status := AVAILABLE</pre></td></tr></tbody></table><p>The first statement removes the next part to be processed from the input buffer and stores it in the variable <code>part</code>. </p><p>The second statement (lines 2-5) checks if the workstation has a successor workstation and then adds the part to its input buffer and sets the <code>status</code> attribute to BLOCKED if the successor workstation's input buffer is full. </p><p>The third statement (lines 6-7) sets the <code>status</code> attribute to AVAILABLE, if the workstation is busy and its input buffer is empty. Otherwise, if the workstation's input buffer length has decreased from maximum length to maximum length minus 1, then the <code>status</code> attribute of the predecessor workstation is set to AVAILABLE.</p></section></section><section class="role-chapter" id="chJobShops"><h1 class="role-chapter-title"><span class="role-label">Chapter <span class="role-number">4</span>. </span>Job Shops</h1><p>A job shop serves a wide variety of parts or jobs. Each type of job may use a different subset of the workstations and visit those stations in a unique sequence. </p><p>Several unique aspects of job shops must be taken into account. When a part using a machine is of a different type than its predecessor, the machine may require a setup task to change its operating parameter values or tooling. Different jobs may require significantly different amounts of processing time at a workstation.</p><section class="role-section1" id="secJobShopOf2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">4.1</span>. </span>Design Model 4.1: A Job Shop Consisting of Two Workstations</h2><p>The simplest case of a job shop consists of a system with two workstations where jobs are classified into three types with the arrival rate and distribution known for each type only. Each job within a type will be modeled as having the same route through the shop. Processing times are known only by station, independent of job type. Thus, processing times are modeled as random variables with a large variance.</p><p>We consider a job shop with a planing and a lathing workstation, as described in the class diagram of <a class="role-figure-ref" href="#secJobShopOf2__figJobShopOf2IDM"><span class="role-label">Figure <span class="role-number">4-1</span></span></a></p><figure id="secJobShopOf2__figJobShopOf2IDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">4-1</span>. </span>An information design model for a job shop with two workstations.</figcaption><img src="ManufacturingDevTutorial_files/JobShopOf2_IDM.svg" width="600" /></figure><p>According to this information design model, each workstation (type) is associated with its own type of activity (<em>Planing</em> and <em>Lathing</em>).</p><p>As opposed to the sequential routing in serial lines of workstations, the routing in a job shop model is based on conditional branching, which is expressed in a DPMN diagram with the help of BPMN Exclusive Gateways, as shown in <a class="role-figure-ref" href="#secJobShopOf2__figJobShopOf2PDM"><span class="role-label">Figure <span class="role-number">4-2</span></span></a>.</p><figure id="secJobShopOf2__figJobShopOf2PDM"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">4-2</span>. </span>A process design model for a job shop with two workstations.</figcaption><img src="ManufacturingDevTutorial_files/JobShopOf2_PDM.svg" width="800" /></figure></section></section><section class="role-appendix" id="appOESjs"><h1 class="role-appendix-title"><span class="role-label">Appendix <span class="role-number">A</span>. </span>Simulation with OESjs</h1><p>OESjs is a web-based simulation framework that implements the <em>Object Event Simulation (<a href="https://sim4edu.com/oes">OES</a>)</em> paradigm. OESjs is used on the <em><a href="https://sim4edu.com/">Simulation for Education</a></em> website. It can be downloaded from <a href="https://sim4edu.com/downloads/">https://sim4edu.com/downloads</a>.</p><section class="role-section1" id="secModel1"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.1</span>. </span>Implementing Design Model 1.1</h2><p>Design model 1.1, presented in <a href="#subsecDesModel0__secDesM1.1"></a>, defines one object type, <code>WorkStation</code>, and two event types, <code>PartArrival</code> and <code>PartDeparture</code>. It can be run as an OESjs online simulation at <a href="https://sim4edu.com/sims/101">https://sim4edu.com/sims/101</a>.</p><p>An OESjs simulation consists of a <kbd>simulation.js</kbd> file that essentially defines simulation parameters and an initial state for a model, which is coded in a number of object class files and event class files, such as <kbd>WorkStation.js</kbd>, <kbd>PartArrival.js</kbd> and <kbd>PartDeparture.js</kbd>. </p><section><h4>Implementing object and event types</h4><p>The information design model 1.1 shown below defines one object type and two event types. </p><figure id="secModel1__figWS0IDM_1"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">A-1</span>. </span>Information design model 1.1.</figcaption><img src="ManufacturingDevTutorial_files/WS0_IDM.svg" width="350" /></figure><p>These three type definitions are implemented in the form of three corresponding classes in OESjs. An object type like <code>WorkStation</code> is implemented as a class that extends the predefined class <code>oBJECT</code> in a class definition file like <kbd>WorkStation.js</kbd>, as shown in the following program listing:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var <b>WorkStation</b> = new cLASS({
  Name: &quot;WorkStation&quot;,
  supertypeName: &quot;oBJECT&quot;,
  properties: {
    &quot;<b>inputBufferLength</b>&quot;: { range: &quot;NonNegativeInteger&quot;},
    &quot;currentProcessingTime&quot;: {range: &quot;Decimal&quot;}
  }
});
WorkStation.<b>processingTime</b> = function () {
  return rand.exponential(1/6);
};</pre></td></tr></tbody></table><p>In addition to the attribute <code>inputBufferLength</code>, as specified in the class diagram of <a class="role-figure-ref" href="#subsecDesModel0__figWS0IDM"><span class="role-label">Figure <span class="role-number">2-6</span></span></a>, the object type <code>WorkStation</code> also defines an attribute <code>currentProcessingTime</code>, which is used for the purpose of computing the utilization statistics.</p><p>The two event types, <code>PartArrival</code> and <code>PartDeparture</code>, are implemented as classes that extend the predefined class <code>eVENT</code> in corresponding class definition files <kbd>PartArrival.js</kbd> and <kbd>PartDeparture.js</kbd>, as shown in the following program listings:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var <b>PartArrival</b> = new cLASS({
  Name: &quot;PartArrival&quot;,
  supertypeName: &quot;eVENT&quot;,
  properties: {
    &quot;<b>workStation</b>&quot;: {range: &quot;WorkStation&quot;}
  },
  methods: {
    &quot;<b>onEvent</b>&quot;: function () {...}
  }
});
PartArrival.<b>recurrence</b> = function () {
  return rand.triangular( 3, 8, 4);  // min,max,mode
};</pre></td></tr></tbody></table><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">var <b>PartDeparture</b> = new cLASS({
  Name: &quot;PartDeparture&quot;,
  supertypeName: &quot;eVENT&quot;,
  properties: {
    &quot;<b>workStation</b>&quot;: {range: &quot;WorkStation&quot;}
  },
  methods: {
    &quot;<b>onEvent</b>&quot;: function () {...}
  }
});</pre></td></tr></tbody></table><p>Notice that in order to show up in the simulation log, object types and event types, and their properties, need to have a <code>label</code> attribute defined for them.</p></section><section><h4>Implementing event rules</h4><p>In OESjs, any event class must have an &quot;onEvent&quot; method, which implements the <em>event routine</em> of the event type's event rule. The event rules of the event types <code>PartArrival</code> and <code>PartDeparture</code> are defined in the following DPMN diagram .</p><figure id="secModel1__figWS0PDM_1"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">A-2</span>. </span>Process design model 1.1.</figcaption><img src="ManufacturingDevTutorial_files/WS0_PDM.svg" width="500" /></figure><p>In the case of the event type <code>PartArrival</code>, the code of its event routine is shown in the following program listing:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">&quot;<b>onEvent</b>&quot;: function () {
  var events=[], ws = this.workStation;
  // add part to buffer
  ws.inputBufferLength++;
  // update statistics
  sim.stat.arrivedParts++;
  // if the work station is available
  if (ws.inputBufferLength === 1) {
    // compute random processing time
    ws.currentProcessingTime = WorkStation.processingTime();
    // schedule the part's departure event
    events.push( new <b>PartDeparture</b>({
      delay: ws.currentProcessingTime,
      workStation: ws
    }));
  }
  return events;
}</pre></td></tr></tbody></table><p>In the case of the event type <code>PartDeparture</code>, defined in <kbd>PartDeparture.js</kbd>, the code of its event routine is shown in the following program listing:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.25em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">&quot;<b>onEvent</b>&quot;: function () {
  var events=[], ws = this.workStation;
  // remove part from buffer
  ws.inputBufferLength--;
  // update statistics
  sim.stat.departedParts++;
  sim.stat.totalProcessingTime += ws.currentProcessingTime;
  // if there are still parts waiting
  if (ws.inputBufferLength &gt; 0) {
    // compute random processing time
    ws.currentProcessingTime = WorkStation.processingTime();
    // schedule the next departure event
    events.push( new PartDeparture({
      delay: ws.currentProcessingTime,
      workStation: ws
    }));
  }
  return events;
}</pre></td></tr></tbody></table></section><section><h4>Defining the initial state</h4><p>The initial state is defined in the <kbd>simulation.js</kbd> file like so:</p><table class="role-listing" style="width: 100%; border-collapse: collapse;"><colgroup class="listing-numbers-column" style="width: 2.0em;"></colgroup><tbody style="vertical-align: baseline;"><tr><td class="listing-numbers"><pre style="text-align: right; background-color: transparent; border-style: none; padding: 0; margin: 0;">1
2
3
4
5
6
7
8</pre></td><td class="listing-lines"><pre style="text-align: left; background-color: transparent; border-style: none; padding: 0; margin: 0;">sim.scenario.initialState.objects = {
  &quot;1&quot;: {typeName: &quot;WorkStation&quot;, name:&quot;workStation1&quot;, 
    inputBufferLength: 3}
};
sim.scenario.initialState.events = [
  {typeName: &quot;PartArrival&quot;, occTime: 1, workStation: 1},
  {typeName: &quot;PartDeparture&quot;, occTime: 1, workStation: 1}
];</pre></td></tr></tbody></table><p>Notice that the initial <code>PartArrival</code> and <code>PartDeparture</code> events refer to the <code>workStation</code> with ID=1, which has been created as an object of type <code>WorkStation</code> with an <code>inputBufferLength</code> of 3. For obtaining a simulation of two workstations operating in parallel, we would have to create another <code>WorkStation</code> object, say with ID=2, and also schedule initial events for it, as in</p><pre>sim.scenario.initialState.objects = {
  &quot;1&quot;: {typeName: &quot;WorkStation&quot;, name:&quot;workStation1&quot;, 
    inputBufferLength: 3},
  &quot;2&quot;: {typeName: &quot;WorkStation&quot;, name:&quot;workStation2&quot;, 
    inputBufferLength: 3}
};
sim.scenario.initialState.events = [
  {typeName: &quot;PartArrival&quot;, occTime: 1, workStation: 1},
  {typeName: &quot;PartDeparture&quot;, occTime: 1, workStation: 1},
  {typeName: &quot;PartArrival&quot;, occTime: 1, workStation: 2},
  {typeName: &quot;PartDeparture&quot;, occTime: 1, workStation: 2}
];</pre></section></section><section class="role-section1" id="secModel2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.2</span>. </span>Implementing Design Model 1.2</h2><p>Design model 1.2, presented in <a class="role-section2-ref" href="#subsecDesModel1"><span class="role-label">Section <span class="role-number">2.3.2</span></span></a>, defines one object type, <code>WorkStation</code>, and three event types, <code>PartArrival</code>, <code>ProcessingStart</code> and <code>ProcessingEnd</code>. It can be run as an OESjs online simulation at <a href="https://sim4edu.com/sims/102">https://sim4edu.com/sims/102</a>.</p></section><section class="role-section1" id="secModel3"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.3</span>. </span>Implementing Design Model 1.3</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel4"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.4</span>. </span>Implementing Design Model 2.1</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel5"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.5</span>. </span>Implementing Design Model 2.2</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel6"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.6</span>. </span>Implementing Design Model 2.3</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel7"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.7</span>. </span>Implementing Design Model 2.4</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel8"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.8</span>. </span>Implementing Design Model 8</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel9"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">A.9</span>. </span>Implementing Design Model 9</h2><p>T.B.D.</p></section></section><section class="role-appendix" id="appAnyLogic"><h1 class="role-appendix-title"><span class="role-label">Appendix <span class="role-number">B</span>. </span>Simulation with AnyLogic</h1><p>AnyLogic is a simulation framework that supports the three modeling paradigms of DES, System Dynamics (continuous state change modeling with differential equations), and object/agent-based modeling, and and their combination.</p><p>AnyLogic DES models can be either <em>event-based</em>, using AnyLogic's <em>Event</em> or <em>Dynamic Event</em> from the Agent Palette, or <em>Processing-Network-based</em>, using, for instance, <em>Source</em>, <em>Service</em> and <em>Sink</em> from their Process Modeling Library. </p><section class="role-section1" id="secModel1-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.1</span>. </span>Implementing Design Model 1.1</h2><p>The simplest approach to event-based simulation with AnyLogic is to use the <em>Event</em> element from the Agent Palette. However, the <em>Event</em> element does not support event types with properties. In example 1, this prevents part arrival and departure events having a reference to a particular workstation as the value of a reference property <i>workStation</i>, unlike what is specified by the design model shown in <a class="role-figure-ref" href="#secModel1-2__figWS0PDM_2"><span class="role-label">Figure <span class="role-number">B-2</span></span></a>. We will therefore first show how to make a simplified simulation model with <code>PartArrival</code> and <code>PartDeparture</code> modeled as <em>Events</em> without a reference to a workstation, thus leaving the participating workstation implicit. </p><section><figure id="secModel1-2__figWS0IDM_2"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">B-1</span>. </span>Information design model 1.1.</figcaption><img src="ManufacturingDevTutorial_files/WS0_IDM.svg" width="350" /></figure><h4>Implementing the object type <code>WorkStation</code></h4><p>The object type <code>WorkStation</code> defined in information design model 1.1 can be implemented in AnyLogic in the form of an Agent Type. </p><p>After selecting the <em>Agent</em> Palette, drag-and-drop the <em>Agent</em> element, choose the option &quot;A single agent&quot;, keep the setting &quot;I want to create a new agent type&quot;, call the resulting object type &quot;WorkStation&quot; and the resulting object &quot;workStation1&quot;, and click Finish. Then double-click the <code>workStation1</code> object, such that the <code>WorkStation</code> Agent Type tab is opened for defining the attribute <code>inputBufferLength</code> by dragging-and-dropping the AnyLogic <em>Variable</em> element and setting its <em>Type</em> to &quot;int&quot;.</p><p>Right-click on the <code>inputBufferLength</code> attribute and choose &quot;Create chart&quot; and then &quot;Create time plot&quot; for adding a variable monitor that will show a time series of the input buffer length values when the simulation is executed.</p><blockquote class="role-notice"><p>In AnyLogic, an object type is defined as an &quot;Agent Type&quot;, and an object is defined as an &quot;Agent&quot;. A property of an object type is defined as a &quot;Variable&quot; of the &quot;Agent Type&quot; concerned, if the property's value is changed by a state change statement of an event rule. Otherwise, if the property's value is not changed during a simulation run, it is defined as a &quot;Parameter&quot; of the &quot;Agent Type&quot; concerned.</p></blockquote></section><figure id="secModel1-2__figWS0PDM_2"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">B-2</span>. </span>Process design model 1.1.</figcaption><img src="ManufacturingDevTutorial_files/WS0_PDM.svg" width="500" /></figure><section><h4>Implementing a simplified version of design model 1.1 using AnyLogic's <em>Event</em> element</h4><p>AnyLogic's <em>Event</em> element only supports simple event types without properties. Consequently, using it only allows implementing a simplified version of the design model without workstation references.</p><p>Drag-and-drop the <em>Event</em> element twice and call the resulting event types &quot;PartArrival&quot; and &quot;PartDeparture&quot;. Go on with defining these event types in the following way:</p><ol><li><p>Click on <code>PartArrival</code>, choose &quot;Timeout&quot; as <i>Trigger type</i>, set <em>Mode</em> to &quot;Cyclic&quot; for defining events of this type to be <em>exogenous</em> (i.e., recurring), with a &quot;First occurrence time&quot; of 1 and an expression <code>exponential(0.1666)</code> as the value of &quot;Recurrence time&quot;, and add the following Java statements in the <em>Action</em> panel:</p><pre>workStation1.inputBufferLength++;
if (workStation1.inputBufferLength == 1) {
  PartDeparture.restart( triangular( 3, 8, 4));
}</pre></li><li><p>Click on <code>PartDeparture</code>, choose &quot;Timeout&quot; as <i>Trigger type</i> and set <em>Mode</em> to &quot;User control&quot; for defining events of this type to be <em>endogenous</em> (i.e., caused by invoking AnyLogic's <code>restart</code> method), and add the following Java statements in the <em>Action</em> panel:</p><pre>workStation1.inputBufferLength--;
if (workStation1.inputBufferLength &gt; 0) {
  PartDeparture.restart( triangular( 3, 8, 4));
}</pre></li></ol><p>After performing the above simulation definition steps, we see the defined elements in the Main Agent window, as shown in <a class="role-figure-ref" href="#secModel1-2__figDesM1_AnyLogic"><span class="role-label">Figure <span class="role-number">B-3</span></span></a>.</p><figure id="secModel1-2__figDesM1_AnyLogic"><figcaption style="text-align:center;"><span class="role-label">Figure <span class="role-number">B-3</span>. </span>The Main Agent window showing the first AnyLogic implementation of design model 1.1.</figcaption><img src="ManufacturingDevTutorial_files/WS0_AnyLogic.png" width="500" /></figure><blockquote class="role-notice"><p>An event type without properties can be implemented as an &quot;Event&quot;, distinguishing the following two cases:</p><ol><li><p>For <em>exogenous</em> event types, set <i>Trigger type</i> to &quot;Timeout&quot; and <em>Mode</em> to &quot;Cyclic&quot;. Then, define the &quot;First occurrence time&quot; of an event of this type, and set the &quot;Recurrence time&quot; to a fixed value or to a probability distribution function such as <code>exponential(0.5)</code>.</p></li><li>For other (caused) event types, set <i>Trigger type</i> to &quot;Timeout&quot; and <em>Mode</em> to &quot;User control&quot;, which means that events of such a type need to be scheduled with AnyLogic's predefined <code>restart</code> <em>Event</em> method.</li></ol></blockquote></section><section><h4>Implementing design model 1.1 using AnyLogic's <em>Dynamic Event</em> element</h4><p>AnyLogic's <em>Dynamic Event</em> element allows implementing an event type E with properties by implementing these properties in the form of event creation parameters. A Dynamic Event of type E has to be scheduled with a special method, which is automatically generated by AnyLogic with the name &quot;create_E&quot;, having two fixed parameters, the occurrence time and the time unit, followed by parameters corresponding to the properties of the event type. For instance, the following method invocation expression includes an occurrence time (obtained by invoking the <code>exponential</code> distribution function) and the time unit <code>MINUTE</code>, followed by a reference to a particular <code>WorkStation</code> as arguments for invoking the <code>create_PartArrival</code> method:</p><pre>create_PartArrival( exponential(0.5), MINUTE, workStation1);</pre><p>As in the implementation with <em>Event</em> elements described above, an object type <code>WorkStation</code> with an attribute <code>inputBufferLength</code> has first to be defined and instantiated with an object <code>workStation1</code>. Also, as before, a variable monitor for <code>inputBufferLength</code> is needed for obtaining a simulation output.</p><p>Then drag-and-drop the <em>Dynamic Event</em> element twice to the <em>Main</em> panel and call the resulting event types &quot;PartArrival&quot; and &quot;PartDeparture&quot;. Go on with defining these event types in the following way:</p><ol><li><p>Click on <code>PartArrival</code>, define under &quot;Arguments&quot; the (event creation) parameter <code>workStation</code> of type <code>WorkStation</code>, and add the following Java statements using this parameter in the <em>Action</em> text area:</p><pre>workStation.inputBufferLength++;
if (workStation.inputBufferLength == 1) {
  create_PartDeparture( triangular(3,8,4), MINUTE, workStation);
}
// create next arrival event
create_PartArrival( exponential(0.1666), MINUTE, workStation);</pre><p>Notice that since a <em>Dynamic Event</em> does not allow a direct recurrence definition, it is necessary to schedule the next event in the <em>Action</em> of that event type for keeping the flow of exogenous events going on.</p></li><li><p>Click on <code>PartDeparture</code>, define under &quot;Arguments&quot; the property <code>workStation</code> of type <code>WorkStation</code>, and add the following Java statements in the <em>Action</em> panel:</p><pre>workStation.inputBufferLength--;
if (workStation.inputBufferLength &gt; 0) {
  create_PartDeparture( triangular(3,8,4), MINUTE, workStation);
}</pre></li></ol><p>Finally, for any exogenous event type, like <code>PartArrival</code>, an initial event has to be scheduled in the &quot;On startup&quot; action of <code>Main</code>:</p><pre>// create first arrival event
create_PartArrival( 1, MINUTE, workStation1);</pre><p>Notice that the initial <code>PartArrival</code> event refers to <code>workStation1</code>, which has been created as an object of type <code>WorkStation</code>. For obtaining a simulation of two workstations operating in parallel, we would have to create another <code>WorkStation</code> object, say <code>workStation2</code>, and also schedule a part arrival event for it, as in</p><pre>// create first arrival event at workStation1
create_PartArrival( 1, MINUTE, workStation1);
// create first arrival event at workStation2
create_PartArrival( 1, MINUTE, workStation2);</pre><blockquote class="role-notice"><p>Normally, an event of a certain type has one or more objects of certain types as its participants playing certain roles in the event. For instance, a part arrival event has two participants: a <em>part</em> object and a <em>workstation</em> object. The participation roles of an event type can be represented in the form of reference properties of the event type. For instance, the event type <code>PartArrival</code> would have the reference properties <code>part</code> (with range <code>Part</code>) and <code>workstation</code> (with range <code>Workstation</code>).</p><p>AnyLogic's <em>Dynamic Event</em> element does not allow defining properties for a certain type of Dynamic Event, but event properties can be implemented with the help of event creation parameters, called &quot;Arguments&quot; in the Dynamic Event definition panel, such that certain values for these event creation parameters (representing properties) can be provided when creating an event. For instance, the Dynamic Event <code>PartArrival</code> would have the event creation parameters <code>part</code> (with range <code>Part</code>) and <code>workstation</code> (with range <code>Workstation</code>).</p></blockquote></section></section><section class="role-section1" id="secModel2-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.2</span>. </span>Implementing Design Model 1.2</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel3-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.3</span>. </span>Implementing Design Model 1.3</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel4-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.4</span>. </span>Implementing Design Model 2.1</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel5-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.5</span>. </span>Implementing Design Model 2.2</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel6-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.6</span>. </span>Implementing Design Model 2.3</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel7-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.7</span>. </span>Implementing Design Model 2.4</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel8-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.8</span>. </span>Implementing Design Model 8</h2><p>T.B.D.</p></section><section class="role-section1" id="secModel9-2"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">B.9</span>. </span>Implementing Design Model 9</h2><p>T.B.D.</p></section></section><div class="role-backmatter" id="backmatter"><section class="role-section1" id="Bibliography"><h2 class="role-section1-title">Bibliography</h2><ul><li>Schruben, L.W. 1983. Simulation Modeling with Event Graphs. <i>Communications of the ACM</i> 26, pp. 957-963.</li><li>Standridge, C.R. 2013. <i>Beyond Lean: Simulation in Practice</i>, Second Edition, Open Access book, available from <a href="https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books">https://scholarworks.gvsu.edu/cgi/viewcontent.cgi?article=1006&amp;context=books</a>.</li><li>Wagner, G. 2017a. An Abstract State Machine Semantics for Discrete Event Simulation. In <i>Proceedings of the 2017 Winter Simulation Conference</i>. Piscataway, NJ: IEEE. Available from <a href="https://www.informs-sim.org/wsc17papers/includes/files/056.pdf">https://www.informs-sim.org/wsc17papers/includes/files/056.pdf</a>.</li><li>Wagner, G. 2017b. Sim4edu.com – Web-Based Simulation for Education. <i>Proceedings of the 2017 Winter Simulation Conference</i>. Piscataway, NJ: IEEE.</li><li>Wagner, G. 2018a. Discrete Event Process Modeling Notation (DPMN). Language Reference. Available from <a href="https://sim4edu.com/reading/DPMN">https://sim4edu.com/reading/DPMN</a>.</li><li>Wagner, G. 2018b. Information and Process Modeling for Simulation – Part I: Objects and Events. Journal of Simulation Engineering, vol. 1, 2018. Available from <a href="https://articles.jsime.org/1/1">https://articles.jsime.org/1/1</a>.</li></ul></section><section class="role-index" id="_index"><h1 class="role-index-title">Index</h1></section></div></section>
   <script>
// load iframe only after loading the page
document.getElementById("subsecDesModel0__iframe1").src = "https://sim4edu.com/sims/101/";
   </script>
</body></html>