<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="role-ebook-page"><head><meta charset="UTF-8" /><title>2.1. Event-Based Simulation without Objects</title><link href="_res/pageNavigation.css" rel="stylesheet" type="text/css" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="_res/ebook.css" rel="stylesheet" type="text/css" /></head><body><header class="page-navigation"><table><tr><td class="page-navigation-to-previous"><a href="EventBasedDES-Intro.html"><span class="page-navigation-to-previous-icon" title="Previous page
Chapter 2. Event-Based Simulation"></span></a></td><td class="page-navigation-previous"><span>Chapter 2. Event-Based Simulation</span></td><td class="page-navigation-current"><span>2.1. Event-Based Simulation without Objects</span> <span class="page-navigation-current-page">(13/41)</span><a href="toc.html"><span class="page-navigation-to-toc-icon" title="Table of Contents
Table of Contents"></span></a><a href="_index.html"><span class="page-navigation-to-index-icon" title="Index
Index"></span></a></td><td class="page-navigation-next"><span>2.2. Modeling a Manufacturing Workstation as a Queueing System</span></td><td class="page-navigation-to-next"><a href="OEM-Example-Workstation.html"><span class="page-navigation-to-next-icon" title="Next page
2.2. Modeling a Manufacturing Workstation as a Queueing System"></span></a></td></tr></table></header><main><section class="role-section1" id="ES-without-Objects"><h2 class="role-section1-title"><span class="role-label"><span class="role-number">2.1</span>. </span>Event-Based Simulation without Objects</h2><p>When Event-Based Simulation (ES) was developed in the 1960's, pioneered by <a href="https://www.rand.org/content/dam/rand/pubs/research_memoranda/2009/RM3310.pdf">SIMSCRIPT</a>, the software engineering paradigm of Object-Oriented (OO) modeling and OO programming was not yet available. Therefore, the objects of a system have not been modeled as objects, but rather the relevant characteristics of the (objects of) the system under investigation have been modeled in the form of <em>state variables</em>.</p><section><h4>The ES Formalism</h4><p>We illustrate the formal semantics of ES with the help of an example. We model a system of one or more service desks, each of them having its own queue, as a discrete event system characterized by the following narrative:</p><ol><li>Customers arrive at a service desk at random times.</li><li>If there is no other customer in front of them, and the service desk is available, they are served immediately, otherwise they have to queue up in a waiting line.</li><li>The duration of services varies, depending on the individual case.</li><li>When a service is completed, the customer departs and the next customer is served, if there is still any customer in the queue.</li></ol><p>The base concepts of ES are:</p><ol><li><em>state variables</em> for defining the state of a system,</li><li>event types,</li><li>event expressions,</li><li>event routines,</li><li>future events lists (FEL).</li></ol><p>A <b><i>state variable</i></b> is declared with a name and a <em>range</em>, which is a datatype defining its possible values.</p><p>An <b><i>event type</i></b> is defined in the form of a class: with a name, a set of property declarations and a set of method definitions, which together define the <i>signature</i> of the event type.</p><p>An <b><i>event expression</i></b> is a term E<i>(<u>x</u>)@t</i> where</p><ol><li>E is an event type,</li><li><i>t</i> is a parameter for the occurrence time of events,</li><li><i><u>x</u></i> is a (possibly empty) list of event parameters <i>x<sub>1</sub></i>, <i>x<sub>2</sub></i>, …, <i>x<sub>n</sub></i> according to the signature of the event type E.</li></ol><p>For instance, Arrival@<i>t</i> is an event expression for describing Arrival events where the signature of the event type Arrival is empty, so there are no event parameters, and the parameter <i>t</i> denotes the arrival time (more precisely, the occurrence time of the Arrival event). An individual event of type E is a <i>ground</i> event expression, <i>e</i> = E(<i><u>v</u></i>)@<i>i</i>, where the event parameter list <i><u>x</u></i> and the occurrence time parameter <i>t</i> have been instantiated with a corresponding value list <i><u>v</u></i> and a specific time instant <i>i</i>. For instance, Arrival@1 is a ground event expression representing an individual Arrival event.</p>An <b><i>event routine</i></b> is a procedure that essentially computes state changes and follow-up events, possibly based on conditions on the current state. In practice, state changes are often directly performed by immediately updating the state variables concerned, and follow-up events are immediately scheduled by adding them to the FEL. For defining the formal semantics of ES, we assume that an event routine is a pure function that computes state changes and follow-up events, but does not apply them, as in the rules described in <a class="role-table-ref" href="#ES-without-Objects__tblEventRulesArrDep"><span class="role-label">Table <span class="role-number">2-1</span></span></a>.<table border="1" id="ES-without-Objects__tblEventRulesArrDep" style="border-spacing:0px;width:100%;"><caption><span class="role-label">Table <span class="role-number">2-1</span>. </span>Expressing event routines as pure functions that compute state changes and follow-up events.</caption><colgroup style="text-align:center;"></colgroup><colgroup></colgroup><colgroup></colgroup><thead><tr><td style="vertical-align:top;"><p><b>Event rule name</b></p></td><td style="text-align:center;"><p><b>ON (event expression)</b></p></td><td style="text-align:center;"><p><b>DO (event routine)</b></p></td></tr></thead><tbody><tr><td><p>r<i><sub>Arr</sub></i></p></td><td><p>Arrival @ t</p></td><td><p>E’ := { Arrival @ (t + recurrence()) }<br />Δ := { INCREMENT queueLength }<br />IF queueLength = 0<br />THEN E’ := E’ ⋃ { Departure @ (t + serviceDuration()) }<br />RETURN ⟨ Δ, <i>E'</i> ⟩</p></td></tr><tr><td><p>r<i><sub>Dep</sub></i></p></td><td><p>Departure @ t</p></td><td><p>E’ := {}<br />Δ := { DECREMENT queueLength }<br />IF queueLength &gt; 1<br />THEN E’ := E’ ⋃ { Departure @ (t + serviceDuration()) }<br />RETURN ⟨ Δ, <i>E'</i> ⟩ </p></td></tr></tbody></table><p>An <b><i>event rule</i></b> associates an event expression with an <i>event routine F</i>:</p><p class="indented"><b>ON</b> E<i>(<u>x</u>)@t</i> <b>DO</b> <i>F( t, <u>x</u>)</i>,</p><p>where the event expression E<i>(<u>x</u>)@t</i> specifies the type E of events that trigger the rule, and <i>F( t, <u>x</u>)</i> is a function call expression for computing a set of <i>state changes</i> and a set of <i>follow-up events</i>, based on the event parameter values <i><u>x</u></i>, the event's occurrence time <i>t</i> and the current system state, which is accessed in the event routine <i>F</i> for testing conditions expressed in terms of state variables.</p><p>A <b><i>Future Events List (FEL)</i></b> is a set of ground event expressions partially ordered by their occurrence times, which represent future time instants either from a discrete or a continuous model of time. The partial order implies the possibility of simultaneous events, as in the example { Departure@4, Arrival@4 }.</p><section><h5>ES Models</h5><p>An <em>ES<b><i> </i></b>model</em> is a triple ⟨ SV, ET, R ⟩ where</p><ol><li>SV is a set of state variable declarations defining the structure of possible system states,</li><li>ET is a set of event type definitions,</li><li>R is a set of event rules expressed in terms of SV and ET.</li></ol><p>We show how to express the example model of a simple service desk system as an ES model. The set of state variables is a singleton:</p><p class="indented">SV = { queueLength: NonNegativeInteger}</p><p>There are two event types, both having an empty signature:</p><p class="indented">ET = { Arrival(), Departure()}</p><p>And there are two event rules:</p><p class="indented">R = { r<i><sub>Arr</sub></i>, r<i><sub>Dep</sub></i>}</p><p>which are defined as in Table 1 above.</p><p>Such a model, together with an initial state (specifying initial values for state variables and initial events), defines an ES system, which is a transition system where</p><ol><li>system states are defined by value assignments for the state variables,</li><li>transitions are provided by event occurrences triggering event rules that change the simulation state through changing the system state (by changing the values of affected state variables) and the FEL (by adding follow-up events).</li></ol><p>Whenever the transitions of an ES system involve computations based on random numbers (if the simulation model contains random variables), the transition system defined is non-deterministic.</p><p>For instance, assuming that the initial system state is <i>S</i><sub>0</sub> = {queueLength: 0}, and there is an initial event {Arrival@1}, then, as a consequence of applying r<i><sub>Arr</sub></i>, there is a system state change {queueLength := 1} and, assuming a random service time of 2 time units (as a sample from the underlying probability distribution function), a follow-up event Departure@3, which has to be scheduled along with the next Arrival event, say Arrival@3 (with a random inter-arrival time of 2), because Arrival is an exogenous event type (with a random recurrence). Consequently, the next system state is <i>S</i><sub>1</sub> = {queueLength: 1}.</p><p>We need to distinguish between the <i>system state</i>, like <i>S</i><sub>0</sub> = {queueLength: 0}, which is the state of the simulated system, and the <i>simulation state</i>, which adds the FEL to the system state, like</p><p class="indented"><b><i>S</i></b><sub>0</sub> = ⟨ {queueLength: 0}, {Arrival@1} ⟩</p><p class="indented"><b><i>S</i></b><sub>1</sub> = ⟨ {queueLength: 1}, {Arrival@2, Departure@3} ⟩</p><p>Doing one more step, the next transition is given by the next event Arrival@2 again triggering r<i><sub>Arr</sub></i>, which leads to</p><p class="indented"><b><i>S</i></b><sub>2</sub> = ⟨ {queueLength: 2}, {Departure@3, Arrival@4} ⟩</p><p>In this way, we get a succession of states <b><i>S</i></b><sub>0</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>1</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>2</sub> <span style="font-family:monospace;">→</span> … as a history of the transition system defined by the ES model.</p></section><section><h5>Event Rules as Functions</h5><p>An event rule <i>r</i> = <b>ON</b> E<i>(<u>x</u>)@t</i> <b>DO</b> <i>F( t, <u>x</u>)</i> can be considered as a 2-step function that, in the first step, maps an event <i>e</i> = E(<i><u>v</u></i>)@<i>i</i> to a parameter-free state change function <i>r<sub>e</sub></i> = <i>F( i, <u>v</u>)</i>, which maps a system state to a pair ⟨ Δ, <i>E'</i> ⟩ of system state changes Δ and follow-up events <i>E'</i>. When the parameters <i>t</i> and<i> <u>x</u></i> of <i>F( t, <u>x</u>)</i> are replaced by the values <i>i</i> and <i><u>v</u></i> provided by a ground event expression E(<i><u>v</u></i>)@<i>i</i>, we also simply write <i>F<sub>i,<u>v</u></sub></i> instead of <i>F( i, <u>v</u>)</i> for the resulting parameter-free state change function.</p><p>We say that an event rule <i>r</i> is <i>triggered</i> by an event <i>e</i> when the event’s type is the same as the rule’s triggering event type. When <i>r</i> is triggered by <i>e</i>, we can form the state change function <i>r<sub>e</sub></i> = <i>F<sub>i,<u>v</u></sub></i> and apply it to a system state <i>S</i> by mapping it to a set of system state changes Δ and a set of follow-up events <i>E'</i>:</p><p class="indented"><i>r<sub>e</sub>(S)</i> = <i>F<sub>i,<u>v</u></sub>(S)</i> = ⟨ Δ, <i>E'</i> ⟩</p><p>We can illustrate this with the help of our running example. Consider the rule r<i><sub>Arr</sub></i> defined in Table 1 above triggered by the event Arrival@1 in state <i>S</i><sub>0</sub> = {queueLength: 0}. The resulting state change function <i>F</i><sub>1</sub> defined by the corresponding event routine from Table 1 maps <i>S</i><sub>0</sub> to the set of state changes Δ = { INCREMENT queueLength} and the set of follow-up events <i>E'</i> = {Departure@3}. We show how the pair ⟨ Δ, <i>E'</i> ⟩ amounts to a transition of the simulation state in the next section.</p><p>In ES, a system state change is an update of one or more state variables. Such an update is specified in the form of an assignment where the right-hand side is an expression that may involve state variables. For instance, the state change <span style="font-family:monospace;">INCREMENT queueLength</span> is equivalent to the assignment <span style="font-family:monospace;">queueLength </span>:=<span style="font-family:monospace;"> queueLength + 1</span>.</p><p>In general, there may be situations, where we have several concurrent events, that is, there may be two or more events occurring at the same (next-event) time. Therefore, we need to explain how to apply a set of rules <i>R<sub>E</sub></i> triggered by a set of events <i>E</i>, even if both sets are singletons in many cases.</p><p>The rule set <i>R</i> of an ES model can also be considered as a 2-step function that, in the first step, maps a set of events <i>E</i> to a state change function <i>R<sub>E</sub></i>, which maps a system state to a pair ⟨ Δ, <i>E'</i> ⟩ of state changes Δ and follow-up events <i>E'</i>.</p><p>For a given set of events <i>E</i> and a rule set <i>R</i>, we can form the set of state change functions obtained from rules triggered by events from <i>E</i>:</p><p class="indented"><i>R<sub>E</sub></i> = { <i>r<sub>e</sub></i> : <i>r</i> ∈ <i>R</i> &amp; <i>e</i> ∈ <i>E</i> &amp; <i>e</i> triggers <i>r</i>}</p><p>Notice that the elements <i>C</i> of <i>R<sub>E</sub></i> are parameter-free state change functions, which can be applied as a block, in parallel, to a system state <i>S:</i></p><p class="indented"><i>R<sub>E</sub>(S)</i> = ⟨ Δ, <i>E'</i> ⟩</p><p>with</p><p class="indented">Δ = ⋃ { Δ<i><sub>C</sub></i> : <i>C</i> ∈ <i>R<sub>E</sub></i> &amp; <i>C(S)</i> = ⟨ Δ<i><sub>C</sub></i>, <i>E'<sub>C</sub></i> ⟩ }<br /><i>E'</i> = ⋃ { <i>E'<sub>C</sub></i> : <i>C</i> ∈ <i>R<sub>E</sub></i> &amp; <i>C(S)</i> = ⟨ Δ<i><sub>C</sub></i>, <i>E'<sub>C</sub></i> ⟩ }</p><p>Notice that when forming the union of all state changes brought about by applying rules from <i>R<sub>E</sub></i>, and likewise when forming the union of all follow-up events created by applying rules from <i>R<sub>E</sub></i>, the order of rule applications does not matter because they do not affect the applicability of each other, so any selection function for choosing rules from <i>R<sub>E</sub></i> and applying them sequentially will do, and they could also be applied simultaneously if such a parallel computation is supported.</p><p>However, computing a set of state changes Δ raises the question if this set is, in some sense, consistent. A simple, but too restrictive, notion of consistent state changes would require that if Δ contains two or more updates of the same state variable, all of them must be equivalent (effectively assigning the same value). A more liberal notion just requires that if Δ contains two or more updates of the same state variable, their collective application must result in the same value for it, no matter in which order they are applied.</p><p>If Δ contains inconsistent updates for a state variable, this may be a bug or a feature of the simulation model. If it is not a bug, a conflict resolution policy is needed. The simplest policy is ignoring, or discarding, all inconsistent updates. Another common conflict resolution policy is based on assigning priorities to event rules.</p><p>Consider again our running example with a system state <i>S</i> = {queueLength: 1} and the set of next events <i>N</i> = {Arrival@4, Departure@4}. Then, R<i><sub>N</sub></i> consists of the two parameter-free change functions:</p><ol><li>F<sub>1</sub>: function () {Δ := { INCREMENT queueLength}; IF queueLength = 0 THEN <br /> <i>E'</i> := { Departure @ (4 + serviceDuration())}; RETURN ⟨ Δ, <i>E'</i> ⟩ }</li><li>F<sub>2</sub>: function () {Δ := { DECREMENT queueLength}; IF queueLength &gt; 1 THEN <br /><i> E'</i> := { Departure @ (4 + serviceDuration())}; RETURN ⟨ Δ, <i>E'</i> ⟩}</li></ol><p>No matter in which order we apply F<sub>1</sub> and F<sub>2</sub>, forming the union of their state changes always results in Δ = {}, because the incrementation and decrementation of the variable <i>queueLength</i> neutralize each other, and forming the union of their follow-up events always results in <i>E'</i> = { Departure@(4+d)} where d is the random value returned by the <i>serviceDuration</i> function.</p></section><section><h5>An Event Rule Set as a Simulation State Transition Function</h5><p>We show that the event rule set R of an ES model ⟨ SV, ET, R ⟩ defines a transition function that maps a simulation state ⟨ <i>S</i>, <i>FEL</i> ⟩ to a successor state ⟨ <i>S'</i>, <i>FEL'</i> ⟩ in 3 steps:</p><ol><li>R maps the set of next events <i>N</i> extracted from the <i>FEL</i> to a set R<i><sub>N</sub></i> of state change functions of rules triggered by one of the next events from <i>N</i>.</li><li>R<i><sub>N</sub></i> maps the current system state <i>S</i> to a set of state changes Δ and a set of follow-up events <i>E'</i>.</li><li>The pair ⟨ Δ, <i>E'</i> ⟩ amounts to a transition of the current simulation state ⟨ <i>S</i>, <i>FEL</i> ⟩ by applying the updates from Δ to <i>S</i> yielding <i>S’</i> and by removing <i>N</i> from <i>FEL</i> and adding <i>E'</i>.</li></ol><p>We have already explained how to obtain R<i><sub>N</sub></i> from R and how to apply R<i><sub>N</sub></i> to <i>S</i> for getting ⟨ Δ, <i>E'</i> ⟩ in the previous subsection, so we only need to provide more explanation for the last step: processing ⟨ Δ, <i>E'</i> ⟩ for obtaining the next simulation state ⟨ <i>S'</i>, <i>FEL'</i> ⟩.</p><p>We use the symbol Upd for denoting an update operation that takes a system state <i>S</i> and a set of state changes Δ, and returns an updated system state Upd( <i>S, </i>Δ). When the system state consists of state variables, the update operation simply performs assignments. Using this operation, we can define the third step of the simulation state transition function with two sub-steps in the following way:</p><ol type="a"><li><i>S'</i> = Upd( <i>S, </i>Δ)</li><li><i>FEL' = FEL <span style="font-family:monospace;">−</span> N </i>⋃ <i>E'</i></li></ol><p>This completes our definition of how the event rule set R of an ES model works as a transition function that computes the successor state of a simulation state:</p><p class="indented">R(⟨ <i>S</i>, <i>FEL </i>⟩) = ⟨ <i>S'</i>, <i>FEL'</i> ⟩</p><p>such that for a given initial simulation state <b><i>S</i></b><sub>0</sub> = ⟨ <i>S</i><sub>0</sub>, <i>FEL</i><sub>0</sub><i> </i>⟩, we obtain a succession of states</p><p class="indented"><b><i>S</i></b><sub>0</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>1</sub> <span style="font-family:monospace;">→</span> <b><i>S</i></b><sub>2</sub> <span style="font-family:monospace;">→</span> …</p><p>by iteratively applying R:</p><p class="indented"><b><i>S</i></b><sub>i+1</sub> = R( <b><i>S</i></b><sub>i</sub>)</p><p>Consider again our running example. In simple cases we do not have more than one next event, so <i>R<sub>N</sub></i> is a singleton and we do not have to apply more than one rule at a time. For instance, when</p><p class="indented"><b><i>S</i></b><sub>1</sub> = ⟨{ queueLength: 1}, { Arrival@2, Departure@3}⟩</p><p>There is only one next event: Arrival@2, so we do not have to form a set of applicable rules, but can immediately apply the rule triggered by Arrival@2 for obtaining a set of system state changes and a set of follow-up events:</p><p class="indented">r<i><sub>Arr</sub></i><sub> </sub>( <b><i>S</i></b><sub>1</sub>) = ⟨{ queueLength := 2}, { Arrival@4}⟩</p><p>Now consider a simulation state where we have more than one next event, like the following one:</p><p class="indented"><b><i>S</i></b><sub>3</sub> = ⟨{ queueLength: 1}, { Arrival@4, Departure@4}⟩</p><p>We obtain</p><p class="indented">R( <b><i>S</i></b><sub>3</sub>) = ⟨{ queueLength: 1}, { Arrival@5, Departure@6}⟩</p><p>assuming a random inter-arrival time sample of 1 and a random service duration sample of 2.</p></section></section></section></main><footer class="page-navigation"><table><tr><td class="page-navigation-to-previous"><a href="EventBasedDES-Intro.html"><span class="page-navigation-to-previous-icon" title="Previous page
Chapter 2. Event-Based Simulation"></span></a></td><td class="page-navigation-previous"><span>Chapter 2. Event-Based Simulation</span></td><td class="page-navigation-current"><span>2.1. Event-Based Simulation without Objects</span> <span class="page-navigation-current-page">(13/41)</span><a href="toc.html"><span class="page-navigation-to-toc-icon" title="Table of Contents
Table of Contents"></span></a><a href="_index.html"><span class="page-navigation-to-index-icon" title="Index
Index"></span></a></td><td class="page-navigation-next"><span>2.2. Modeling a Manufacturing Workstation as a Queueing System</span></td><td class="page-navigation-to-next"><a href="OEM-Example-Workstation.html"><span class="page-navigation-to-next-icon" title="Next page
2.2. Modeling a Manufacturing Workstation as a Queueing System"></span></a></td></tr></table></footer></body></html>